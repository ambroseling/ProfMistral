{"text": " All righty, welcome back to 105. So this is last lecture until our two-day break. So again, don't come to class on Wednesday and Friday. Do come to class next Monday. So let's get into this because we will need this when we start talking about Lab 9 stuff, and it might be useful."}
{"text": " So structures, what are structures? So in C, we can group together variables within something called a structure. It is a new type. And of course, it's C, so they couldn't have just called it structure. They called it struct. So they made it shorter because everything they had to make shorter. So the syntax to define a struct is, well, you just"}
{"text": " type the word struct, then give it a name, so a name representing what you want to call this group of variables. And then inside of the curly brackets, you can put as many variable declarations as you want. So as many variables as you would like to define, you give them a name."}
{"text": " Similar to an enum, short for an enumeration, well, you define a struct just below the includes, and typically you do not do it within a function. So, we'll spend the rest of the lecture talking about why we would use this, why it makes our life easier, and some motivation behind actually using it."}
{"text": " And if you've seen like Python or C++ or Java or anything like this, this will be familiar to you. Essentially, they just took the idea of a struct and made it a bit easier to use, but at the end of the day, it is the exact same thing."}
{"text": " So let's start off with a simple task. So we're just going to calculate the distance between two points. So I could write that as a function. So if I have two points, a point is an x and a y. So if I want to calculate the distance between two points, well,"}
{"text": " I could represent them as x1 and then y1 for the coordinates for the first point, and then maybe x2 and then y2 for the coordinates of the second point. And then if I want to calculate the distance between those two points, it's just the difference between the two x-coordinates to the power of 2. So I could write pow, the difference, and then 2.0. So that will just square it, and then plus"}
{"text": " the difference between the y-coordinates, so y2 minus y1, to the power of two, so again, we get some review using our math function, pow is just taking this as the base to the power of whatever the second argument is. And then, in order to calculate the distance, I just take the square root of all that, so I just give it to the square root function, which of course, they called squirt,"}
{"text": " short for square root because, of course, they did. And then if I wanted to use this, well, I could, in my main, I could define points x1 equal to 1, y1 equals to 2, x2 equals to 4, y2 equals to 6. And then I could calculate the distance, and then we can review. We can go ahead, just print it to one decimal place because it is a double value."}
{"text": " If I go ahead and run this, they get 5.0. That's the distance between them. This should be nothing new, right? Any questions about this program as written? Fairly straightforward. We're just going to make it much, much better today. So we're good. We're good. All right. So we could have written this at, like, what, week or lecture, like, 6, something like that."}
{"text": " For a function like that, for distance, not too bad to remember which variable is which. I have an x1, I have an y1, I have an x2, I have a y2. Not too bad to keep track of them. But what about if I write a function that just prints a point? So I just write a function just called print. I give it an x and a y, and then it will just print off the coordinates just rounded to the nearest 10th."}
{"text": " And while this is a bit awkward to use and might lead to errors, so just naming variables x1, y1, y2 is kind of a pain. If I accidentally write something like print x1, y2, that's one coordinate from one point and one coordinate from another point. So that probably doesn't make sense. It's really easy to do here. It might not be one of the two points we intended. And debugging it might be confusing because"}
{"text": " You just don't expect that. So since we learned what a structure is, we can just make a structure that represents a point. So we know a point is like a logical."}
{"text": " thing. So a point is a coordinate. So I could just create a structure called point. And then inside of it, I'm allowed to make as many variable declarations as I wish. So a point, I'll just say, consists of an x and a y. Again, they're going to be just doubles."}
{"text": " This will create a new type called struct point. And then you can just use that as if it was an int, a double, a char, a bool, whatever. So you can create a variable with it, but instead of just saying its type is one of the things we've already learned, you could create a new variable by saying struct point, and then I could say p1. So I could create a point called p1, and it would be"}
{"text": " the type of it would be the struct point that has an x and a y. So to access the inner variables or to access the variables within that structure, usually called fields or members by the compiler. So you might see some compiler messages where it calls them members. You can access them by just typing or after the name, just putting a dot. So for example, if I want to access x,"}
{"text": " of p1, it's just p1.x. If I want to access y, it's p1.y. So questions about that? We just get to group them a little better, and then we can go ahead and rewrite our function. So first, I'll get into a common trick you will see that"}
{"text": " is arguable whether or not it is clear or not, but we saw typedef before when we had enums. So the syntax of a typedef, just in case we missed that one on Friday, is you can type type, like typedef is a keyword, so you can do typedef, and then a already existing type, and then you can rename it to a new type, and then you can use it as either of the names. So."}
{"text": " In this, if I just do typedef, I don't know, typedef int num underscore T, then whenever I actually use a type num underscore T, then it would actually just replace it by an int. And then I can go, I can change this typedef whenever I want. Just creates a new name for a type."}
{"text": " So I can use this with a struct to make it arguably more readable. So we can create a struct without a name. So I could do something like typedef struct and then not give it a name, do the curly brackets, give it a x."}
{"text": " which is a double, and a y, which is a double. And then I name that unnamed struct point underscore t. So that is going to be my name for a type that's supposed to represent a point. So afterwards, I can create a variable with just point underscore t p1. And then I can access it like I could before. I could do p1.x, p1.y, so on and so forth."}
{"text": " Usually, unlike enums, you should still give structs a name. So if I want to do this, I could do typedef struct point, and then give it the curly brackets, give it the x and the y, and then give it the new name point underscore t. And now I have two names I can make it. I can use whatever one I want. I could use struct point. If I don't want to type struct, I can use point underscore t."}
{"text": " Both mean the same thing, just have an x and a y. So, if I wanted to create our two points and initialize the fields, I could do something like this instead, which seems..."}
{"text": " Like, I kind of logically grouped them here, but seems like a lot of work here. So I could create a point, underscore t, called p1, and then do p1.x equals 1, p1.y equals 2. Create another point. I'll call it p2, because I have original ideas. And then call it p2.x, or sorry, set p2.x equals to 4, p2.y equals to 6, and then"}
{"text": " that does essentially what I had before, right? But."}
{"text": " Turns out with structures, we can initialize them like arrays. So instead of doing all of that, I can just kind of borrow the same syntax as I have with arrays. So instead, to initialize it, I could write point underscore t, p1 equals, and then curly brackets. And instead of just setting array values, I'm setting fields in the struct in order."}
{"text": " So since my struct had x and then a y, well, this first one would set x, and the second number would set y. So this is the same as just setting p1.x equals to 1, p1.y equals to 2. But I can just do it whenever I declare the variable. I can initialize them straight up. So."}
{"text": " I could also do p2 equals to four, six, and that will be the values just in the order you declare them in the struct. If you want to set the values in some different order, there's a funnier looking syntax. So I can give it a curly bracket, and then I can say which field I want to set to what value. So if,"}
{"text": " I don't know, for some reason I wanted to set y first, but y was the second thing defined in my struct. Well, then I could just do .y equals whatever. So I could do .y equals 2, .x equals 1."}
{"text": " And yeah, there's a question how the computer stores these values. So it basically stores these values like an array, except that all the elements can have different types. So it does some magic to figure out where they should actually be in memory. So like arrays, they all have to be of the same type."}
{"text": " For structures, they don't have to be the same type. I could put bool, whatever. But they're stored more or less like arrays. And C gets to keep track of where they actually are in memory. But they'll be in one big chunk of memory altogether. All right. So now I can go back."}
{"text": " and I could rewrite this code. So I could be like, oh, okay, well, I should probably use, so create a struct, so I could do typedef struct point, give it a double X, give it a double Y, and then call it point underscore T."}
{"text": " So now I have my struct point, and I want to rewrite these functions in terms of points. So maybe for this function, what I would do is, well, it takes two points. So I could say point t, p1, just assume that they're integers or something like that. And then I could do point p2. And then inside of here, instead of just accessing"}
{"text": " x1, x2, well, they're from two distinct points, so instead of x2, that would be p2.x, and instead of x1, that would be p1.x. And then for the second one, y2 gets replaced by p2.y, y1 gets replaced by p1.y, and that should be it, my print function."}
{"text": " would be similar, maybe I want to replace it with the point. And then here, I would just do point.x, point.y. And then whenever I calculate my distance, so I could create P1, initialize it, so an x and then a y, create a P2 for,"}
{"text": " So saving some lines of code, and I'm also grouping things that are logically together. All right, there we go."}
{"text": " Doesn't that look a little better? It makes it clear that I'm calculating the distance between two points. And then I could also print off the value or just print out a point if I want. There's no printing one coordinate from one point, one coordinate from another point. They're logically grouped together in this struct, which for this, basically, it's like an array. So if I go ahead and run that."}
{"text": " Boom, should get 5.0, same thing, but helps me group concepts together. So any questions about these changes here? Yeah?"}
{"text": " Ah, so do I have to write this above all the functions? Yeah, so this I would have to write above all the functions because the C compiler's dumb. It just reads it from top to bottom. And if I use point underscore T without telling C what it is, it gets really confused. So we can see what that error actually is. So let's just move it down before this function. So."}
{"text": " The print function knows what point T is, but we'll see here we already have some angry, angry C compiler. So if we do this, it'll probably just say that unknown type name point underscore T has to come before everything. But yeah, good to see errors because that is a common one. All right, any other questions? All right, so how could this possibly get better, right?"}
{"text": " So, here's what we had. So, it worked. However, no one really writes this because remember, how does C work?"}
{"text": " deal with function arguments. So do functions get complete copies of things? Is C copied by value? Well, yes, it is. And unlike with arrays that just kind of get turned into pointers, well, the same confusingly doesn't happen for structures. They get copied."}
{"text": " Function arguments in C, again, so this is also review. They are copied by value. And sometimes structures can be very large, and it gets a complete copy of them. So even if your structure has like 1,000 variables in it, and it is, I don't know,"}
{"text": " 8,000 bytes large, well, each time we use a function there, they get copied by value, they get a new copy of the struct."}
{"text": " And of course, since they're copied by value, if we wrote function that would like modify the X and the Y, well, if we modified it in a function, we would modify that copy of the struct and not whoever called the function. So we wouldn't get our modifications and also it would be really slow. So in general, it's generally frowned upon to do structs just straight up by copying them by value."}
{"text": " And for speed reasons, for usability reasons, and normally programmers just always use structures as pointers. So if I want to write my distance function, I would write just a pointer to P1 and then a pointer to P2. So let's see what happens when I do that. So I change these to pointers."}
{"text": " And then in my main function, well, I can't just, just like if I was using scanf or something like that, I would have to give it the address of it, not the actual value because I don't want to copy the entire structure. So I'd give it the address of P1 and the address of P2. But now when I compile,"}
{"text": " It does a bunch of things. In fact, I get an error where it says P1 is a pointer. So now how would I actually access the value of P1.x now that P1 is a pointer? So think about what I would have to dereference to get that struct back from the pointer."}
{"text": " Yeah. Asterix? Yeah, the dereference. So instead of writing p2.x, what would I have to write? Yeah. Yeah, so I might have to write star p2.x, but that doesn't quite work, right? Because what it's trying to do here"}
{"text": " based off the precedence rules that you don't really have to remember. What this would do is try to take the field of this first, so like try to access p2.x, and then dereference that. So I have to tell the C compiler what I actually mean, so I could just put in parentheses, yep. Oh, yeah, whoops, I said it. Same thing, yeah."}
{"text": " We don't know that yet. Yeah, so if I wanted to do this without anything special, I would have to put parentheses around it. So I could do dereference p2 and then .x and because of the preference rules, I always have to do parentheses. So does this look nice to do and is this fun to do? So are we having fun right now if I change them all to something like that or does that look like really ugly?"}
{"text": " Looks pretty damn ugly, right? And it's not even working yet. I'd have to change this one. So we do this. And like the parentheses are not optional. I would have to have them."}
{"text": " So let's see, make sure we compile and it works. So now it works. But doing that, that looks like one of the ugliest things I have seen since, oh no, I woke up this morning and saw myself in the mirror. Ha ha, boom. Boom roasted, all right. So."}
{"text": " There's actually a special C operator to access fields through a pointer. So if I have a pointer to that structure, well, to access it, I would have to dereference P1, put it in brackets because I need to make sure the precedence rules, like I dereference it first."}
{"text": " So I have to do this. It's kind of a pain. There's actually a new operator that just looks like an arrow. So it is the minus sign and then a less than. It doesn't mean subtract anything and then, or wait, that's greater than. It doesn't mean subtract anything, make it greater than. It's supposed to look like an arrow. So it's supposed to look like it's pointing to something. So that combines dereferencing and field accesses."}
{"text": " in just one step. So instead of doing parentheses, dereference p1, end parentheses, dot x, kind of a pain, I could just do p1 arrow x."}
{"text": " So I can change it, I can make it a lot more readable, and this is what most people do. So I can just get rid of this. Instead, I could just do p2 because it's a pointer, p2.x, or arrow x. And this one could be p1, arrow x."}
{"text": " And then p1 arrow y. All right. So I could do that. That looks a lot better, right? OK, well, if they have to be pointers, it looks a lot better. So if you try to do something like,"}
{"text": " p2.x and p2 is a pointer, your compiler will, so this is probably, once you start doing this, this will probably be one of the most common compiler errors you'll see. It says p2 is a pointer, did you mean to use this? Did you mean to use the arrow? So it's telling you, instead of the dot, just use the arrow, even points to you at the dot you need to change and need to change it to an arrow."}
{"text": " So we would just go ahead, change that to an error. Get ready to see that compiler message a lot of times, because typically what will happen is you might write it the first time and write just point underscore t, and then be like, oh no, crap, he told me to make it a pointer."}
{"text": " And then you change it to a pointer. And then you just fix the compiler errors until it actually works is generally what ends up happening. So this one is preferred. So this is the preferred thing to do. Take the structures by pointers. And then, well, inside here, just use the arrow operator. Don't use the dereference in the dot. No one does that."}
{"text": " So yeah, we should always use a pointer. And to take my own advice, we should change this function as well. So here, I just change it back to a pointer. I get red underlines between the dot, because the dot needs to change to an arrow. Boom, boom. So now we compile. It works. Cool. So questions about that?"}
{"text": " OK, so just so you have it in the slides, change the functions to use pointers, and we just use that arrow operator. And also, just so you have it, can access fields with a single dot. If it's a pointer, you'll get this compiler error, which you will see probably a bunch of times. Luckily, it is an easy fix. It's just telling you to replace a dot by an arrow."}
{"text": " So maybe you decide that, oh, well, I want to create a structure dynamically."}
{"text": " And then, well, you realize that to do that, well, I have to malloc it just as usual. So I would have to malloc, and then I don't know how many bytes it takes, but luckily I can ask C. So I could say, hey, C, how many bytes do I need to store a point underscore T? And then I would get back a new pointer that points to that many valid bytes. And then I could just use it as,"}
{"text": " just a pointer. And then, well, because these things are grouped together, I would logically need to set the x to x, the y to y. And, well, if I have to do that all the time when I have to make one anyways, what usually happens is that you just create your own dedicated function for this. So here, I would do something"}
{"text": " I might call it point create. And then it takes in as an argument a double x and a double y. And then it returns a pointer to a new point underscore t. So here, I malloc it. I set the two fields. And then I return that pointer back. So that lets us create a point dynamically and initialize it in one step. So to create p1, I could just do point underscore"}
{"text": " T pointer called P1 is equal to point create."}
{"text": " one, and then two, and then as always, if I malloc something, I have to remember to free it. So I would have to remember to free this when I am done. So any questions about that function and what it does? So that should just create a point for us somewhere in the heap. We go ahead and we set its fields to just equal whatever we got from the arguments."}
{"text": " All right, so this is typically what you do in Java and stuff like this. This essentially is the thing that gets written for you and why people like Java. Yeah, so this is kind of like a constructor in Java if you have done Java before. But this is C. C is no hand-holding, so you have to write your own."}
{"text": " Usually when we write functions like this or just write functions that just deal with our structure, we just prefix all the functions. So in our case, we would name them all starting with something like point underscore. So I should define the other functions like point underscore distance, and then just take the points by pointer."}
{"text": " Wow, that's a lot of points in a sentence. And then for the other one, I would just call it point print instead of just print. So this is what my final thing would be. So any questions like that before we get into more fun stuff? All right, so this are things you should follow."}
{"text": " I'll preface this by saying this is more advanced C programming stuff. You might not be able to use it for this course. You might not want to use them for this course. But you will see this if you do any C programming or if you have seen other languages. But this is the stuff. Anything before this, you definitely have to know. Anything after this is just bonus. So."}
{"text": " Usually what happens, you're kind of encountering this with the recent labs, but usually, once we start writing bigger programs, we usually divide up our code between different files. So we could just write, I don't know, what was this called? This was called distance.c. Well,"}
{"text": " I started off by calculating the distance between two points. Then I created this point structure. Then I did a whole bunch of things using points. Then maybe I make my program, I don't know, do something with graphs or something like that. And then suddenly it gets bigger and bigger and bigger and bigger. And well, usually you want to divide things up to make them more manageable instead of just throwing everything in a single C file. So."}
{"text": " Usually what happens is people will just create a single C file for like all the related functions that operate on a structure. So how code is usually organized is I might call a file like point.c, and then that file would contain the definition or all the code for point underscore create, point distance, and point print, and then point,"}
{"text": " .c could also be the only file that defines the struct itself. We'll see a bit more on this later. This is more advanced usage, but again, do not hesitate to ask questions if I confuse you, because this gets fairly subtle."}
{"text": " So how we would organize our code, we've kind of used it before, like std.io and things like that. So what we would do, we'd create our own header file for these that would have the function prototypes for all of our print functions. So we would create like a point.h."}
{"text": " that would have all of our function prototypes, and that way we could use these functions in other C files, and remember just a .h, that's just called a header file, it's meant to just define structures, define function prototypes, and everything like that. So, our .h file would probably look like this, which has a few weirder things."}
{"text": " So it would start with the hashtag, is that what we agreed to call it? So the hashtag, the pound if you're old."}
{"text": " If something starts with a pound, that's something for the C preprocessor. So what the first two lines here and then the end if at the end do, you don't have to really understand it, but basically what they do is make sure that if we include this file, we only get a single copy of it. So it will check."}
{"text": " The C preprocessor, you can write like if statements and then define variables. So what this does, it says if not defined and then a name. So if a variable is not defined in the C preprocessor called point underscore H, then it defines it. So it creates a new variable called point underscore H."}
{"text": " and then it does all of this stuff and then it has an end if. So if I were to write like include point.h twice in a row, well, the first time we include it, this variable doesn't exist, so it would define it and then do, and then like copy and paste these lines. And then if we included it again, well, point.h already exists, so it wouldn't actually include all those function prototypes two times."}
{"text": " because C gets really snarky once you define something two times. It'll say like duplicate definition or duplicate declaration. Please choose one, you should only just give me one. So this is just to make some like C preprocessor magic to make sure that this file only gets copy and pasted once. Don't need to know the internals for that, but basically it'll always look something like that."}
{"text": " And then in it, we could do typedef struct point, point underscore T. And here, we do not tell it the fields. So we are allowed to just say, struct point. We're basically telling C, hey, we're going to create a structure called point. I will tell you what fields it has, when it is relevant to you. So if you don't need to know, don't worry about it."}
{"text": " I'll use it somewhere, and the purpose for this is to actually hide the structure. So if you modify it later on, then your code doesn't break in really, really subtle ways, which you would experience in other courses, which you might experience as software evolves, okay?"}
{"text": " And then otherwise, in our header file, we define our function prototypes. So any questions about this header file as it stands? Basically, it's telling the C compiler, OK, I'm going to create a struct called point. It's also known by point underscore t. And I'll go ahead and give you the function prototypes for these three functions. All right, cool."}
{"text": " Again, that header file, make sure it's only included once or copy and pasted once. And it hides the fields of the struct. Anything that starts with a hashtag, they're preprocessor commands. So that happens before you actually compile it. And then C will compile it after all that's done."}
{"text": " And just saying struct point and not telling it any fields has a special name that you might see. It's something called a forward declaration, which again is just say, see, I'm making a struct called point. Trust me, I will define it later, so don't worry about it. So."}
{"text": " Why I did this is because, well, I have to tell C what a point underscore T is. And it doesn't need to know what the fields are to be able to just create a pointer to it. Pointer is just an address to somewhere. So I can just use pointers for that struct. No problem. If I got rid of the stars here and I didn't have them, then C probably wants to know, oh, well, if I need to copy this damn structure,"}
{"text": " as an argument, well then I need to know what fields it has, how big it is and everything like that. So in that case, it would matter. In the case where you just have pointers, you can do this and it's fine, which is the third and most important reason that people typically just use pointers for arguments. So it's just to hide the struct."}
{"text": " So if I do this division, then in my main program, this is what I could do. So I could get rid of all of the point functions and just keep it to whatever happens when I start running my program. So all I do is I include point.h, then I have the type point underscore t, and I can actually use the functions point create. So here, maybe I create a point called p1, and then I print it."}
{"text": " Maybe I create a point called P2 again and then print it and then print off the distance between the two points by doing point distance P1, P2. And then after I'm done with them, I use point create, which did a malloc. So I had to make sure that I free them and it would look something like this. So any questions about that?"}
{"text": " Yeah? Yeah, so the question is basically, here, let's find it."}
{"text": " So basically, why is point.h in double quotes and the other ones in angled brackets? So this is a subtle thing. So if I tried to put mine in angled brackets, well, turns out,"}
{"text": " Probably actually works, yeah. So still, it works, no problem. The difference is really subtle of where C will look for things for you, but the usual practice is usually it doesn't matter, and the angled brackets you reserve for things from standard libraries, and then use double quotes for anything that you created yourself."}
{"text": " So it just lets you know, okay, this is the thing I wrote, this is the thing that's in the C standard library. Turns out, doesn't matter, but it's kind of just like a preference thing and like what people usually do. All right, so."}
{"text": " That's what our main program would be. So now our main program can't access the fields itself, which is actually kind of helpful because while you know that the user cannot just change the fields of the struct, anything that changes the fields of the struct are hopefully in your point.c file. So if something is wrong with it, you know exactly what file to go to, which really helps once you start developing larger and larger programs."}
{"text": " So it's more, and it's way more flexible if you can hide the details, but maybe you were like, oh, well, I wanted to actually change X or Y and like get the values of X and Y. How do I do that with a pointer? Especially if I just can't access the fields. So if I go back to my code here and let's say I tried to just use double X equals P1.X,"}
{"text": " Well, because I only have like a forward declaration there, whenever we try to compile this, it'll be like invalid use of incomplete typedef, which basically just means, well,"}
{"text": " In this header file, you just told me that you're creating something called struct point, which is a point underscore T. You haven't told me any fields, it's not actually complete. And if I try to use the fields, it just says, basically, I don't know what the fields are. Why are you asking for X? I don't know what fields this has, so don't try it."}
{"text": " So that is typically a nice thing to have, but maybe I actually want to access X and Y, so I need to create more functions. And typically, you create something called a getter function, so that can get the current value of a field, and then a setter function that will go ahead and modify the value of a field. So."}
{"text": " how most real programs will look, this would be my complete header file. So I would create a function to get the value of x. So given a point, which I take by pointer, I would return a double that represents the current value of x. If I want to set it, well, I don't have to return anything, I'm just modifying something. So the first argument would be a pointer to the point to modify."}
{"text": " and then a value to change the current x to, and then I would do the same for y. So, now I have the full functionality with it, but the user can't actually access x and y directly. So, questions about that one? So, I just added some more functions so we can go ahead, we can modify the fields if we want, or we could get their values. So, that's our complete header file."}
{"text": " Anyone that uses it doesn't know the definition of the stretch. And it's more flexible, and we can hide the details. So the details would have to be in our separate file. So we would create a point.c file, like I said before. Whoops."}
{"text": " Like I said before, that actually defines the struct and also has all of the definitions. So inside of point.c, well, I could include point.h. Turns out I don't really need to, but that's usually what you do. It's just a style thing."}
{"text": " And then I would actually define the structure itself. So I could do typed up struct point, then give it its fields x and y. And then we could have our point create from before. We could have our distance from before. And then the only difference would be we could have get x. So get x would just return."}
{"text": " the current x value. So we just go ahead and use that arrow. And then to set x, well, it would just be p arrow x equals x, whatever the argument is we get from the function. Same with y. And then same with print. So any questions about that?"}
{"text": " Cool, this is how people actually mostly use structures and mostly write programs so that they are logically separated in files. And it's much, much, much, much harder to screw things up. So here's just the code. So you have it in the slide. So that was the start of point.h, or point.c. That was the rest of it, and then the rest of it."}
{"text": " The only other step we need to do here is when we compile, we need to tell the compiler about both files. So it needs to compile them both together so that we have all of our code. So usually, you put your main function in its own file. So I might do something and put it in a file named main.c. And that has what I showed before. Just have main and then include point.h."}
{"text": " If I want to compile them, and if I want to do it by hand, well, then I have to tell GCC if I use that as my compiler. I give it point.c, main.c, and then dash o, so that is the name of the executable file. And then in this point, I use the math library, so I have to do dash lm. And then afterwards, we just run that main executable as before."}
{"text": " So just to show that there are no tricks or anything."}
{"text": " Here is point.c. Here is main.c. So that just has include point.h. Really readable. That's all it has is 16 lines of code. And if I wanted to compile it, well, it's just GCC, point.c, main.c, and then the output, I want to just call it main. Maybe I could rename it if I want. Doesn't matter. And then just compile it."}
{"text": " it would create main, and I could just run main as before. And here it would print off the first point, then the second point, and then the distance between the two points. All right, any other questions about that? So as thing gets bigger, so your labs probably won't get that much bigger, but"}
{"text": " You will see this as soon as you start programming more and more. If you read other people's code, they're not just gonna give you one .c file and then that's it. It's gonna be divided up into a lot of things and this is how they kind of start to fit all together. So with that, just remember, pulling for you, we're all in this together."}
{"text": " Hey everyone! In this video, I'm gonna give you an introduction to and an overview of quicksorts. And by the way, I recently restarted my Patreon page, so I would really appreciate it if you could check it out. I'm gonna put a link to it in the description below. Anyway, let's get started! So suppose you're given an array of integers, for example this one, and your task is to sort it in the ascending order, just like that."}
{"text": " And one approach you can use for this is QuickSort. QuickSort implements a recursive function, which we're going to call QS, that takes three arguments, the given array, L, and R."}
{"text": " L and R will be two integers that are going to represent the indexes that will show the section of the array that we want to sort. So for example, if you're given this array, and if L happens to be 4, the index of this element right here, and R happens to be 6, the index of this element right here,"}
{"text": " then after running this function with these particular arguments, this array will be like this. So the section of the array that's between L and R will be sorted just like that. So if you want to sort the entire array using QS, you just need to give the same array with L being 0, the index of the first element, and R being 6, in this particular case, the index of the last element."}
{"text": " And to implement this recursive function, qs, we'll first take care of the base case. That's when l is greater than or equal to r. If l is equal to r, if they are pointing to the same element, for example, this one, then that will mean that the section of the array that we want to sort has only one element. That's already sorted, so there's nothing to do."}
{"text": " And if l is greater than r, it's sort of the same thing. The section of the array that we want to sort has no elements. So there is nothing to do. And that means we can just return from this function. OK, so that's the base case. But what about the recursive case?"}
{"text": " For that, let's take a look at this example here, where we're given this particular array with L being 0 and R being 6, or the index of the last element of this array. In a recursive case, we're going to do what's called partition. I'm going to explain what it is in a second, but for that we're going to use this function called partition that takes three arguments, just like QS. It's going to take R, L, and R."}
{"text": " And this is going to do what's called partition for the array for the section between L and R. So let me explain what it means exactly. The first step for partitioning is to pick what's called a pivot. I'm going to explain what it is in a second. And there are different ways of choosing your pivot. But one simple approach is to pick the last element as your pivot. So that's this number right here in this particular case."}
{"text": " Then, the goal of this partition function is to divide this array into two groups. The first group is going to be all the numbers that are less than the pivot. So in this particular case, that's these three numbers, minus 2, minus 1, and 0. And those numbers should come to the left of the pivot. And the second group of the numbers that we're going to examine"}
{"text": " is gonna be the numbers greater than the pivots. So those are these three numbers, three, two, and four in this particular case. And these three numbers should come to the right of the pivots. And obviously the pivot should come in between those two groups of numbers. So in this particular case, after running the partition function, the array should look like this."}
{"text": " As you can see, after running the partition function, the pivots will come to the center of the array and all the numbers less than the pivot"}
{"text": " are to the left of it, and all the numbers greater or equal to the pivot are to the right of it. And we don't care about the ordering of the numbers within each group. These numbers happen to be sorted, but as you can see, these numbers in this group are not sorted."}
{"text": " Either way, another thing to note here is that we're going to write this partition function so that it's going to do that partitioning, and then it's going to return the new index of the pivots. So in this particular case, that's right here. And so it's going to return 3, or the index of the pivots. And then we can store it in a new variable, which we're going to call p here."}
{"text": " And I'm going to show you how to implement partition later. But let's just here for now say that we already have this function. So after partitioning the given section of the array, we'll already know that the position of the pivot right here is correct. So that means that this position isn't going to change after sorting this entire array. So all we need to take care of after partitioning is"}
{"text": " this group of numbers and this group of numbers. We need to sort this section and then this section. And we can do that by calling qs on this section and then qs on this section. We can do that with qs of r, l, and p-1. So here we're saying we're gonna sort the section of the array between l, which is"}
{"text": " right here, and p minus 1, which is right here. And then we're going to do the same thing for the other section with qs of r, p plus 1, and r. So we're saying we're going to sort the section of the array between p plus 1 and r. And by repeating this process recursively, we'll be able to sort the entire array."}
{"text": " Now, let's take a look at how partition might be implemented. But before I show you some code, I'm going to give you an overview of how it works. And for that, I'm going to use an example where we have an array of 11 elements, just like this one. And to explain it, actually, I'm going to jump into the middle of running this algorithm instead of at the beginning."}
{"text": " And I'm doing it that way because I think the middle part is easier to understand, and then, you know, I'm going to explain the beginning part later. Anyway, let's say here that we're trying to partition the entire array, and our pivot is the last element, 10, right here. And to run this algorithm, we're going to use two indexes, j and i."}
{"text": " j will keep track of the current number that we're examining. And this is going to be part of a for loop that we're going to use. So that for loop is going to say, move j from the beginning of this array up to the number that's right before the pivots. And currently we're examining this number, let's say."}
{"text": " And in each iteration of the for loop, we want to make sure that all the numbers we've seen so far are separated into two groups. The first group is the numbers that are less than the pivot. And the second group is the numbers that are greater than or equal to the pivot."}
{"text": " And we want to do it in a way that i, this index right here, will always point to the last number out of the numbers less than the pivots. In other words, there are two conditions that we want to always satisfy."}
{"text": " The first one is that all the numbers from the beginning up to i are less than the pivot. And the second one is that all the numbers between i and j, not including i, are greater than or equal to the pivot."}
{"text": " And like I said earlier, we're currently examining this number, 12, and those two conditions are already satisfied because 12 is already greater than the pivot. So we can move to the next number by incrementing j by 1. And at this point, one of those conditions is not satisfied anymore. And we can fix that by doing this. We're going to increment i"}
{"text": " by 1, or move i over here, and then swap the values at i and j, just like that. And that way, those two conditions are satisfied again. So all the numbers up to i are less than the pivot, and all the numbers after that, up to j, are greater than or equal to the pivot. So we can keep going, move j over here,"}
{"text": " And since this number, 16, is already greater than the pivot, there's nothing to do. So let's move j over here. And as you can see, the number at j is less than the pivot, so we'll need to do the same thing. Increment i by 1, or move i over here, and then swap the values at i and j, just like that."}
{"text": " OK, let's finish this up by moving j over here, or by incrementing j by 1. And then doing the same thing, increment i by 1, and then swap the values at i and j."}
{"text": " Alright, and as you can see at this point, this array has been grouped into two groups of numbers. The numbers less than the pivot and the numbers greater than the pivot. But the last thing we need to do is we need to make sure that the pivot is between those two groups. We can do that by swapping the pivots"}
{"text": " with the value at i plus one, this value right here. So let's swap those two values, just like that. And then we're done partitioning. Like I said, from our partition function, we're supposed to return the index of the pivot. So we can just return i plus one, because that's the index of the pivot."}
{"text": " Okay, so now that we hopefully understand how this partition algorithm works, let's take a look at some pseudocode. Like I said earlier, we're going to call this function, partition, and it's going to take three arguments, the given array, L, and R."}
{"text": " And this function is going to apply partition to the section of the array between L and R. Let's say here, as an example, that we're given this particular array with L being the beginning of the array, or 0, and R being the end of the array, or 6 in this particular case. And the first step of this function is going to be define the pivot."}
{"text": " And that's going to be the value at r, or the last element of the section of the array that we are trying to partition. And that's going to be 0 in this particular case. And then we're going to define i to be o minus 1. In this particular case, i will be initialized to minus 1. And then we're going to run a for loop."}
{"text": " for j from l, this element, up to r-1, the last index before the pivot. And in each iteration of this for loop, we're going to check if the current number that we're examining, or r of j, is less than the pivot."}
{"text": " If that's the case, for example, the current number we're examining, minus 2, is less than the pivot, which is 0. If that's the case, then we're going to increment i by 1, and then we're going to swap r of i and r of j."}
{"text": " So those two numbers happen to be the same number in this particular case, so we're swapping this number by itself, and nothing happens. But let's continue with this for loop. So after that, we'll move j over here, and since the current number that we're examining, 3, is greater than or equal to pivot, so nothing happens, and so we move j over here."}
{"text": " And at that point, this number is less than the pivot, so we're going to move i over here, and then we're going to swap the numbers at i and j. And just like that, we can keep going with this for loop until j is right here. At that point, our array is going to look like this. j is going to be right here, and i is going to be right here."}
{"text": " After that, we want the pivot to be between those two groups of numbers, and we can do that by swapping r of i plus 1, this number right here, 5, and our pivot, r of r. So that's this number and this number."}
{"text": " And once it's swapped, 0 will come here and 5 will come here. We just need to return i plus 1, the index of the pivots. OK, so that's my suit code. But you can check my actual implementation in Python and Java at this URL, too. OK, so that's the quick sort algorithm. But what about the time complexity?"}
{"text": " To understand this, we'll need to consider the best case, the worst case, as well as the average case. So let's start with the worst case. That's when the given array is already sorted, like this one, or when we have a lot of duplicates in the given array, like this one. And actually, the time complexity of these two cases will be the same. So let's just consider a case where the given array is already sorted."}
{"text": " For this particular example, to sort this array with the QS function that we saw earlier, we would call it with the given array 0 and 6. So 0 would be right here at the beginning of the array, and 6 would be the index of the last element of the array. And the pivot will be this one. And after running the partition function for the entire array,"}
{"text": " Actually, what's going to happen is the pivot will stay here and all the elements will stay where they are. So nothing is going to happen to this array. And after finishing partition, we'll need to call QS."}
{"text": " for the rest of the array, other than the pivots. We can do that with Qs of r and 0 and 5. And we end up doing the same sort of thing over and over again. So we would call Qs of r and 0 and 4 after that, and so on, until we get down to Qs of r, 0, and 1."}
{"text": " So the pattern we see here is that the number of elements that we need to examine in the QS function starts at, let's say, n, the number of elements in the entire array. And then we get down to n-1, and so on, n-2, up until 1."}
{"text": " So as I said, this is the number of elements that we need to examine in the QS function, each of these numbers, but it's also the number of iterations that we need to go through in our main for loop. To be precise, you might say if we have n elements given to the QS function,"}
{"text": " we'll need to go through n-1 for loops in our partition function, but it's roughly n. So if you want to add up the total number of for loop iterations that we need to go through for this entire execution of the function, then we can just add these numbers up."}
{"text": " So we get this one, n times n plus 1 divided by 2, which is O of n squared. And that's why we get O of n squared as the time complexity of the worst case scenario."}
{"text": " And what about the best case? Well, the best case is every time we chose our pivot, it happens to be the best choice. So it means it happens to be the median or the closest number to the median of the given section of the given array."}
{"text": " So as you can see in this particular case, the number of integers less than the pivot is equivalent to the number of integers greater than the pivot. In the best case scenario like that, we would start with n elements that we need to deal with in our QS function."}
{"text": " And then in the subsequent calls of Qs, we would have to deal with n over 2 elements in one of the calls, and n over 2 in the other one. It's going to be slightly less than n over 2, but it's going to be about n over 2. And in the subsequent calls after that, we would need to deal with n over 4 elements, and so on, until we get down to single elements."}
{"text": " And what's interesting here is if you look at each level, if you look at the top level, for example, you can see that we would go through about n for loops in our partition function in this level. And if you look at the second level, we can do the same kind of analysis for this call,"}
{"text": " in the partition function we will need to deal with n over 2 for loops and for this one we need to deal with n over 2 for loops as well so the total number of loops that we need to go through for the second level is going to be O of n as well or about n loops"}
{"text": " It's going to be the same thing with this level and this level as well. And this kind of analysis will show you that executing everything on each level will take off and in time. And you might say, well, how many levels do we have in this recursion tree?"}
{"text": " Well, we can use the same kind of argument as the one I used in my binary search video to show that at the number of levels here,"}
{"text": " is going to be about log n, or log 2 of n. So basically, what I'm saying here is that we have log n levels here, and for each level, the time complexity is O of n. So to find the total time complexity for the best case scenario, we can just multiply them together, and we get"}
{"text": " of n log n. So that's the time complexity for the best case scenario. You might say, what about the average case?"}
{"text": " Well, it's more tricky to think about. But given a few assumptions, we can actually show that the time complexity for the average case is also of n log n. And by the way, those few assumptions are first, that there are no duplicates. So we don't have a case like this. And second, that the ordering of the array is random."}
{"text": " And I saw this proof in a book I used as a reference to make this video. So in case you're curious about the proof, I'll put a link to the book in the description below as well. Okay, and before I go, I wanted to mention a few things to note about the implementation details."}
{"text": " The first one is how to choose the pivots. Of course, in our implementation, we chose the last element. But another method is to pick a random element as your pivot. Or equivalently, you can, before running our quick sort function, you can reshuffle the given array randomly, and then pick the last element as the pivot."}
{"text": " And another method for choosing the pivot is called median of three. The idea of this approach is instead of picking one element, you would choose three elements randomly from the given section of the given array, and then you would pick the median of those three numbers."}
{"text": " And that way, you'll be able to decrease the probability that you would pick a bad pivot for the given section of the given array. Okay, and the second thing I wanted to discuss is dealing with duplicates. Because as we saw, quicksort doesn't perform well when there are a lot of duplicates in the given array. One way to deal with this is called three-way quicksort."}
{"text": " In case you're curious about it, I'm going to put a link to a page that describes this method. But the idea of this method is that instead of dividing the given section of the given array into two groups, we divide it into three groups. The first group is going to be the numbers less than the pivot. The second group is going to be the numbers equal."}
{"text": " to the pivot, and the third group is going to be the numbers greater than the pivot. Again, in case you're curious about it, I'm going to put a link to a page with more info about it in the description below. Anyway, that's all I wanted to talk about in this video. I hope you enjoyed this video, and thank you as always for watching my videos. I'll see you guys in the next one."}
{"text": " All right, good afternoon. So we will be continuing our journey talking about processes today, and especially how you manage processes. So"}
{"text": " Now we have multiple processes, potentially, and right now we just kind of run them. They do whatever they want. They have that parent-child relationship, but we don't actually know how to use it or how to do anything useful with it. So just some more notes just to make it clear. So processes are assigned a process ID. Oh, yeah. Oh, screen again."}
{"text": " Okay, sorry. Processes, when they're created, are assigned a process ID, otherwise called a PID, or it's just an integer if you wanna think of it that way, whenever they're created, and then it does not change from that point forward. So as soon as you create a process through something like fork, well, fork is the only thing you can do,"}
{"text": " it gets assigned a process ID when it's created, that is a copy of whoever created it, and that's the only time it gets assigned a new process ID. And it doesn't change throughout its whole execution, and it's unique for every single active process. So on most Linux systems, like older systems, the limit is 32,000, and zero is reserved as being invalid, and one is kind of that special process, that init process that gets created."}
{"text": " So eventually, the kernel will recycle a PID after a process dies for a new process. So say if you have process ID 2 that exited and that no longer represents an active process, well, if you run out of process IDs, then the kernel would use 2 for a new process, assuming that 2 is already dead. So the limit for this on 64-bit machines is something like 4 million or something like that. So the limits might vary, and you can change them if you want."}
{"text": " But just remember that each process has its own address space or independent view of memory. And we can accomplish this through virtual memory, because each process thinks it has the entire memory space. And that's how the OS can actually make that illusion we saw before, where the same variable in two different processes had the same address, and changing it in one didn't affect the other."}
{"text": " It's because each process has its own address space, so its own view of memory. So if you change one, something on one, you don't change it on the other. So this is kind of bringing that state diagram back into it. This is how something like Firefox would create a process, or how we create a process with a fork. Eventually, you're going to launch your browser through some means, and it's going to be created, get a process ID like 1337, and then it would be in this created state."}
{"text": " where the kernel would have to load it into memory, load all the instructions, all that static information into memory, maybe set aside some virtual memory for things it requests like other variables and so on, and then it would go ahead as soon as it's created,"}
{"text": " It would go into this waiting state where it hasn't executed a single instruction now. It's just able to execute instructions. So it's loaded. Its process ID or its virtual CPU is pointed at its entry, its start one start instruction. And it's just waiting for the kernel to actually schedule it and actually run the instructions that are part of that program."}
{"text": " So eventually, the OS is going to say, hey, Firefox, you can run. It would do that context switch and change it to running. And it would go get the CPU, run some code. One of the things, if you're running it, you might open a new tab, which would cause Firefox to fork. Because part of the architecture of Firefox is every tab is its own process."}
{"text": " And now we now know each process is independent. So that means each Firefox tab, just building off processes, are also independent. So that's a nice thing that if you crash a tab on Firefox or Chrome, has the same architecture, it won't crash the rest of your browser."}
{"text": " Because the old architecture was, OK, you open a tab. It's in the same process. So if everyone has hundreds of tabs open at a time, if one of those crashes and your whole browser crashes, that'd be pretty bad. But if every tab has its own process and one tab crashes, well, you're all good, because your main one can just say, hey, that tab crashed. Just reload it. Do whatever you need to do."}
{"text": " So as part of running, Firefox would call fork, and then fork would go ahead. And then as part of that, you'd get a system call. So the kernel has to actually do all the tasks associated with that. So it would throw that Firefox process into the waiting state where it's ready to run. But we're doing a system call, so we're going to just sit it there because we're going to create a new process."}
{"text": " And then a new process would pop up. Boom, our Firefox tab. It would get something like process ID 1338 or whatever the next available one is. And its parent would be whoever called fork on it. So in this case, it's parent or ppid or parent process ID is our original 1337. And then it would go through the same process. So it's in this created state, but"}
{"text": " Most of the created state, instead of loading some stuff and initializing it, it will copy whatever forked it. So copy exactly where that is, exactly what it was doing, which is this fork call, and copy all of its contents of memory, all of its open files, everything like that."}
{"text": " And then it would be set in the waiting queue again. And this would be as part of the return for fork. So after this, they're both waiting. And the only difference between them at this point, they're exact clones of each other except for this relationship. And now, as part of the system called the return value of that fork. So in the browser, the return value of fork would be like 1338. And in this newly created tab here,"}
{"text": " the return value fork would just be 0 because it's the child. So then at some point, the CPU is going to choose maybe the main browser to run, maybe the tab. At this point, you don't know. It's up to the kernel to decide what to run. And we'll get into that later, how you make that decision. But for argument's sake, for you programming and argue about your correctness, you have to assume either of them could run at this point."}
{"text": " So Firefox goes ahead, runs for a while. The CPU would want a context switch, run something else. So it gets stuck in that waiting queue again. Then maybe the tab runs for a little bit. It runs, executes some instructions. Then the OS takes back control and says, OK, I need to run something else now. Maybe the browser runs a bit more. Then it gets thrown back."}
{"text": " then maybe the tab runs a bit more and then maybe it calls something like exit and then if it calls exit it goes into this terminated state and it's actually still around and we'll see how to actually delete a"}
{"text": " process today. So it just goes into this terminated state where it can't run anymore. It's done executing. It can't execute one more instruction. But all the memory associated with this process is still sticking around, and you can't actually delete that whole process from existence yet. What you have to do in order to delete them is do some type of process communication."}
{"text": " The rule in Unix and all kind of Linux-y, Unix-y operating systems is in order to clean up a process and all its resources, the parent has to acknowledge that it has terminated. So only when you acknowledge that process has terminated can you actually delete everything associated with it, including its process ID, and then go ahead and clean up."}
{"text": " So it would have to do something called acknowledge that process ID 1338 has actually finished. And then as part of that, it can go back and waiting and then the curl can go ahead and delete that tab. So that process ID is now no longer valid. It wouldn't have an entry in that proc file system because now it can completely be deleted."}
{"text": " And then Firefox would go on, run at some point, and that's it. So we have to maintain this parent-child relationship. So previously, we made sure that our parent exited last using sleep. So that's what that sleep was before. So I didn't get any weird ordering. But we don't need to do that."}
{"text": " Yeah, so I can't see images on that thing, so that's a rip. So previously, we saw that our parent exit last using sleep. So let's see what happens when our parent exits first and no longer exists. So let's see, vm. So in our wait example here,"}
{"text": " Let's make sure we can see it. So we have a fork. And then after the fork, we check the value returned. If it's negative 1, it means an error happened and our computer's probably dying. And then if it's 0, it's the child. So it can just sleep for two seconds. Let's go ahead and just say, printf child done sleeping. And now."}
{"text": " Before we get into wait, let's just go ahead and in the parent, we'll just call this calling wait, and we'll just exit the parent. So now, we would likely expect to see, whenever we run something, we would expect to see, you know, it would start at main fork, and then there'd be two processes, one going into"}
{"text": " One going on to line 13 here and one that wants to go to line 17 here. So line 13 is asleep for two seconds, which just puts that process to sleep. So likely my CPU is fast enough where this will happen within two seconds and then exit. So returning from main is the same as exiting. So now my parent process is dead. And then after two seconds, my child goes ahead and prints a message. So let's go ahead and do that."}
{"text": " So if I do that, what was it called? It was called a wait example. So if I do that, I see calling wait. And then I can actually type on my terminal again. And then it kind of just interrupts me and throws the child done sleeping at me, even though I can start typing again. And that's because my shell here"}
{"text": " It waits until the process it creates is done. And then as soon as it's done, it lets you type again. So it doesn't know about my child. So my child's still running whenever my process dies. So as far as the terminal knows, you're done running whatever you wanted to run. But then later on, after two seconds, it goes ahead and prints something. So any questions about that?"}
{"text": " Okay, so we are going to get into a way to prevent this from happening and make sure that all our process is finished before the main parent process dies."}
{"text": " So I'll say a little bit more about, so the parent process is responsible for the child and only the direct parent process. So as part of the things you do when you terminate is you return, you call exit with that number, and that's called an exit status."}
{"text": " So for example, whatever you call, if you return 0 for main, that's the same as exit 0. So that means the exit status of that process when it terminates is 0. If there's an error, typically it's just anything other than 0. So it'd be like 1 or something like that."}
{"text": " So whatever you call exit in that child process or the parent process, so far, no one's read that exit status at all. So the minimum acknowledgment you can think of is just reading the child's exit status. So if you create a process and it finishes, at minimum, you should know what that returned, if it exits successfully or if it had an error of some sort."}
{"text": " But there's two situations, because that assumes that the child process always dies first. But that doesn't have to be the case. So normally, the child exits first. And if the child exits first, well, like I said, you can't delete all of that information until you acknowledge it."}
{"text": " The state that that child is in from the time it exits before it gets acknowledged, we'll have weird terminology here. It'll only get worse as this course goes on. So it's called a zombie process. So it's terminated. It's dead. But it's still consuming resources. So that's where the name zombie comes from. So it's still consuming some resources on our system. And we can't get rid of it yet."}
{"text": " So that's why it's called zombie. And then the other name is if the parent exits first. So you create a child, and then you perish or exit or die. They like using the term die. A little gruesome, but if the parent dies and doesn't, and the child is now parentless, so now it is called an orphan. Very, very literal. And that is also something you need to handle as part of the operating system because"}
{"text": " Only the direct parent can acknowledge the child, and now if the parent's dead, well, who's there to acknowledge the child? So we will discuss this through some more examples. So luckily, this name is about the only non-gruesome name we'll see. So that acknowledgement process I was talking about is called wait, and you need to call wait on a child process."}
{"text": " So it has the following API. It takes an address to store the status of the process, and that is not just a number, it's coded, and you actually have to use macros to get some meaning out of it. And then other things it does is it returns the process ID of whatever the child process is that is now exited, that you've waited on, and it can now be cleaned up. So like all these C wrapper functions, it returns negative one if there's a failure."}
{"text": " It returns zero for a non-blocking call with no child changes, and that might seem kind of gibberish. All that means is, by default, what wait does is it waits for a child to finish running. So if you call wait and nothing has finished running yet, it will sit there and you'll be in that block state where the kernel will not let your process run anymore until one of your children have actually exited."}
{"text": " So that's the blocking version. There's a non-blocking version you might want to use in this course, maybe not, that you can just ask straight away, hey, do I have any children that are dead? And then it can respond instantly, yes or no. So zero is the no. If you don't specify that option, it just means that it will block and wait for a child to finish."}
{"text": " And then if it's greater than 0, you get the process ID of the child that had the change or the child that actually exited. So the wait status contains a bunch of information. And one of the things is the exit code, because calling exit is not the only way to end a process."}
{"text": " But for the purposes of this course, it will be exiting, and maybe one other way we'll talk about. But for now, you can just assume that processes exit by calling exit, or they get terminated by calling exit."}
{"text": " So you need to use our man pages if you want to use any of the other macros. And then wait will, like I said, wait for any child. And if you want to wait for a specific process to die, that is your direct children. So if you call this on something that's not your child, it will give you an error."}
{"text": " But if you want to wait on a specific process, so say you created eight children, if you wanted to wait on a specific one of them, you could use waitpid, which just takes another argument as with the process ID to wait for."}
{"text": " So here's our simple wait example. It just starts with main, and like we've been doing so far, it calls fork. So now after the fork, we have two processes. The only difference between them is the return value of fork. One will be zero, that's the child that's newly created, and the parent will have the process ID of the child. So like I just showed in the child, instead of having that print statement, it just goes to sleep for two seconds."}
{"text": " And I showed if there's a print statement after that, it kind of messes up our terminal and makes it look ugly. And then here is actually how you use wait. So it will say calling wait, it will create a variable on the stack, just an integer for something called W status. And that's the address that wait wants. So we call wait with the address of W status and it will write some value to there that we can actually read."}
{"text": " And it returns a process ID that we waited on. So hopefully it's the process we created. So it should match that process ID from fork in the parent because we only created a single process here."}
{"text": " So then we can use this macro here, this w if exited on the wait status. So that will just tell you 0 or 1, whether or not that process has exited. And for now, we can assume this will always be true for our purposes for now. And then if it's exited, you are allowed to use this w exit status macro that will give you the return value of that process, whatever it returned as part of exit."}
{"text": " So in the parent, it would say wait return for an exit process, whatever that process ID was, and then whatever status it read. So let's go ahead and see that. So I'll just get rid of my print statements in this. So any questions before I run this thing?"}
{"text": " So if I run it, what should happen is nothing happens for like two seconds. I don't get control immediately from my terminal because my parent process, the one that the shell actually executed, will go ahead and be calling wait. And it will wait for my one child to die, which will take two seconds, at least two seconds. And then after it returns from wait,"}
{"text": " It fills in that W status so I can actually start using it and get some information out of it."}
{"text": " So if I do that and I run my wait example, now I'm actually waiting for two seconds, and then it will finally return whenever my child is dead, and then say wait return for an exit process gives me the process ID of the child, and then that status, whatever it exited with. So any questions about that? Yep. Yeah, so if I have multiple children, then I need to call wait for as many children as I have."}
{"text": " Yeah, so you can select a child with that weight PID 1 that I showed. Whoops. Yeah, so there's this weight PID at the bottom. Sorry, there's another question. Yeah? What is the value of W status? So the value of W status is something you're not supposed to read directly. You're supposed to access it through those macros."}
{"text": " So it's supposed to be transparent. So instead of using W status directly, you should be using this W if exited thing. And if you look at man weight, it tells you what all these are. So you're not supposed to actually know what the values mean in there."}
{"text": " So instead of using W status directly, I use W if exited W status. And then if you read that, it says it'll return 0 if it exited normally, 1, sorry, 0 if it didn't exit and 1 if it exited. And then I use W exit status here. And W exit status is whatever it returns. So if I do something like,"}
{"text": " So the usual convention is if it doesn't return zero, it exits. So in this case, I'll change it so that the child returns two, and that would be thrown to exit. So my parents should be able to read that."}
{"text": " So if I do that and I wait for it this time, then I see, hey, the status is different now. It's a 2 because my child returned a 2. And usually, this would maybe change the behavior program if I know whatever I launched failed. Maybe I display an error to the user like, hey, your process failed or something like that. Yep."}
{"text": " So yeah, the question is, where in this code did the child exit? So the child goes into here, because it's the child. It sleeps for two seconds. And then it returns two. And it's in main. So return from main is the same as calling exit. And that's just the way C does things for you. So before, it returns 0, because you can skip to the last line, which returns 0. Yeah."}
{"text": " Yep. Yeah, it just went all the way to 0. If I didn't want to return from there, I could exit 3 or something like that, which should do the exact same thing. So if I exit 3, I didn't declare it, but whatever. Oh, no, it's good. So I didn't declare it, but whatever, it still works. But I can also just call exit. Yep."}
{"text": " In which one? If the child just never exited? Yeah. If the child never exited, by default, that wait doesn't have a timeout. It's just going to wait as long as it takes. So if you want a timeout, you can do that yourself. And that would be through that non-blocking call. You could just, hey, are you done yet? Hey, are you done yet? And you can not maintain control. But by default, it's going to wait there forever. Yep."}
{"text": " Yeah, so that's a good question. So the question is, what happens if I call wait without a child process? So let's just say, instead of fork, I just go pit equals down to re. I just make up something. Whoops, I need to define it still. So if you call wait without a process,"}
{"text": " And it gives you an error. So here, whenever I ran it, this, by default, your shell will actually tell you the exit status of whatever you just ran if it exits abnormally for some reason. So when I ran my process, it exited with this code 10. And if I go look at my code, please say I wrapped it properly."}
{"text": " that here, I check wait, I get wait pid. And in this case, this is probably garbage and it didn't exit properly. So it went into this else statement and just returned and just, it got an error from wait. So it just hit that exit with that, each child is just 10. So it died, yep."}
{"text": " Yeah, so the question is, what's preventing the parent from exiting earlier than child? And the answer is nothing. And we'll see that. So if the parent exit first, that's that orphan case we have. So this is the case where everything is nice and proper. So let's go back. Oops."}
{"text": " OK, so this is our normal case where we actually properly wait for our children. We don't die first. Everything is well and good. So let's go into what happens when that is not the case. So the first one is that zombie case where"}
{"text": " Maybe that child process is done, but the parent has not called wait on it yet. So it's just in that zombie state where it's still consuming some resources. So that means that child process is done. It's terminated. But it hasn't been acknowledged yet. No one called wait on it. And the process might have an error. That child might indicate an error. But nothing ever reads from it. So it's like that tree falling in the forest kind of thing. They kind of plug your ears."}
{"text": " So there's some things the operating system can do. So one of the things we'll see later in the course is the operating system kind of generates, interrupts two processes. So one thing it can do is poke the process and say, hey, your child died. You should probably do something about this."}
{"text": " But of course, because it's your program and you can do whatever you want, you're free to be like, yeah, sure, whatever, and carry on. So that's just a slight nudge where you don't have to handle it at all. So that's the most basic thing. So that form of interrupts for processes are called signals. And by default, there's some default handlers. The default handler for your child dying is to ignore it. Yeah."}
{"text": " Yep. Just the wait call. Yeah. So wait is the acknowledgement. So it and wait will wait for your child to actually exit. Yep. Yep. Yep."}
{"text": " Yep. Yeah, so the acknowledgement is returning from that wait and that process ID you get, that's what you acknowledged. Yep."}
{"text": " The question is, can you wait for a process that is not your child? And the answer to that is no. You get an error from the wait call, just like you would get an error if you tried to wait and you didn't have any children. So that's one of the error scenarios."}
{"text": " So in this zombie scenario, the operating system has to keep that zombie process until it's acknowledged, like something has to read its exit status at the very minimum. And if the parent ignores it, well, that's the zombie process, and it needs to be waited to be reparented, and we'll see what that means in a second. But first, let's see what a zombie process looks like."}
{"text": " Uh, zombie. OK, so this example starts off kind of the same. Here, I'll make it a bit bigger. So it starts off kind of the same. We fork. So now we have two processes. And they're exact clones of each other. But so far, nothing really interesting has happened. So one will have process ID 0. The other will have the process ID of the child."}
{"text": " So in the child, we go ahead. All it does is sit here, sit here, wait for two seconds, and then eventually it's going to fall through here. So I didn't show this earlier. Fall through here, and then after two seconds, it's going to return zero. So it's going to call exit, and it's going to be done."}
{"text": " Then in the parent process, what we're going to do, we're going to set up some temporary variable to use for a return value. And then all it does is sleep for one second. So likely, when it wakes back up, the child should still be alive and running because it just sleeps for two seconds and I wake up after one second."}
{"text": " So I wrote a little thing that, as part of your doing for Lab 1, so you're looking at that status file in PROC, and there's a bunch of information about it. One thing is its name that you're using. Another thing that's in there is its state. So in its state, you can read off what its state is, if it's running, if it's blocked, if it's whatever. And we can go ahead, read its state."}
{"text": " So we'll read at state, print it out. And if we get some error from that, we'll just return what that error is. Hopefully it works. And then the parent's going to wait for an additional two seconds. So by this point, whenever it wakes up from this sleep, it would have been running for three seconds. And our child's dead after two seconds. So our child should be dead at this point."}
{"text": " But so it's dead, but it won't clean up any of its resources because we're the parent and we were bad parents. It's been dead for like a whole second, which is an eternity. And instead of acknowledging it, we'll just go ahead and poke its dead body and see what its process state is just to show you that zombie states are a natural thing and I'm just not making it up."}
{"text": " And all it does after that is it reads its state, and then it just returns. So it never acknowledged the child whatsoever. It's just kind of in limbo. So if I go ahead and do that."}
{"text": " So a zombie example. So go ahead. So I see it's state here, it's sleeping, because I woke up after a second, and then I go to sleep for two more seconds, it's dead, and then I can see that, hey, reading from that file, it's in the zombie state, and the kernel actually tells you it's in that zombie state. So it means it's terminated, but no one's acknowledged it yet, and it's just kind of out chilling there, yep."}
{"text": " Yeah, so that's a good question. So we can see if the question is, hey, if the parent exits, does the OS finally clean up the resources associated with that? So let's go ahead and print out. Whoops."}
{"text": " So let's just print out the process ID of the child. So we can go ahead and poke around in that proc file system."}
{"text": " So if we do that, OK, so my child is 41031. It was sleeping, and now it's a zombie. Well, if it's still a zombie, it should have an entry in that proc file system, because that just read it. So let's see if it's still a zombie and if it still exists. So it was 41031. So if I do that."}
{"text": " It says, no such file directory because it got cleaned up by something, which is a bit of a mystery because I didn't acknowledge it. So if the rule is someone has to acknowledge it to be cleaned up, the natural question is, well, who did that? So."}
{"text": " That process, so that zombie process, whenever that parent exited, it became an orphan, right? And its parent is now dead, and it was also kind of dead, but no one acknowledged it. So it needs a new parent, and because it still needs a process to acknowledge it, that hasn't gone away. That's like an ironclad rule that will always be a thing."}
{"text": " So what your kernel does is it does something called reparenting. So if the parent is dead, it will go through a process of reparenting. So by default, it will reparent that process back to init, which is process ID 1. So it will just be like, hey, init."}
{"text": " you should acknowledge this thing, and that's one of the things init does. So now we know the two things init is responsible for. So init is responsible for creating processes and also acknowledging all the dead zombies that come in, or everything that gets reparented to it. So you can kind of think of it as the orphanage, if you want, if you go through this terminology. So,"}
{"text": " It kind of re-parents it, and now init's now responsible for acknowledging the child. And at this point, if init doesn't acknowledge the child, then you're just going to have wasted resources on your system, and they're never going to be cleaned up. So if you have a really bad init, then you're going to run out of memory on your machine faster. So hopefully someone good has written an init for you."}
{"text": " So let's just create an orphan and see what happens. So in this example, I call fork again. And let's assume that there's no errors. So in the child, I just say, hey,"}
{"text": " who's my parent, which will be whatever just created it. And then after that, I sleep for two seconds, and then I'll say, hey, who's my parent now? And after two seconds, the original parent sleeps for one second, so it should be dead. So it should have went through this reparenting process, and that system call just tells you who your parent is. So if I go ahead and do that,"}
{"text": " So I say, it says, oh, child parent process ID is 41124, whatever. And then after two more seconds, I can see my parents dead because I got control back on my terminal. And now it says the child's parent process ID after sleep is 701, which is not a knit and not one, which is kind of weird. But now we know, we can kind of figure out, well, what the hell is 701?"}
{"text": " So let's just go ahead and see. Oops. 701 status. Oh, that's a great file."}
{"text": " So 701, we'll go through all this crap. And it's something called systemd, which I said was init, usually what init is. So this is actually systemd, but this is like the user version of systemd. So it's responsible for cleaning up your processes. So this is what some init systems can do. And by default, things will get reparented to init."}
{"text": " But one thing you can do on Linux and other operating systems is you can essentially opt in to being the orphanage and saying, hey, if any of my grandchildren has to get reparented, instead of going to init, go to me instead and don't keep going up. So you can opt into this. And it's called being a sub-reaper."}
{"text": " which is a very great name. And it is actually called a reaper as well, if you want to get into the terminology. So you can opt into being a sub-reaper, which means, hey, I get to kill all the children, which is so fun, right?"}
{"text": " Yeah, terminology real bad. But if you go ahead and run that example, so that will work on macOS or something like that. And on my Mac, if I just run it directly, it gets reparented to process ID 1. So Mac follows the same rules, but uses a different init system. Yeah."}
{"text": " So in this case, I kind of had a... So..."}
{"text": " You can reparent a zombie or just a running process. So in this example, well, the child that had to get reparented was still running, so it was just a plain orphan process."}
{"text": " And then the other example I had, like the first example, where my child died first and I didn't acknowledge it, well, before the parent process died, it was already a zombie. So it was already a zombie, and then the parent died. So it became simultaneously an orphan zombie. So it was both at the same time. So it was a zombie whose parent is dead. So you can have both. They're not mutually exclusive."}
{"text": " And then what would happen, that orphan zombie would get reparented to a nit, likely, or something else. And then it would get acknowledged and then cleaned up right away. So in this example, when it got reparented for the orphan example, it was already still running. Let me go back to it."}
{"text": " So in this orphan example, when I got reparented, it was still running, because it was still doing that sleep thing. So I was actually still running, so I printed out who my parent was. But when you get reparented, you could still be running. You could be a zombie. Doesn't matter. All right. Any more questions? OK. If not, we see how well we understand things, and we go back."}
{"text": " to reading something a bit more difficult. Oops. So close that. So let's go ahead and try and read this program. And we'll try and argue about what it does. So in this process, or yeah, in this program, what's it do? So in main,"}
{"text": " It goes in this for loop, which starts at 1 and goes to equal to 4. So through this for loop, i will be equal to 1, 2, 3, and 4. Hopefully everyone understands that right. Still see everything still makes sense at this point. So it will call new process with i equal 1, 2, 3, and 4. So what do we do in new process?"}
{"text": " So a new process, it will fork. Uh-oh. So this is a fork within a for loop. So it will fork. And then if PID is greater than 0, it will just return. So thankfully, in the parent, nothing that interesting happens. So in the parent, it will fork and then immediately return. So it just creates a process, returns."}
{"text": " That's all it does. So in here, in the parent, it will just go through this for loop, and it will make four children. And then new process creates a children, child returns, creates a child, returns. So hopefully that's OK."}
{"text": " And then the more interesting case is what happens in the child. So it also checks if it's negative 1, just to error check. And my computer would probably be dying if that was true. So I go ahead and assume that that's true. And then now I'm in the child process. So each child will go ahead and print what's the ideas, which is whatever. It's just a function parameter. It's i."}
{"text": " Because they're exact copies at the time of the fork, well, first time through this, id equals to 1. It forks. At that time of the fork, id is 1."}
{"text": " and the parent would return, and then the child, it would also have ID as one. So it would come out here, and for the rest of that child, ID is always going to be one, because it's a copy at the time of the fork. So it should print off process one, and then this just prints off 10 times, so process one, zero, one, two, all the way to nine, and then eventually it exits, and it takes a second to print each one."}
{"text": " Now, when I call it with argument id 2, well, that happens another fork. And because 4 copies at the time of the fork, now the new process id is equal to 2, because that's when it got created. So it would get id 2, do the same thing, come into here, go into that for loop. So that process should print process 2, and then 0 to 9."}
{"text": " And then similarly, the same thing would happen with 3 and 4, hopefully. So any questions about that before I run that? So what should I see?"}
{"text": " So I created four processes. I should see, hopefully, I should see process one, two, three, and four, and they should all do print 10 times. So let's go ahead and see just what happens. Whoops. So if I go ahead and do that, I see that, hey,"}
{"text": " They print a lot of stuff and it's not necessarily in any order because I created four children and I just kind of let them go at it and see whatever happens, happens."}
{"text": " So I don't know what order they print. All I know is within a process, it still makes sense because it's still executing instructions sequentially, more or less. So I'll see process one, I'll see process one print eight, and then nine always, but I can't depend on any ordering between two processes. So let's just go ahead and verify that everything prints."}
{"text": " So here, we can just see what our luck was. So we created process 1 first, then 2, then 3. But when we executed it, well, process 3 printed 0 first, and then 2, and then 1. And then before process 4 even got to print anything, process 3 woke back up and printed 1."}
{"text": " And then process 4 finally came in, print out 1. And then eventually, we go through all the numbers. So every process will do the same thing in order between itself. But between all the processes, every time we execute it, we're going to get probably different orders. So this time, we got 3, 2, 4, 1, 1, 4. Execute again, 3, 4, 1, 4, 3, 2. You've no idea what the order is. It's always going to be different. Yeah."}
{"text": " Yeah, so the question is, why are they kind of ending it all at the same time? And the answer to that is, let me get, is because I have this sleep, because I'm essentially making them fall asleep for a second each and then letting them all battle it out. So I can go ahead and just remove sleep. So likely, likely that runs so fast that I might just see one process print everything it has."}
{"text": " So if I go ahead and do that."}
{"text": " Yeah, so I see, essentially, process one here got kind of the short end of the stick. It printed nine things, oddly not zero. And then process two printed everything all in one big chunk together. So you can actually see when it kind of switches. So it got really unlucky. Process one started, printed off zero, and then the kernel was like, no, no, no, no, no, it's process two's turn. And then it got chosen,"}
{"text": " Went all the way until it finished and then only process one went and then Process three went all the way to completion process for all the way to completion So likely printing something is really really fast and you get a fair amount of time Whenever it chooses to switch to you that likely you'll just print everything But if we run it over and over again, we'll see that you know, not necessarily the case so here"}
{"text": " Three got interrupted after it printed zero and then one, and then got interrupted before it got restarted again. But this is all some order that you can't really control if you just create everything and just say, hey, go for it. All right, any other questions before we wrap up? Nope, good, sweet. All right, just remember, pulling for you, we're all in this together."}
{"text": " Do it."}
{"text": " Now, see in this video we will discuss how 2D arrays are related with pointers, how you can access the elements of a 2D array with the help of pointer rather than using the array name, fine. See we have discussed the relationship between arrays and pointers, I mean that 1D array and pointers, you can check out that video also in that I button, fine."}
{"text": " Now see, let us take this, this is 2D and this is how we are going to declare the 2D area or you can say that initialize the 2D area. I have initialized this area at compile time only, fine. 3 into 3 means this 3 rows would be there and 3 columns would be there, like this. This is a 3 into 3 matrix."}
{"text": " 3 rows are there and 3 columns are there. These are the values and this is the actual representation of this 3 into 3 matrix or you can say this 2D array in memory. This is just a logical representation. Fine, we have taken that row measure implementation of 2D array. First of all this first row is to be stored 6 to 5, then second row and then third row."}
{"text": " fine so you can say that it's a 2d array is what it's an array of arrays how see in this case we are having 3 arrays if you see this one 6 2 and 3 this is what a 1d array"}
{"text": " this is another 1d array and this is another 1d array and each 1d array is having three integer elements fine and if you combine these three then it forms a 2d array so you can say the 2d array is what it's an array of"}
{"text": " arrays or this 2D array is what? It's an array of 3 1D arrays and each 1D array is having elements, how many? 3 elements, fine. So you can see this is what A of 0."}
{"text": " that 1D array A of 0 or this is what another 1D array the name is A of 1 and this is another 1D array and the name is A of 2 right. So a 2D array name A is having 3 1D arrays A0, A1 and A2 and each 1D array is having 3 integer elements, 3 integer values right."}
{"text": " So see, how you can write this, this A of 0s, you can say this. So this element, first element is A of 0. If you simply write A of 0, it means it itself a 1D array and the name of an array, name of an array contains what? Address of its"}
{"text": " that first element of the array or you can say it points to the first element of the array. So, if you write a of 0, it means it contains 100, the element of its first address. So, 100. If you write a of 1, it means it itself a of 1 is a 1D array and if you say a of 1, it means it is a name of array, name of array contains base address or you can say address it points to the first integer element in the array, first element is containing address 1 1."}
{"text": " 2 same a of 2 contains 1 to 4 or you can you can write it like this this a of 0 contains these 3 integer values this contains these 3 integer values and this contains these 3 integer values and this is the base address of these arrays fine so 2d array is what it's an array of arrays now let us take a pointer now I have initialized I have taken a pointer"}
{"text": " This is how you are going to declare a pointer variable. This point this variable this pointer variable is going to contain address of another variable and the data type of that variable is integer. So, it is a pointer to integer fine. So, here can we write p is equal to c p contains what address of some another integer variable address of integer variable. So, can I write here a"}
{"text": " the name of the array as we have discussed in 1d array in 1d array that is fine but here this is not right this is invalid now why so see if you write simple this a is name of 2d array and what array name returns array name returns the pointer to its first element"}
{"text": " So, now in 2D array first element is what in this 2D array we are having three elements this one, this one and this one you can say it is having three 1D arrays. So, if you simply write a it mean it returns what this pointer to its first element first element is what a of 0 it means it returns what pointer to a 1D array it is not going to return pointer to a integer."}
{"text": " So, but P can contain address of an integer variable only, so this is invalid, right? So, now here you can write, here you can write address of A of 0 and 0."}
{"text": " a of 0 0 means this value and address of this is what 100. So, it means address of a of 0 0 means it will return address of a integer variable that is this 6 is an integer variable it will return address of this integer variable and that is fine or you can write or you can write p is equal to a of 0."}
{"text": " that is also valid. Now why so? See if you write a of zero it means this first array 1d array fine. So if you write the name of this array the name of the array name of the array what name of the array always returns what pointer to its first variable fine or you can say address of its first variable."}
{"text": " So, it will point to here if you write name of there it will point to here address of its point to its first integer variable and 6 is what integer variable it will return 100. So, 100 will be stored at in this pointer because pointer can contain address of another integer variable. So, this is fine you can write this thing fine, but you cannot write p is equal to a of 0 and 0."}
{"text": " Why so because a of 0 and 0 it means it will return what value that is 6, but pointer cannot contain a value. So, this is invalid right. So, you cannot write this thing. So, now, if you want to print the address of this 2D array that is this base address that is 100 I have taken 100 here fine. So, if you want to print in hexadecimal form you can write down percentage p otherwise you can write down percentage u."}
{"text": " fine it will print in unsigned integer some integer value. So, you can print if you print in printf I guess you can write printf percentage u and you can write whatever you want to print. So, if you print I am not going to write the complete printf statement p right. If you simply print this p then it will return what because here"}
{"text": " we have declared a pointer p somewhere in memory this pointer is going to be allocated some memory location. So, this p is now going to store address of a of 0 0 that is 100. So, now, p is going to point here. So, if you will print this p then 100 would be printed fine or rather than p you can write what a simply the name of the array. So, the name of the array 2 d array it will give what"}
{"text": " the address of the first element first element is what a of 0 and the address of a of 0 is what 100 only fine you can say that base address of this is what 100 so it will print 100 or you can write address of a of 0 0 this will also print 100 fine or you can write address of a."}
{"text": " address of a means a means this array name complete array name address of a means it will give points to the address base address of the complete array the whole array base address is what 100 so it will print 100 or you can write asterisk a"}
{"text": " Now how asterisk a will print 100 because asterisk means dereferencing operator and it will print what the value at that address. Now see if you write simple a it means it will return what array name is a it will return what that pointer to its first element or you can say that address of its first element. Now in this array first element in 2d array is this complete 1d array right because it is having 3 elements 3 1d array."}
{"text": " So, a of 0 now asterisk a of 0 it means value at a of 0 value at this means this complete 1D array value does not mean does not mean that it is it is returning either 6 2 or 5 because at a of 0 at this address it will return at this element the complete 1D array fine. So, it will return what this this base address of this one that is 100 100 a of 0 contains what 100."}
{"text": " fine so it will return 100 or you can write a of 0 this will also return what 100 because a of 0 means a of 0 that is name of the array this this a of 0 means this name of this complete array 1d array name of the array"}
{"text": " If you write down name of the array that that will return what address of the first element in this array means the first element in this array is 6 address is 100. So it will return 100 fine. Although this a and address of a is returning the same value, but they are different how they are different. I will discuss in this video later. So now if you print a plus 1 in percentage f if you write a plus 1 then what should be the value see this a."}
{"text": " name of the 2d array it will return what pointer to this first element in this array first element is this complete 1d array that is a of 0 fine and this is a pointer a of 0 that is it is going to return a pointer to this one and if you add in a pointer if you add plus 1 it means it is going to point to the next"}
{"text": " variable that we have discussed in 1D array also. So, it will point here next variable in this is complete 1D array that is this A of 1 right."}
{"text": " it is going to point here now what it will return if you write a of 1 then it means it will return the base address of its first element or you can say it points to here the first element in this array the address of this one is 1 1 2 so it is going to return 1 1 2 from here you can see"}
{"text": " a will return this point a will point to a of 0 a of 0 contains 100 and if you add plus 1 then it will jump to the next element next element is a of 1 that is the complete 1d array so it is going to return the base address of the first element that is 1 1 2 or you can write address of a of 1 because a of 1 you can write in this form also address of a of 1 fine a of 1"}
{"text": " this array name address of array will return the base address of this array base address of this this complete array is 1 1 2 so it will return 1 1 2 only and if you write this one asterisk a plus 1"}
{"text": " then what should be the value then also it will return 1 1 2. How? See here a means same name of this 2 d array it is going to points to the first element or you can say it is going to return the address of the first element. Now, first element in this 2 d array is this complete 1 d array that is a of 0."}
{"text": " fine. If you add plus 1, if you add plus 1 in this case then it is going to point to the next element that is next element is also complete 1D array in this 2D array that is A of 1 fine. And if you do a strict A of 1, it means"}
{"text": " value at this pointer, value at this address, value is this complete 1D array, value is not a single integer, value is this complete 1D array, fine. So, it is going to return what this 1 1 2, this base address that is 1 1 2. So, it is also going to return 1 1 2 here or you can write a of 1 only."}
{"text": " because asterisk a of 1 is equal to a of 1 only. So, if you write a of 1 a of 1 means this one and array this is a complete array a of 1 is complete array and array name will points will return always the address of its first element. So, this is 1 1 2 it is going to return 1 1 2 only this can also be written something like this asterisk a plus 1 fine that we have discussed in 1d array also. And if you write address of"}
{"text": " a of 1 and 0 a of 1 means row number row is this one index of row is this one second row but index is 1 and column is 0 and address of this one is 1 1 2 so it is going to return 1 1 2 only this is also same fine. Now if you write asterisk a plus 1 plus suppose"}
{"text": " Now what it is going to print? Now see s3k plus 1 a is going to return what?"}
{"text": " this the address of first element first element is this complete array if you add plus 1 here then it is going to point to the next element in this array next element is also a complete 1d array and asterisk this means it is going to return this complete 1d array value is complete 1d array. So, this you can say the base address of or you address of this first element that is 1 1 2 if in this 1 1 2 you are going to add plus 2."}
{"text": " it means it is going to add how many bytes one integer is going to take 4 bytes that is 8 bytes. So, it is going to point here at 120. So, it will return 120 and if you want to print the value at 120 that is 3 then simply to print the value what you are going to take that dereferencing operator. So, if you you are going to print this value then simply you can write"}
{"text": " say this one this is same this is this is going to give you 120 and value at 120 if you want to print then just do a again write a dereferencing operator. So, it is going to print the value that is 3. So, you can say it is a double pointer you can implement you can also declare a double pointer and you can implement this 2D array fine."}
{"text": " This is how we are going to print the value. Now this is going to print the value at C. If you print A of 1 and 2, that will also going to print 3."}
{"text": " a of 1, row number is 1, this row 1 and second column 0, 1, 2 and second column that is 3, a of 1 and 2, a of here you will write plus this row number and here you will write column number. So, if you are going to print this value suppose this one 4, it means a of 2 and 0."}
{"text": " then in this form how you can write you can write asterisk again asterisk a plus this row number that is 2 plus column number that is 0 and this is going to print 4 right. So, in general you can write"}
{"text": " See this is how we are going to access a of i and j the value of 2D array, so if you want to write this in the form of pointer then how you can write you can write here asterisk again asterisk a plus i plus j this is same a of i j is equal to this one."}
{"text": " right or if you want to use the pointer then this pointer is also going to store this base address to rather than using this a you can write here the pointer name p or rather than this rather than this how you can write this see asterisk of a plus 1 is equal to a of 1 right so in this case here we can write a of 1 plus 2 plus 2 and you just write asterisk."}
{"text": " So, here simply you can write a strict A of this i plus j."}
{"text": " So, this this and this is going to be this is going to give you same result that is you can access the this values using either this one or this or this expression or rather than a you can write here p also that will also give that is also going to give you same result. Now, suppose if you want to print asterisk"}
{"text": " plus one and again asterisk. Now what should be the output of this thing just think about it. See asterisk a here step by step we are going to solve this a, a means it is going to return a is name of 2d array so it is going to return what"}
{"text": " if you write down name of an array so it is going to return pointer to its first element or you can say address of its first element. First element in 2D array is this complete 1D array fine. So, it is going to return pointer to this 1D array fine or you can say this address of this 1D array."}
{"text": " asterisk a, asterisk a means value at this address. Value is what? Value is this complete 1D array fine or you can say that base address of this address of its first element that is 100 it is going to return value at a of 0 is what 100 it is going to return 100 this element sorry the pointer to its first element that is 100."}
{"text": " 100 now 100 plus 1 this is a pointer if you want to add some arithmetic or some integer values and then it is going to what point to the next variable how many bytes is going to be added 4 bytes fine so it is going to point here at 104 so this is what 104 and a strict 104 means value at 104 is 2 so it is going to return what"}
{"text": " do here. Now the question for you is if you print asterisk asterisk a then what will be the output fine."}
{"text": " And if you print asterisk asterisk this p then what will be the output. So you are going to try this one and you are going to tell me in the comment box what should be the output of a and asterisk asterisk a and asterisk asterisk p. Now last point is at a of 1 plus 1 and address of a of 1 plus 1 what should be the output of these two values."}
{"text": " Here a of 1, a of 1 means this one the name of this 1d array and name of 1d array means it is going to return what? Thus pointer to its first integer value or first variable or you can say that address of its first integer variable that is 1 1 2 it is going to return 1 1 2."}
{"text": " 2 in this one if you add 1 then it is going to point to the obviously the next variable sorry the next value so that is it is going to point here it means it becomes 1 1 6 fine now what is the value of this address of a of 1 plus 1 see address of 1 if you print a of 1 and address of a of 1 both will return what this 1 1 2"}
{"text": " So you will say this and this will also return same value that is 116 but that is not right. How these things are different? See let us discuss it with 1D array."}
{"text": " then you will get it better. See now suppose we have taken 1 array 1d array size 3 elements are 1 4 and 3 address suppose base address is 200 next element for 204 and next is 208. If you print a and address of a a means name of the array see name of the array the address of a and a both will return 200 fine and same a plus 1 and address of a plus 1."}
{"text": " then you will say these are going to return same thing because a and address of a are same but that is different thing. See here a simple you are writing name of the array, name of the array means it is going to give you the pointer to its first value or you can say it is going to give"}
{"text": " you the address of the first element of the array. So first element of the array, first element of the array address is 200 that is why it is going to give 200 fine and address of A, address of A means it is going to give you the address or you can say the base address of the complete array."}
{"text": " for this complete array the base address is also 200 that is why it is going to give you 200 that is why these both are same but if you add plus 1 and plus 1 in that case they are different see a plus 1 a means it is it is pointing to the first variable first variable and if you do plus 1 arithmetic plus 1 in the pointer then it is going to point to the"}
{"text": " obviously the next element so it is going to point here that is 204 but address of a means it is going to give you the array the pointer to the complete array so that is also 200 address of a but if you do plus 1 plus 1 it means it is going to add how many bytes"}
{"text": " size of array is 3 so 3 into 4 that is it is going to add 12 bytes because it is going to give you the address of the complete array so now in this case it is going to point here after this complete array here the next part so it means you can say this plus 12 that is 2 1 2 it is going to give you 2 1 2."}
{"text": " same in this case a1 plus 1 that is 116 now address of a1 plus 1 address of a1 a1 means this this array this 1d array address means this it is going to give you the address or the base address of this complete 1d array that is 1 1 2 ok 1 1 2 plus now if you add plus 1 it means how many bytes is going to add see"}
{"text": " Size of array is 1, 2 and 3. 3 elements are there in this 1D array. So, 3 into 4 that is 12 bytes. That is 12. It means 1, 2, 4. So, that is why now it is going to point from 1, 1, 2 to here. 1, 2, 1 to the next element. It is going to switch this complete array. Then it is going to point this the next element of or you can say the next 1D array that is 1, 2, 4."}
{"text": " this is the difference between this and this. See I cannot discuss everything in one video so it's up to you. You can try different different expressions like this like this or any other expression and you can check out what the output is fine. So I'll see you in the next video till then bye bye take care."}
{"text": " Now see, as we have discussed how to reverse a singly linked list, right? What reverse means? Suppose I have 4 node in the list, right?"}
{"text": " In circular linked list, the last node will contain address of the first node and we are maintaining only the tail pointer. Tail pointer is containing address of the last node, right. So, now what reversing means? We are not going to swap these nodes, right. What we actually do? We are going to reverse these links. See, here each node is containing address of the next node, right. But after reversing what it should look like? This node would contain address of the previous node. We are going to reverse this link."}
{"text": " right means now see this node is containing address of the next node that is 150 but after reversing this node would contain address this should contain address of the previous node that is here we will store 500 right this node also contain address of the previous node that is we are going to reverse this link we are going to reverse this link so see it is almost same as reversing a singly linked list that we have already discussed only difference is what now in this case last node is containing address of the first node"}
{"text": " But after reversing obviously we are going to reverse this link also. So now this node is containing address of this node. Now we are going to reverse this. Now this node should contain address of this node that is this node now should contain 600. So now we are going to reverse this link because after reversing this should be the last node. And one more thing now after reversing tail would point here."}
{"text": " So, when you will display the linked list after reversing then it should print minus 3, 6, 1 and 7. Now for this, how you will do this reverse operation? See, suppose at some point of time I have a pointer to this node."}
{"text": " Obviously, we are going to take some pointers extra pointers because we cannot move this tail right. So, for reversing we are going to traverse the link this list and with the traversing only we are going to reverse these links right. So, now, suppose I have a pointer temp pointing to this node. Now, when this node"}
{"text": " I should store what value of address of this node for reversing this link right. So, suppose I have stored temp of next equal to from where I can get this address in tail I have this address. So, temp of next equal to tail it means here I have stored what rather than this I have 600 now. So, now, you can say this link is no more now this node is pointing to this node."}
{"text": " ok fine but now this link is no more then how you will reach till this node because obviously we are going to reverse this link also this link also right we need to reverse all the links. So now suppose by applying some logic I will tell you that logic we have reached till here we have moved our temp here."}
{"text": " We will discuss that logic also when we will write that code. Now, in temp of next, I will store what? This node, address of this node, address of previous node. So, we have to maintain address of this node also, because if you remove temp here, then how you will, from where you can get this address 500."}
{"text": " because we have only one pointer left but tail pointer is pointing to the last node right. So, now, you have to maintain one another pointer suppose I am taking previous pointer. So, before moving temp forward we are going to set this previous also. Now, in previous we have 500. So, we can write temp of next is equal to previous that is also fine. Now, you have broken this link and now here I have 500. So, this is now pointing to this node right. Now, how you will move here?"}
{"text": " So, you need some extra pointer one more pointers. So, basically 3 pointers we need here fine. What you can do before setting this before breaking this link before setting here 500 what you can do? We can set suppose a pointer next node third pointer to this node."}
{"text": " and how you can do in next node we can write next node is equal to temp of next that is 150. So, here I have in next node we will have 150. So, this will point to here. So, now, you can break this link you can set temp of next is equal to previous and we have a pointer to next node also. So, we can reach till this node right after that we can move this temp then we will move this previous also and the next node become this one."}
{"text": " And now we are going to move till this node. Right? Till we reach here. Till the last node. It means we are going to take basically three pointers here. Rather than temp I am taking about current. You can take any name. Current, previous and next node. Right? So see how we will write down the code for this thing."}
{"text": " So, as you can see we have declared three pointers preview pointer current and next node and these pointers are pointer to node because these are containing address of the node. So, here I am taking struct node right this thing I guess you already know that user defined data type the two parts are there of this node data part and one is next pointer this will contain address of the next node we have maintained only the tail pointer right. So, this thing we this is what the global part this we are going to use in all the functions if you call that create"}
{"text": " CLL function, display function or this function. So, this thing I am going to write globally out of all these function and out of main function you can say after header files directly right. After that you can define this reverse function. Now, see we have taken three pointers. Now, for reverse obviously, we are going to traverse the link."}
{"text": " For traversing we need one pointer. So, I am taking that current pointer that is main pointer. These previous and next node you can say these are supportive pointers of this current. One is containing one is storing address of previous node and this will contain address of the next node right. So, first of all what you will do?"}
{"text": " Now, we are going to start from head node, from the first node we are going to start the traversing. So, we are not having any head pointer. So, how you can come to know that the which node is the first node. So, tail of next this will always contain address of the first node. So, how we can do current is equal to tail of next."}
{"text": " it means now current is pointing to this node in tail next we have 500 in current now we will store 500. So, now, as you can see this current is pointing to this node that is to the first node right. Now, you can check if tail is equal to 0 it means list is empty you cannot reverse the list right. So, you can after this you can write down this condition also if tail equal to equal to 0 it means list is empty you can print this thing."}
{"text": " or if you want to print that thing also that if suppose in list we have only one node how you can check that thing we have discussed when we were discussing how to delete node from the circular link list right. If suppose only one node is there then tail would point here and current would point here right and this node would contain address of itself that is here also 500 here also 500. So, you can check else if"}
{"text": " that tail of next is equal to is equal to tail or you can say current of next is equal to is equal to current right. In that case you can directly call that display function or you can say that there is only one node in the list and only this if 7 is the node then 7 would be printing after display after reversing the list else we are having 4 nodes now. Now, see what is the situation now how you will write this thing here I will write a"}
{"text": " while this current because for traversing we are using this current node when you will stop here right. When this current becomes when current will point here it means current is pointing to the tail node it means current becomes equal to tail. So, we are going to move till current becomes until current becomes tail. So, current not equal to"}
{"text": " till then we are going to move this current right. So, before moving this current obviously, first of all we are going to set our previous pointer right. So, here you will write this prev is equal to current. Now, this prev is containing 500. So, now, this is pointing to this node right. Now, only difference in this case is"}
{"text": " now it should have address of the this node right because we are going to reverse this link also right but at starting we will not reverse this link we are going to reverse this link at last fine because if in while loop only you will write this statement now i can write previous of next here i want to store address of this thing that is 600 so here i can write previous of next is equal to tail"}
{"text": " So, if you write that statement in while loop then. So, when after some iteration current would point to this node in that case previous would point to this node right because this is the previous node. Now, again that condition would be executed means previous of next is equal to tail. So, previous of next is this pointer now. So, here you will store address of 600. So, now, this node would point to this node."}
{"text": " But that we don't want. And after that previous would be this one, current would be this one. In that case also previous next is equal to tail. So again and again that line would be executed. So we don't want that thing. So first of all we are not going to reverse this link. We are going to reverse what?"}
{"text": " next links it means we are not going to change this value it means we are not going to break this link right. So, this link is still there we are going to break this link first of all we are going to store here what address of the previous node that is 500 fine and this link would be there still this link would be there at last we will update this pointer."}
{"text": " So, now here obviously, we will move this current now. So, here you will write current is equal to. So, now, in current what do we need to store the value of this node because we are going to move this current now current is pointing to this after that current will point to this node that is 200 right."}
{"text": " so now here how we can store this 200 in current see now here you need to set this next node pointer also see at starting we have set current is equal to tail next so after this line after this line before this if statement what you will write what you will write you will set next node also next node equal to current of next"}
{"text": " It means we have set both current and next node pointer. Now, what is current of next? Current of next that is 200. So, here now I have 200. So, now, this is pointing to this node right. So, we have set both pointers at starting current and next node. After that you will write this if condition. If tail equal to equal to 0 here you can print list is empty right."}
{"text": " and in else part you will write this while loop. Now, see in current what you will store address of this node from where you can get address of this node that is next node is containing this node address of this node. So, now, current is having 200 right. So, now, current is pointing to this node fine. Now, we have previous we have set previous pointer also current also we have right. So, now, we can update this part."}
{"text": " Here you will store address of previous node for reversing that is 500. So, here what I can write how you can access this part current is equal to sorry current of next equal to how you can access this part current of next equal to prev whatever the value in previous node right. So, now, see prev have 500. So, here we have 500 now this node is pointing to this node."}
{"text": " this link is no more now. So, now see the problem is next node is also pointing to this node now how you can reach till this node. So, this thing you need to take care you will you need to write which line first. So, first before updating this we will move this next node in next node we want to store 150 from where I can get 150 here before updating here I was 150 I was having 150 right. So, here you can write before this line next node equal to"}
{"text": " current of next. Current next means here before updating 150 was there. So, now, current node is pointing to this node right. And now you can update this now current of next is equal to previous that is 500. Now, you can break this link there is no problem because we have already set a pointer to next node right. So, now, we will we are going to repeat these steps till here see again while you current node equal to tail current is 200 tail is 600."}
{"text": " so that is fine condition is true again we will enter into this loop now previous is equal to current that is in previous we will store 200 so now previous is pointing to this node right now we will move this current current is equal to next node in next node we have 150 so in current we have 150 now current is pointing to this node right"}
{"text": " again we will move now next node should point here next node is equal to current of next current of next current is pointing to this node so current next is 600 so in next node we have 600 so now next node is pointing to this node."}
{"text": " So now we have set three links now you can update this value. So now here see how you will access this part link to this node is current of only current is pointing to this node. So current of next equal to previous in previous you have 200. So here you will store 200. So see what address of previous node is 200. So now this is pointing to this node."}
{"text": " right again current is not null sorry tail current is 150 tail is 600 so the condition is true we are going to enter into this loop again see previous is equal to current so here we will store now whatever the value in current that is 150 right so now you can see previous is pointing to this node we will move this current current is equal to next node so here we will store 600 right so now current node is this one and now next node is"}
{"text": " Next node equal to current next now in current of next we have 500 so in next node we will store 500. It means you can see next node is containing address 500 that is now this next node this next node would point to this node right to the first node fine. Current of next current is pointing to this node current of next is equal to previous in previous we have 150 so here I will store 150."}
{"text": " So, it means now 150 this is pointing to this node right. So, this link was no more now 150. So, this link has been broken now right."}
{"text": " Now we need to set this link. See, we have set all the links. Now you can see say current not equal to tail. Now current is 600, tail is also 600. So this condition is not true. So we are not going to enter into while loop. Fine? So now you need to update two things. Now we will set this pointer. See this node is the last node now. So this node should contain address of this node now. Fine? Because this would be the first node, that is 600. Now how you can access this node?"}
{"text": " Pointer to this node is next node. Right? So here what you can write. In next node, next you will store address of this node that is 600. And we can, we already know the last address, sorry the address of last node is always in tail pointer. So here I can write tail. It means next node next. Here I am storing 600. So now as you can see this is pointing to this node."}
{"text": " Remaining one thing is what you have to move this tail. Now in tail, tail should point to this node, right? So in tail we want to store 500."}
{"text": " So, how you can get this 500 see pointer to this link is next nodes next node is containing 500. So, in tail I can store whatever the value in next node fine. So, now, in tail we have 500. So, tail is pointing to this node right. As you can see we have reversed all the links as well as tail is pointing to this node. And now when you will display when you will call that display function then what the value should be printed minus 3, 6, 1 and 7."}
{"text": " So this is how you can reverse a circular linked list. See after reversing and this link is also not there now."}
{"text": " So, this is I guess same as reversing of a singly linked list only the simple the difference is what here the last node will contain address of the next sorry the first node right. So, you have to take care of that link also and that link we will update in the last. So, after this you can write void main function in that main function you can first of all create this linked list you can call that create CLL function then display function right. Then output would be before reversing 7 1 6 and 3 then you can call"}
{"text": " reverse function and after that again you can call display function. So, after that output would be minus 3 6 1 and 7 right. So, in next video we will see the implementation of a doubly circular linked list. See it was what a singly circular linked list fine. So, I will see in the next video till then bye bye take care."}
{"text": " and we have discussed how to reverse a singly linked list to check out those videos i'll provide you the link in the description box you can check out there the complete series on linked list in data structure fine you can check out in the description box so now this is a doubly linked list it is having four nodes and i want to reverse this doubly linked list see"}
{"text": " i don't want to swap the nodes like this this node and with this node seven would go here and six would go there like this i i'm not going to swap the nodes what i'm going to do is i'll just reverse these links fine that uh processor we have already discussed in singly linked list how to reverse a singly linked list fine so now"}
{"text": " how you will reverse these links see we are having a head pointer and a tail pointer without tail pointer also we can reverse this link this doubly linked list fine now see what i want to do is see the this next pointer of this node is containing address of the next node right and the previous pointer is containing address of the previous node there is no previous node that is why it is null so after reversing what i want to do so now in the next node"}
{"text": " In the next node I will store the address of the previous node not the next node after reversing. It means see in the next pointer of this node address of the next node is there but after reversing I want the next pointer of this node contains address of the previous node means it should contain 0."}
{"text": " And see this previous pointer of this node is containing address of the previous node. No previous node that is why it is containing null. But after reversing what I want this previous pointer will contain address of the next node that is 150. So here there should be 150."}
{"text": " this is what reversing means swap these values fine and finally swap this tail would point here and head would point here fine same here see this node how you will do the previous pointer of this node is containing address of the previous node but after reversing i want what this previous pointer should contain address of the next node that is i want here what 500"}
{"text": " The next pointer should contain after reversing the address of the this this previous node that is 200. So, here 200 right this is what the reversing means this is what I will I will implement fine. So, simply what what we are doing we are swapping these values 200 here 500 here 0 here 150 here this 150 here and this 400 here."}
{"text": " this is what we will do here we will write what 0 so this 0 would be here and this 500 would be here after reversing fine so now how we will do this thing see here obviously we are not going to move this head fine so we will take what another pointer suppose I am taking a temp pointer and temp is pointing to this node suppose temp is pointing to this node and temp is containing what this 200 fine."}
{"text": " So now how can we do swapping suppose here I write how we can access this part temp of next is equal to here I want to store what I want to swap these values so this value 0 I want to store here so how we can write temp of previous means the temp of previous value 0 now would be stored here rather than 150 fine. Now it means this link has been broken there is no link like this."}
{"text": " Now, here I want to store what 150 this this address of this node. But now from where I can get this 150 because see we have already broken this link. So, here we have now 0 we have do not have 150. So, from where I can get this 150. So, that is a problem. Now, if you if you will see ma'am we are not going to implement this 150 we are not going to update this 150 first we will update this node first."}
{"text": " So, rather than writing this line what I can do you suppose if you write temp of previous. Now, temp of previous will contain the value this value 150. So, here I can write temp of next it means here I do not have 0 now I have 150 right. Now, here I want to store what this value 0, but here we have already updated that is 150. So, from where I can get this value?"}
{"text": " It's not like that we simply write temp of next is equal to 0 and that is fine. No, because here I cannot write suppose at some point of time temp would be here. So, I cannot write here 0."}
{"text": " we are our main motto is what we are going to swap these values. So, now, we cannot do this thing now what we can do we have to store this address also we need some another pointer. So, now, we are taking one more pointer suppose I am taking one more pointer here that is I am taking the name next node right and I am not taking temp I am taking what current."}
{"text": " you can take any name temp temp 1 as you wish fine and when I assign this current is equal to head means now current this pointer is containing this address at the same time after that I will assign what next node in next node I will"}
{"text": " assign 150 from where I can get 150 so I will write next node is equal to here from here I can get 150 that is current of next now next node is pointing to here now you can update this thing."}
{"text": " Now, if suppose you write current of next is equal to current of previous means you have updated this thing here we have 0. Now, here I want to store this value that is address of this thing 150. Now, from where I can get 150 because this thing we have already updated. From here I can get 150 because I have set a pointer to this node already before updating before breaking this link."}
{"text": " So, now I can write current previous is equal to next node and after that we will move this current and next node would be this node now."}
{"text": " So, you have to maintain what 2 pointers fine. So, now, I will write the code see. So, now, this thing I hope everybody knows we have discussed many times what is this we have defined our own data type the data type of this node that is struck node 3 parts are there 1 is data part and 2 are next and previous pointers right and we have already we have declared here 2 pointers that is head and tail."}
{"text": " So, here I can write asterisk head asterisk tail or if you do not write here simply you can do semicolon here and after that here you can write this data type struct node asterisk head and asterisk tail fine. After that you can call that function create dll that we have already discussed and you create this doubly linked list and after that we will call a function that is reverse of this dll. So, now I will define this function that is reverse."}
{"text": " reverse doubly linked list right. So, now in this case now for reversing this list for reversing these links we need two extra pointers right. So, here we will declare these two pointers and how to declare I think the syntax you already know because we have already discussed"}
{"text": " the syntax many times in the previous videos right. So, now, I have these 2 nodes sorry these 2 pointers current and next fine. Now, see if you can write down a condition if head is equal to is equal to null, it means there is no node in the list, list is empty. So, we cannot reverse this list."}
{"text": " Else in else part what you will write I am writing that thing only I am not going to write that if condition I guess you can write that condition that is very easy fine. And we have discussed we have already written that condition many times in the program fine. The first step is we are going to point this current here. So, here what I want to store that is 200. So, now, from where I can get this 200 head is containing 200. So, here after this what I can write."}
{"text": " this current is equal to head right now this is pointing to this node only and before updating before reversing before swapping these values I will maintain I will set a pointer to this node also."}
{"text": " So, that if we lose this if we break this link we can easily get this address fine for updating these values for reverse for swapping these values. So, here I will write what this next node is equal to here I want to store 150 from where I can get 150 here the pointer to this long this node is current although we have head, but we are not moving this head we are we will move this current. So, that is why I am using this."}
{"text": " current and next right so 150 would be stored here now what i can do now we can swap these values so now what you will write see how you can access this part current of next so here i will write current of next is equal to here i want to store whatever the value here in this pointer how we can access this pointer current previous so here i will write current"}
{"text": " So, now we have updated this link and we have here 0 because the in current previous we have value 0 and that would be stored here in the current next."}
{"text": " this link is no more now right. And now here I want to store what 150 here we have one we had 150 now. So, this after reversing this previous link should contain address of the next not the previous that is what reversing. So, from where I can get 150 in the next node we have 150 that is why we need this next node. So, here I can write what current of previous is equal"}
{"text": " next node. Right? So now here I have 150. Right? It means now this is pointing to here. Right? And this is pointing to here. Null. So we have reversed these links. Right? Now come to this node. Fine? Now we will move this current."}
{"text": " So, now current in current pointer I want to store 150 from where I can get 150 in next node I have 150. So, here I can write current is equal to next node right. Now, current is also having 150 this pointer now this pointer is also pointing to this node."}
{"text": " now the current node is this one now i want to swap these values see this previous pointer this previous pointer is pointing to this node but i want this pointer should after reversing this pointer should point to the next node that is why i want to reverse this link this link i want to break this link and i want that here i i'll store 500 right this value and here this this pointer is containing address of the next node but i want this"}
{"text": " should contain address of the previous node that is 200. So, here I want to swap these links now. So, we will repeat the same step right. So, these steps I will write in a while loop till we reach here right. So, now, here I will write before these line after this line while and you will write what this current pointer"}
{"text": " not equal to null. Till then we are going to repeat these 4 steps. Please do not write this step in while loop because again we will enter into while loop then again current would be head. So, again current would point to this node, but I want I do not want this thing because we have done with this node. Now, we are at this node we will deal with this node then with this node then with this node till we reach to the this null. So, here I will write current not equal to null fine."}
{"text": " We have done one iteration now in current we have next node that is 150 now 150 is not equal to null fine again we will enter into this loop now next node is equal to current of next now in current of next we have current is pointing to this node current next we have 500 so that would be stored in next node."}
{"text": " So, now this next node is pointing to this node. Now, we can update these this link and this link. Current next, current of next is equal to current of previous that is here I will store 200. So, now, there is this link is no more and now 200 means here. So, now, this is pointing to this node right. So, now, this this will point to this node the previous one we have reversed this link"}
{"text": " right now this one here current of previous means current previous that is here is equal to next node next node we have 500 so here I will store 500 so this link is no more now now this is pointing to this node right now we are done with this node also we have swapped these values now we will do it current is equal to next node now we will move this current in next node we have 500 so now here we will have 500 so now this is pointing to"}
{"text": " this node so I will write here again while loop current not equal to null yes current not equal to null again we will enter into this loop now next node is equal to current next so in next node we will store what current of next that is 400 so here I am writing this one now next node is containing now 400 right so now next node is pointing to this node now we are going to swap these values same current next is equal to current previous so here 150"}
{"text": " this link is no more now and this this is now pointing to this node right and this one current of previous current of previous current is pointing to this node current previous here we will store next node next node we have in next node pointer we have 400. So, now, this is this this"}
{"text": " this is now pointing to this node right. Now, we are done with this we will move now current is equal to next node now in current we have 400."}
{"text": " So, now current is pointing to this node only right and next node is equal to current next in current next we have 0. So, in next node we have 0 it means now next node is not pointing to any node. Now, see we will swap these values current next is equal to current previous current next means here we will store this current previous value."}
{"text": " So, now, this is now what pointing to this node 500 this address and current previous is equal to next node current previous this value is equal to next node in next node we have 0. So, here we will store 0. So, now, this is pointing to 0 right now current is equal to next node now current in current we have 0 because current is equal to next node next node we have 0. So, now, current is also not pointing to this node."}
{"text": " Now again 0 not equal to 0 but this condition is not true. So we will not enter into this loop and we are done. We have reversed these links. But now still we have something left. We have to swap these pointers also. Head would be here and tail would be here. After that reverse operation would be completed. Now how we are going to swap these things?"}
{"text": " how you can swap two variables I guess you know easily after taking third variable you can swap these values right. So, now, obviously, we have two extra pointers current and next node. So, we can use these pointers. So, first of all what you will do you can do what in current we will store head value. So, after this while loop after this closing you will write what current is equal to head. It means in current we have now"}
{"text": " this 200 so it means current is pointing to this node right now I can update this value now I can write head is equal to tail it means head is containing now 400 so now head is pointing to this node address is this one so now here this is now head"}
{"text": " And in tail we should store this 200 right and from where I can get 200 in current we have 200. So here I can write current. So now this becomes tail pointer. So now this is pointing to this node."}
{"text": " right now this is done and if you want to check that this is done or not so before these lines before reversing this head and tail before these lines you can print what the data head of data so it should print 6 and the tail arrow data it should print 7."}
{"text": " right and after these line after reversing head and tail it means head is equal to here now and tail is here now so after these line if you print print %d and if you write head arrow data then it should print 7 after reversing and printf %d tail arrow data then it should print 6 before reversing"}
{"text": " head data is 6, tail data is 7. After reversing these lines head data is 7 and tail data is 6. So, this was the iterative approach to reverse the doubly linked list."}
{"text": " using recursion also we can reverse the list fine and after reversing you can draw it something like this see it if you will print this before reversing then it will print 6 5 1 and 7 after reversing if you will call the display function that we have already discussed many times how to traverse the doubly linked list it is same as singly linked list right then what it should print 7 1 5 and 6 in reverse order 7 1 5 and 6"}
{"text": " So, this is how we can draw this doubly linked list after reversing right. So, in next video we will implement a circular linked list, we will write a C program fine, how to create a circular linked list and how to display the content of a circular linked list right. So, I will see you in the next video till then bye bye take care."}
{"text": " Hi guys, welcome back. In this video, I'm going to discuss with you how to delete data from AVL tree. Fine. In the previous video, we have already discussed how to create AVL tree. You can see how to insert data in AVL tree and all about the AVL rotations. If you want to check out that video, I'll give you the link in the description box. You can check it out. Fine. So today we will discuss how to delete data from AVL tree. See, this is the AVL tree we have created in the last video."}
{"text": " Now, suppose you want to delete data first in this series 8, 7, then 11, then 14, then 17, fine. See, AVL tree is what? First of all it is a BST, second is the balance factor of each and every node should be either minus 1, 0 or 1 and balance factor is to be created how? Height of left subtree minus height of right subtree or maybe somewhere it is also written height of right subtree minus height of left subtree, fine."}
{"text": " So, when you delete the data from AVL tree you need to keep in mind two things. First of all deletion would be same as in BST."}
{"text": " And we have already discussed how to delete data from BST. The link of that video also I will give you in the description box. Fine. The first point is delete data same as you delete data in BST. Fine. Second point is after deletion of data from this tree, you need to check out the balance factor of each node again."}
{"text": " fine and the balance factor is minus 1 0 or 1 in that case tree is balanced no need to balance it out. If the balance factor is out of this range minus 1 0 and 1 then you need to balance it out using that AVL rotations 4 types of rotation we have discussed left left right right left right and right left."}
{"text": " Fine. So, let us discuss. Now, suppose first of all you want to delete this 8. Okay. Find out where is 8. See, this AVL tree is first of all BST. So, how to find out 8? Compare with this root. 8 is less than 14. Go to the left part. 8 is less than 11. Go to the left part. Here is 7. 8 is greater than 7. So, here is 8. Yeah, we have found this 8. Now, how to delete? See, deletion would be same as in BST."}
{"text": " So, this node is having no child it is leaf node. So, directly you can delete this node fine like this and after deletion of this 8 the tree would be something like this we have already we have deleted this 8."}
{"text": " Now it's not like that check out the next number and delete 7. Second thing is you need to check out the balance factor of each node again. Fine. Now check out the balance factor after deletion. Balance factor of this one is 0. This one is left minus right is 1. This one is 0. This one is 0 minus 1 minus 1. This one is height of left subtree 1 2 height of right is also 2 that is 0."}
{"text": " this one balance factor 0 this one is also 0 balance factor of this is also 0 0 1 minus 0 that is 1 balance factor of 19 is 1 2 height of left sub tree is 2 height of right is also 2 that is 2 minus 2 is 0 fine and height of left sub tree of this 14 is 1 2 and 3 3 minus 1 2 3 0."}
{"text": " So, this tray is balanced. No need to balance it out. Now, check out the next number to be deleted. Next number is 7. Find out where is 7. Compare with 14. Less than 14, go to left. Less than 11, go to left. We found 7. Fine. Now, you have to delete this number. Now, check out. Is this number is having any children? Yes, this is having one child. That is left child, 4. Now, how to delete this 7? You will"}
{"text": " Replace the 7 with this with its child either its left or right child. One child has and there would be no problem. Fine. Jo bhi child hoga left or right you would replace the deleted node from his child. Fine. So when we will delete this 7 then the tree would be 14. See this right part would be as it is. This would be unaffected part of this tree. Only the affected part is this the left subtree."}
{"text": " So 11 is as it is, when you delete this 7, fine, then directly 4 will be linked with this 11. Or you can say this 7 would be replaced with this 4. Now 11, here we have 4, right side of 11 is 12, and here we have 13."}
{"text": " Now, next is see next is 11, but do not you cannot directly delete this 11 after deletion next task is what you have to check out the balance factor of each node."}
{"text": " Now, see balance factor of this 4 is 0, 13 is 0, 12 is 0 minus 1 minus 1, for 11 it is 1 minus 2 that is minus 1 and this part was unaffected. So, balance factor would be same like 0, 0, 0, 0, here is 1, here we have 0 and here we have see this would be affected."}
{"text": " sorry the height of left sub tree is now 1 and 2 it's not like 1 and 2 you are supposed to check the height you are supposed to go to the leaf node and height up to leaf node is 1 2 and 3 fine 3 minus 1 2 3 that is 3 minus 3 0 still this tree is balanced okay no need to balance it out next you have to delete is 11 now find out where is 11"}
{"text": " 11 is this node. This one you have to delete now. Now check it out. This node deletion would be same as in BST. This node is having two children. One is left and one is right. Now the node being deleted will be replaced with"}
{"text": " which of its children left or right you have to check it out and here we have two cases you can replace this node with its in-order predecessor or with its in-order successor. In-order predecessor would be the largest element"}
{"text": " from the left subtree of the node being deleted fine and in order successor would be the smallest element from the right subtree of this node fine. So, we will suppose replace the this node with its in order predecessor we will just take one case. Then after deletion of 11 the tree would be"}
{"text": " here we have 14 the right part would be unaffected that is 53 here we have 60 here we have 20 here we have 17 and here we have 16 now you have to delete this 11 find out its in order predecessor in order predecessor is go to its left subtree in left subtree we have only one element that is 4 so obviously there is a largest element from this left subtree would be 4 so we can replace this"}
{"text": " 11 with 4, fine. In the left of 4 there is nothing. In the right of 4 we will have this"}
{"text": " and this 13 because this 11 is replaced by this 4. So, right subtree would be same. Second case would be you can replace this 11 with its successor. Successor is the smallest element from this right subtree and out of this 12 and 13 what is the smallest element that is 12. So, you can replace this 11 with 12. Then here you can write 12 here we would have 4 and here we would have 13 that would be the second case."}
{"text": " Now, check out the balance factor of every node before deleting 14. Here the same balance factor would be there because this node was this right subtree was unaffected. Now, check out 0 balance factor of 12 is 0 minus 1 that is minus 1 balance factor of this 4 is now height of left subtree is 0 height of right subtree is 1 and 2 0 minus 2 that is minus 2."}
{"text": " Now, see this minus 2 is not within this range minus 1 0 and 1. So, this node is critical node. Now, you have to balance it out fine. This one now we are working with this part only. Now, we have already discussed the AVL rotations, which case is this? See this right and right are our rotations."}
{"text": " fine and how this can be balanced? RR rotation we just do one left rotation by doing one left rotation you can balance out this one and how this left rotation would be done? This is left rotation. See this tree is this node is unbalanced or you can say this node is critical. So, you just pull down this 4"}
{"text": " like this. Then 12 would go up and 13 would be the right of 12 and 4 would be to the left of this 12. So, you are supposed to do the left rotation, fine. Isko apko left move karna hai. Then the 4 would be pulled down, ok. Now, the tree would be, here I am ending this tree, 14. The right subtree would be same, fine."}
{"text": " The left subtree would be 4 would go this place here we would have 12, here we would have 13 and here we would have 4. By this left rotation we will pull down this 4, 12 would go up. This is now the left subtree and the right is same 19 we would have here we have 53,"}
{"text": " 17 and 16."}
{"text": " fine. Now, see before deleting this 14 check out the balance factor of each and every node is this now balanced tree because we have this r r rotation we have done this r r rotation. So, 0 0 here we have 0 and this tree was unaffected. So, this one is also 0 0 same as this one fine 14 cubby 1 2 2 minus 1 2 3 that is minus 1. So, this tree is now"}
{"text": " balanced now what you have to delete is you have to delete this 14 now how 14 would be deleted see"}
{"text": " Again 14 is having two children. One is left and one is right. Then how this 14 would be replaced with which one? Either you can replace this 14 with in-order predecessor or in-order successor. Deletion would be same as in BST. Okay. Now you have to delete this 14. Now find out this in-order predecessor."}
{"text": " In order, we will replace this 14 with its in order predecessor. In order predecessor is, see this is the left subtree of 14, the node being deleted. The left subtree of the node being deleted is this one. So, in order predecessor is what? The largest element from this."}
{"text": " left subtree of that node. Largest element out of 4, 12 and 13 is what? 13. So you can replace this 14 with 13. Or second case is"}
{"text": " in order successor in order successor is the smallest element from this right subtree. So, out of these elements smallest element is 16. So, you will delete the 16 from here and you will replace this 14 with this here you can write 16 fine. So, we will discuss one case only we will replace this 14 with its in order predecessor. So, 13 would go up"}
{"text": " right part would be say 53, here we have 60, here we have 20, here we have 17 and here we have 16. And the left part would be 12, we have replaced 14 with this 13. So, 13 will be delete."}
{"text": " And here we would have 12 and 4. Now before deleting the 17, second step, you need to check out the balance factor of each node. Balance factor of 4 is 12, 14 is 1 minus 0, this one is unaffected, 0 0 0 0 1."}
{"text": " minus 0 that is 1, 2 minus 2 that is 0, 1, 2, 2 minus 1, 2, 3 that is minus 1. So, this tray is balanced. Now, delete this 17. Find out where is 17. 17 is greater than 13, go to the next right part. 17 is less than 19, go to the"}
{"text": " left part here we find 17 now 17 is having only one child so no problem is there just simply delete this 17 and replace 17 with this 16 then the tree would be 13 19 53 60"}
{"text": " 20 and here is 16. Check out the balance factor of each node. Balance factor is 0 1 0 0 0 1 minus 1 0 1 minus 2 that is minus 1 2 minus 3 that is minus 1. So, this tray is balanced."}
{"text": " Like this you can delete data from AVL tree. You just have to remember deletion would be same as in BST. First step delete data as you have deleted in BST. Second step is after deletion check out the balance factor of each node. If tree is balanced"}
{"text": " Then you can proceed, you can delete the next number. If tree is unbalanced, you have to check out which rotation is there, by which rotation you can balance it out. If tree is unbalanced after deletion, then balance out that tree first. Then you can proceed with your deletion. Okay? So, I'll see you in the next video. Till then, bye-bye. Take care."}
{"text": " Hi guys, welcome back to my channel and in this video I am going to discuss with you how to construct a B-tree of order 4. So, the question is construct a B-tree of order 4 with the following set of data. We are given some integers and we are supposed to create a B-tree and that B-tree will be having order of 4. See the order is 4 means m value is"}
{"text": " So, maximum keys any node can have is m minus 1 that is 4 minus 1 and that is 3 ok. Now, see first of all scan this you know this given a set of data from left to right. First number is 5, we will insert this 5 into B-tree, but initially we have you know empty B-tree. So, one node will be created."}
{"text": " one node will be created and that node can have maximum keys 3 ok."}
{"text": " 2 and 3. First is first number is 5. 5 will be inserted at this position and this node. Now next is 3. See now I have already told you that all the numbers in that node will be you know stored in ascending order or the data will would be in sorted fashion."}
{"text": " So next number is 3. We cannot put 3 at this place. Why? Because 3 is less than 5. So first of all we will compare 3 with this one. 3 is less than 5. Okay. So where 3 will be inserted? 3 and here it will be 5."}
{"text": " fine. Next is 21. 21 would be inserted at which place? Greater than 3, greater than 5. 21 is greater than 3 and 5 so 21 will be inserted at this place. Now next is 9. Now first of all see"}
{"text": " It's not like this node is full because maximum we can insert only three keys any in any node. So firstly, we would split this node and then we will insert this nine. No. First of all, we have to find out proper place to insert this nine in this node where you can insert this nine after five means at"}
{"text": " this place before 21 and after 9 3 after 5 3 5 9 and 21 now now see maximum keys can be 3 only and but in this node we have 4 keys so what is the procedure now this tree would be splitted in two parts and how this splitting will be done"}
{"text": " will find out the median or you can say the middle element of this node and that middle element would go one level up or you can say to the parent of this node but obviously you can see in this node we have only one node root node so parent iska koi nahi hai in that case that middle element would go one level up and that middle element will become the root aur do iske kya ho jayenge us root ke children now see"}
{"text": " 3, 5, 9 and 21. Now what is the middle element of this one? We have only 4 numbers na. So middle element can be, see even number hai to middle element iske 2 ho sakte hai. 5, either you can take 5 as a middle element or you can take 9 as a middle element. 3, 5, 9 and 21."}
{"text": " Sorry, either you can take 5 as a middle element or 9 as a middle element. If you take 5 as a middle element, then the tree, you will create, 5 will go up and the left child of 5 is 3, the right child of 5 is 9 and 21."}
{"text": " okay if you take 9 as middle element then what will happen 9 would go one level up 9 and the left child of 9 would be 3 5 and right would be 21 and this one 3 5 and right would be 21 okay both trees are right now this tree is known as left biased"}
{"text": " and this tree if you take 9 as middle element then this is known as right biased. when you know the order is even in that case it will happen. so see let us take"}
{"text": " 5 as middle element. The tree would be left biased. If we consider 5 as middle element, then the tree would be, 5 would go one level up, left child of, you can say left subtree of this 5 would be only 3. And the right would be 9 and 21."}
{"text": " The next number is 1. 9 I have inserted and the next is 1. Now you have to find out the proper position to insert this 1 in this B tree. And one rule is that any new number will always be inserted in leaf node. You cannot insert into root node."}
{"text": " one but firstly we will compare this one from the root node. one would be compared with this five one is less than five so we will go to the left part of five now we have three in this node now"}
{"text": " this is leaf node so 1 would be inserted at this place but you cannot insert 1 at this place why so because 1 is less than 3 so it will be inserted at the left of 3 so 1 will be inserted at this place and here would be 3"}
{"text": " Now next is 13. 13 is greater than 5. 13 is greater than 9 but less than 21. So 13 would be inserted at this place. 13 and 21. Now next is 2. Now find out proper place for 2. 2 is less than 5. 2 is greater than 1 and less than 3. So 2 would be inserted at this place."}
{"text": " free fine next number is 7 now find out 7 is greater than 5 so it will go to the right part greater than less than left now find out the proper place for 7 after that we will split this node okay now 7 can be inserted at this place before 9 because 7 is less than 9 less than 13 and less than 21 obviously"}
{"text": " at this place 7 but we cannot insert 7 at this place why so because maximum key any node can hold is 3 only so splitting would be done now splitting"}
{"text": " left biased okay you have to take 9 as middle element you can't take 13 because tree is left biased we are creating tree by considering left element as middle element okay we are splitting so here 9 would be middle element so 9 will go to its"}
{"text": " in the parent node of this node and you can say one level up. So where should 9 go? Here near 5 and we can insert 9 at this place because we don't have a maximum of 3 and we have only one key. Now the tree would be 5 and 9. Left part of 5 is 1, 2 and 3."}
{"text": " See, if 9 goes one level up, this node would be split in two parts. So 9's left child would be 7. This one. 7 is here. And 9's right child would be 13 and 21. 13 and 21. Fine?"}
{"text": " Next is, we have inserted 7 and next element is 10. Now compare 10 with 5 and 9. 10 is bigger than 5 and 9. So, it will go to the right part of 9. Okay. 10 can be inserted here. Now find out the proper place of 10. 10 is less than 13. So, 10 will be inserted here. After that, here is 13 and here will be 21."}
{"text": " Fine. Next is 12. Now find out proper position for 12. 12 is also greater than this 9. So we will go to the right part. Where can 12 be inserted here? After 10 and before 13. So where should 12 be at this place? 12, 13,"}
{"text": " into 21. But you cannot insert this at this place. Why so? Because maximum keys can be 3. So splitting would be done. What will be the middle element? 12 is left biased. We can take 12 or 13. But we are working on left biased. So we will consider 12 only."}
{"text": " middle element okay that middle part middle element would go one level up or you can say to its parent node."}
{"text": " I am updating in this. 12 will go here and 12 will go up. Then this node would be split in two parts. 10 would be the left child of 12. Okay. What is left in 12? Only 10. And what is left in the right part of 12? 13 and 21. Okay. Right part of 12. Now next is 4."}
{"text": " now compare 4 is less than 5 so we will go to the left part of 5 you have to insert 4 here you can insert 4 after 1,2,3"}
{"text": " 3, 4 should be here where your insert should be. But we can't insert it because obviously maximum can be 3. Splitting would be done. What will happen in splitting? Middle element. Who will we insert middle element? 2. Then 2 would go one level upper you can say to its parent node. See. If you have 2, 2 will go at this place."}
{"text": " If 2 goes up, then 2 is obviously less than 5, so it should be inserted here. 2, 5, 9 and 12. But here also we have, you know that this node is also full. Because 3 is already there, so we cannot put 2 at this place. So what will happen here again? Splitting will happen. Until we find out the position properly, splitting will happen again and again."}
{"text": " here splitting happened, 2 went up, if it goes here, in that case splitting will happen here also and after splitting this part, what will happen to you? the middle element will go one level up to its parent node if there is no parent, the middle element would become the root of this tree now this middle element, we will consider it as 5 because tree is left biased so the tree would be 5"}
{"text": " 5 went up. This node would be split. Now what is the left part of 5? This 2. Fine. And what is the right part of this 5? Right children 9 and this 5. 9 and 12. Now come to this level. Now what will be the left part of 2? 2 went up. So what will be the left part of 2? Only 1."}
{"text": " we have only 1 what is the right children of 2? 3 and 4 what will be the right children of 2? 3 and 4 now see where will 7 go? 7 is greater than 5 so it should go in the right part of 5 but it is in the left part of 9 so 9 is here so what will be the left part of 9?"}
{"text": " 7 now 10 is the right children of this 9 this one 10 and 13 and 12 are this right part of actual children of this 12 right subtree or you can say 13 and 21 fine the last number is 8 now find out the proper position for 8"}
{"text": " where you can insert this 8 compare with this 5. 8 is greater than 5 then we would go to the right part of"}
{"text": " this 5. Now compare 8 with this place. You see you cannot insert 8 at this node. Why so? Because you cannot insert any newly coming number into the internal nodes. You can only insert the data into leaf node. Now 8 would be compared with this one. Now 8 is less than 9. To 9 ke kaha jaayenge? Left part mein jaayenge. See now this node is leaf node."}
{"text": " Fine. This is our 7 leaf node. There is no left or right part below this. Now find out proper position for 8. 8 is greater than 7. So where is 8 inserted? At this place. Fine. Next is our Henny. So this is the final B-tree of order 4. Fine. Another variant is, see this is also right. Another variant is that right biased"}
{"text": " tree. You can take this 9 as a, you know, middle part and you can put 9 at this place, 3, 5 at this place and 21 at this place. Like this you will proceed and that one another tree would be there though. Jab aapka even number hota hai, that order is given with this even number to aapke two trees possible. One is left biased and one is right biased. Fine."}
{"text": " So, I'll see you in the next video guys. Till then bye-bye. Take care."}
{"text": " Here the numbers are not compared like this. See we have done in another sorting algorithm. Suppose I am taking 15 and 10. Then I am going to compare this 15 with this 10. Is 15 greater than 10? Yes, then do swapping something like this. See we are not going to do any comparison here between the numbers given, right."}
{"text": " So now if no comparison is there then how the data is to be sorted. See data is to be sorted here digit by digit. We are going to sort the data according to the place value of the digit or you can say the position of the digit in that number. See suppose we are taking a number 4 to 1 right. So this is what"}
{"text": " See place value is what here we have this place value of this one is ones place value of two is tens place value of this four is hundreds."}
{"text": " And face value of this one is 1, face value of this is 2, face value of this is 4. I hope you know what is face value and place value. So we are going to start from the least significant digit. Least significant digit is this side and this is the most significant digit. So I am going to start this sorting from this least significant digit and we are going to move towards most significant digit."}
{"text": " right. Digit by digit the data is to be sorted. So, see how the data is to be sorted digit by digit. Let us take this example we are going to solve this one we are going to we are going to sort this data using radix sort fine. See the sorting algorithm we have discussed bubble, quick, merge, selection, insertion those are comparison based sorting and the best best time complexity for those comparison based algorithm is order of n log n."}
{"text": " or you can say omega n log n they cannot do better than this. So, after sorting we are also going to see what is the time complexity for this radix sort fine. See here the first step in this sorting algorithm is out of these given numbers find out the maximum number fine. Now, see by looking at these number we can see the maximum number is what 802."}
{"text": " Second step is calculate how many digits are there in this maximum number. How many digits are there? 1, 2 and 3. Now third step is you are going to make all these numbers a three digit number."}
{"text": " right now how we are going to make you are going to put zeros now where you are going to put zeros suppose this is the number this is 2 digit number 1 and 2 now where you are going to put 0 to make it a 3 digit number you cannot put 0 here because if you put 0 here then it will become 150 and the number is 15."}
{"text": " So, you cannot change the number the value of this number that is why we are going to put 0 to the here this side. Now, all the numbers are 3 digit number fine here red x means basically the base. So, here I am dealing with decimal numbers. So, base 4 decimal number is 10."}
{"text": " So that is why I am going to take 10 buckets. This is also known as bucket sorting. So here we are going to take 10 buckets from 0 to 9. See this sorting algorithm is also used to sort strings or you can say alphabets. In that case the base is 26 for alphabets. So we are going to take buckets from 0 to 25. In that case how we are going to sort suppose I am going to take two names."}
{"text": " one is Jenny and one is Jia. So, in that case we are going to start from here or you can say from MSB. You can say from the most significant bit right. So, we are compare with this with this both are J then fine. Again we are going to compare second here we have E here we have I. So, E comes first then I. So, this is this Jenny comes first then"}
{"text": " In case of numbers, we are going to check from this side, from the least significant digit."}
{"text": " Now see so now we are going to take 10 buckets ranging from 0 to 9 right and now we are going to put these numbers into these buckets. Now next step is how we are going to fill these buckets. See this is pass 1. So in pass 1 we are going to sort we are going to sort these numbers according to which digit the least significant digit and the least significant digit is this one. So we are going to check this digit of every number."}
{"text": " right and see so first of all check this number the least significant digit is five so now we are going to put this number in which bucket in fifth bucket the number the bucket having number five so here i am going to put this one zero one five next number is zero zero one now we are sorting the data according to this this digit so i am just going to check this digit here we have one so i am going to put this in"}
{"text": " Bucket 1. Here we have 1. So, I am going to put again this in 1. Here we have 0. So, we are going to put this in 0. Here we have 2 in bucket 2. Here we have 2 in bucket 2. Here we have 3. So, we are going to put this in bucket 3. Here we have 0. Again we are going to put this in bucket 0. Then 9. We are going to put this in 9th bucket. And then 1. We are going to put this in 011, 1th bucket."}
{"text": " right now next step is we are going to remove the data from this these buckets and how starting from zeroth bucket now see this bucket is having two numbers now which number you are going to remove first this number the first number right not this number"}
{"text": " you remember you are going to move this number first so in 1th bucket also from first this then this then this now remove one by one from data from all buckets and after pass one after pass one the data is something like this first of all remove this one so the data is 010 then 90 then 001 then you remove"}
{"text": " 321 then 011 now after first pass the data is this one so here one more thing you have to take care the passes would be same as number of digits in the maximum number so maximum number is 802 number of digits are 3 so here we have 3 passes so after pass 1 the data is something like this now pass 2 in pass 2 we are going to sort the data according to which digit this digit the second one"}
{"text": " The digit which is at 10th place. We have already sorted the data according to this digit. The digit which is at 1th place. Now this digit. Now again we are going to take 10 buckets. Now repeat the same step. Check first number. This one 010. Now we are going to take which digit? This one. The digit which is at 10th place. Now here we have 1. So we are going to put this in this bucket."}
{"text": " bucket number 1. We have 9, so we are going to put this in this bucket. Here we have 001 in 0th bucket. 321, 2, 2nd bucket. 011 in 1th bucket. 802, 0 is there, so 802. Here also we have 0. Here we have 2. 1, 2, 3. Here we have 1. 015 and here we have 0109. These buckets are empty."}
{"text": " So that's fine. Now next step is what you are going to remove the data from these buckets. How? From the starting bucket and from starting bucket also if many numbers are there then we are going to remove the first number first. Right? So after pass 2, this is pass 2. So after pass 2 the data is something like this. Remove this one."}
{"text": " 802 002 109 here we have 010 so after pass 2 the data is this one now the last pass that is the third pass in that pass we are going to sort the data according to which digit the third one this one the digit which is at 100th place right so now repeat the same step we are going to take again"}
{"text": " 10 buckets now this is pass 3 again we are going to take 10 buckets ranging from 0 to 9 again we are going to fill these buckets how so these are the number after pass 2 so now we are going to see which digit in the third one third one so now here we have 0 we are going to put this in 0th bucket here we have 8 8 0 2 0 0 0 2 1 0 9"}
{"text": " 0 1 0 here we have again 0 1 1 0 1 5 3 2 1 3 2 1 1 2 3 so digit is 1 here we have 0 0 9 0."}
{"text": " right so these are the buckets now now next step is what you are going to remove data from these buckets right and remove means we are going to store the data in an output array so here is 0 0 1 so you can write 1 here we have 2 here we have 10 11 15 90 10 9 1 2 3 3 2 1 and finally 8 0"}
{"text": " too."}
{"text": " So this is the data after pass three. So as you can see, this is the sorted data now. So here we have removed the extra zeros we have put to make the numbers three digit number, right? So this is now the sorted data as you can see. How many passes are required? Three. Means the number of digits in the maximum number, those number of passes would be required. Here we have three digits, so three passes would be required. So this is how Redix sort will sort the data."}
{"text": " see this radix sort use what count sort as a subroutine so you know what is a count sort right and if you say the running time complexity for this sort is what you can write order"}
{"text": " d into n plus b now here see d is what number of digits in maximum number number of digits are three so here for each digit we are going to repeat the steps right first of all for this digit then this then this how many times three times we have repeated so here we are taking d into"}
{"text": " n is the number of how many numbers are there plus b is what base what is base here because we are going to take buckets equal to the base here base is 10. So, we are going to take 10 buckets in alphabets base is 26. So, in that case we will take 26 buckets from 0 to 25 that is why I am going to take here b n plus b and d is number of digits. So, we are going to repeat the steps"}
{"text": " here for 3 times the number of digits times. So this is the time complexity. So this is all about bucket sort or you can say this radix sort. In next video we are going to discuss shell sorting. So till then bye bye take care."}
{"text": " In the previous lectures, we have been studying about the basics of operating systems and we have seen about computer system organization and computer system architecture. Now, as we have the idea about computer system organization and architecture, we are now ready to talk about operating system structure. So, in this lecture we will be studying about operating system structure and we will be mainly talking about multiprogramming and multitasking."}
{"text": " So, operating systems vary greatly in their makeup internally. So, we have different kind of operating systems that we know like Windows, Ubuntu and so on. And these operating systems vary in their makeup internally. Internally the way they are made may be so much different."}
{"text": " But they also have so many common things in them. So, we will be seeing about the common things that every operating system must be capable of doing in this lecture. So, we will be talking about the commonalities. So, the first two things that every operating system must be capable of doing are"}
{"text": " multiprogramming and timesharing or multitasking. So, these are two very important topics which we will be seeing in this lecture. So, first let's talk about multiprogramming and then we will see about multitasking which is also known as timesharing."}
{"text": " So, coming to multiprogramming, from the name itself we must have understood that multiprogramming means the capability of running multiple programs by the CPU. Now, a single user cannot in general keep either the CPU or the I.O. devices busy at all times."}
{"text": " Now, if you are not having multiprogramming, what will happen is that a single user will always keep the CPU or the I O devices busy at all the times. That is because when a single user wants to execute a particular task, he will use the CPU. So, until and unless the task is completed, no other users can use the CPU or the I O devices. Because it is not capable of multiprogramming."}
{"text": " But in multiprogramming what will happen is that it increases the CPU utilization by organizing the jobs which are codes and data so that the CPU always has one to execute. So, that means that in multiprogramming what we are trying to do is we are trying to increase our CPU utilization because the CPU is capable of executing multiple programs. So, let's see how this works. So, in this diagram we have the job pool and the memory layout of the multiprogramming system."}
{"text": " So, first of all let us understand what is a job? So, a job is something that has to be executed which may contain codes and data. So, here we have a job pool which consists of all the jobs that enter the system. So, all the jobs that have to be executed are kept in a job pool like this. And then here we have the memory layout of a multiprogramming system. So, on top we have the operating systems and these are the jobs that are loaded into the memory."}
{"text": " So, we cannot load all the jobs in the job pool into the memory because we don't have unlimited memory or memory is limited. So, by memory I mean the main memory or your RAM. So, here in this example we are having 512 MB of RAM over here. So, you are not able to load all of this into the main memory. So, a subset of these jobs or some of these jobs are loaded into the memory."}
{"text": " So, for this example, we have loaded job 1, 2, 3 and 4 into the memory. Now, this operating system has to help in executing these jobs by assigning the CPU to these particular jobs. So, if we don't have this multiprogramming, what will happen is that job 1, let's say, starts executing and is using the CPU."}
{"text": " Now, until and unless job 1 finishes its execution completely, the other jobs cannot use the CPU. So, let's say that job 1 was using the CPU and then it has to use some other resources in the course of its execution. Let's say the I O devices. Now, when job 1 goes to use the I O devices,"}
{"text": " the CPU is not used and the CPU just stays idle without being used by any other jobs. So, that is a very inefficient way. So, in multiprogramming what happens is that, let's take the same example again. Job 1 starts executing and is using the CPU. And on the course of its execution, Job 1 tries to use the I O devices."}
{"text": " So, when it goes for using the I O devices or any other resources, the CPU is released by job 1. And then that CPU instead of remaining idle, it can be used by another job, let's say job 2. So, job 2 can use the CPU until job 1 finishes its other I O device operation and wants the CPU back. So, job 2 will be using the CPU. And again, let's say job 2 wants to go for using some other resources and does not need the CPU at a particular time,"}
{"text": " then the CPU again instead of remaining idle can be used by job 3 and so on. So, in this thing we see that the CPU does not remain idle. Whenever a particular job does not want to use the CPU, the CPU can be utilized by another job. So, this is a very efficient system or an efficient way of executing. So, that is what multiprogramming is mainly about."}
{"text": " So, we see that for the operating system to be efficient, it should be capable of this multiprogramming. So, we can also relate this multiprogramming with our day to day life. So, let's say that for example, there is a lawyer who has different clients under him. Now, the lawyer is not taking care of only a single client at a particular time."}
{"text": " Let's say that he is taking care of one client, and when that client's case is waiting to go on a trial, or when the lawyer is waiting for his paperwork to be done, he does not simply keep waiting for that single client, but at the same time, he can take care of another client that is under him. So, in that way, he is utilizing his time and resources efficiently. So, that is what we do in multiprogramming. We are trying to utilize our CPU efficiently."}
{"text": " Now, a multiprogram system provides an environment in which the various system resources like CPU, memory, and peripheral devices are used effectively but they do not provide for user interaction with the computer system."}
{"text": " So, in multiprogramming system, it makes sure that all our resources are used effectively, but they do not provide for user interaction with the computer system. So, that brings us to the next topic, which is multitasking or time sharing systems. So, now let's see what is this time sharing or multitasking system, and let's see how it is different from the multiprogramming system."}
{"text": " So, first of all, the CPU executes multiple jobs by switching among them. Now, this is almost same like the multiprogramming system, this first point. It says that the CPU executes multiple jobs. We have multiple jobs as we saw above. And then, instead of executing only a single job at a time, what the CPU does is, it switches between the jobs. And then,"}
{"text": " The switching occurs so frequently that the user can interact with each program while it is running. Now, when the switching happens, it happens so quickly that the user can interact with the program while it is running."}
{"text": " So, this was something that was not there in the multiprogramming. So, here the user can actually interact with the program even while it is running. Because the switching between the jobs takes place very fast in this time sharing system. And then this time sharing requires an interactive"}
{"text": " or hands-on computer system which provides direct communication between the user and the system. So, this was something that was not there in the multiprogramming system. That was the last point that we discussed. But in this time-sharing system, there is a direct communication between the user and the system. And in this time-sharing system, as the name suggests, a time-shared operating system allows many users to share the computer simultaneously."}
{"text": " So, the computer system is shared among many users simultaneously in this timesharing system. So, let's see how this works. So, in order to elaborate this point, let's take an example. Let's say that we have a timeshared system over here. And there are four users sharing this system. Users 1, 2, 3 and 4. They are sharing this timeshared system. Now, in this timesharing system, the switching between the jobs of the users"}
{"text": " takes place so quickly that the users themselves do not even realize that they are sharing the system. They feel that the entire system belongs to just that one person. So, user 1 thinks that the entire system belongs to me. And user 2, 3, 4, they all think the same. Because the switching between the jobs takes place so quickly that they don't even realize that"}
{"text": " there is a time sharing or multitasking happening in this system. Now, let's say that user 1 is using this time shared system and there is a certain job that he wants to execute. So, the job is being executed by the time shared system. And then the execution of the job takes place in CPU speed. And we know that CPU speed is very high. So, the execution of the job takes place in CPU speed. And let's say that after execution,"}
{"text": " the user has to be shown some output and then the user has to give some input again to the system. So, after the execution of the job, the output is shown to this user1 and user1 wants to give some other input to the system. That means he is interacting with the system."}
{"text": " Now, the interaction between the user and the system takes place in user speed or people speed. That means it is taking place in human speed. So, we know that CPU speed is so much higher as compared to human speed. So, when he gives an input to the system, he is giving in the normal human speed. So, that time gap itself is so big for the system that we have because systems are very fast."}
{"text": " So, while he is giving that input to the system, in that time gap the CPU can be used by user 2 for executing the job from user 2. So, in that way we see that there is a time gap between the user and the system. Because users are usually slower than the system. So, in that time gap the switching of the jobs takes place so quickly"}
{"text": " and it is so quick and so frequent that the user does not even realize that they are using a timeshared system. They just feel like the entire system belongs to themselves. So, in this timeshared system, it uses CPU scheduling and multiprogramming to provide each user with a small portion of the timeshared computer."}
{"text": " So, as I told you, a small portion of the time shared system is provided to each of the users. But the user thinks that the entire system belongs to him. And how this time will be shared among the users, that will be decided using CPU scheduling algorithms, which we will discuss in detail in the coming lectures. So, this is a very important topic, CPU scheduling, which we will be discussing later on. And then each user has at least one separate program in memory."}
{"text": " So, all of these users, they at least have one of the programs waiting in memory to be executed. And then a program loaded into memory and executing is called a process. Now, as I told you, each of these users, they are having programs stored in memory, which are waiting to be executed. And when a particular program is loaded into the memory, and when it is executing, that program is known as a process."}
{"text": " Now, this is a very important term as far as the subject operating system is concerned. Process. So, keep this word in mind and we will be discussing this in later and in more detail in the coming lectures. So, for now, this is all we will be discussing about multiprogramming and multitasking or time-shared systems. So, I hope this was clear to you. Thank you for watching and see you in the next one."}
{"text": " In this lecture, we will be studying about operations on processes. And this lecture particularly will be about process creation. So, let us see what is this process creation. So, it says here, A process may create several new processes via a create process system call during the course of execution."}
{"text": " So, when we have been studying about processes from the last few lectures, we have seen that there is not only one process, but several processes that are running in the system. And all these processes are not created individually by the user or something like that. But a single process, it can create several new processes under it via a create process system call. Using this create process system call,"}
{"text": " one process can create so many sub processes under it. And this can happen during the course of execution. So, the creating process is called a parent process and the new processes are called the children of that process."}
{"text": " So, as I told you, one process can create many other processes under it during the course of its execution. So, the creating process is called the parent process. So, the process that is creating the other processes, they are known as the parent process. And the new processes are called the children of that process. So, the processes that are created under the parent process or the processes created by the parent process are known as the"}
{"text": " children of that process. So, from the name itself, it is easy to understand. The creating process is the parent process and the new processes are called the children of that process. Each of these new processes may in turn create other processes forming a tree of processes. So, we saw here that the parent process, they create children process and those children process can also create children of their process and so on. It can continue."}
{"text": " So, each of these new processes may in turn create other processes following a tree of processes. So, we have the parent, the parent creates the children, and then the children create their children,"}
{"text": " and those children create their children and it goes on. The formation of processes goes on forming kind of a tree structure. So, we will be seeing that example by taking a diagram and trying to understand that. So, here we have a figure which is a tree of processes on a typical solaris system. So, as I told you, if you look at this,"}
{"text": " it looks like a tree structure. So, let us try to visualize and try to understand what this tree means. Alright. So, all these circles or all these oval shapes over here, they represent particular processes. And they have a name and they have a unique id which we call the"}
{"text": " process ID or PID. So, each process is identified by their unique number which is known as the PID which is required. So, we have already discussed that when we discussed about processes in the previous lectures. So, let us see over here. So, here in the beginning we have a process called SCHD or SHED."}
{"text": " and the process id of this is zero, pid zero. So, this is the parent process or the first process that we have. And this shed process, it is creating three children, one, two, and three. So, these three are the children of this parent sched. So, what are the children of sched? They are init with pid one,"}
{"text": " They are pageout with PID 2 and fsflush with PID 3. So, these are three children created by the parent SCHED with PID 0. So, this init process, it will serve as the parent for all the processes that will be created by the user. So, if you look at this, the tree continues here in this way, and these are all processes that are created by the user."}
{"text": " So, this init process will serve as the parent for all these child processes created by the user. And these two, page out and this one, they serve as processes that take care of memory and file management. So, for memory and file management, these two processes are created. So, keep in mind this is on a typical Solaris system."}
{"text": " Alright, so let us just continue from here and see what are these and what are the meaning of these processes over here. So, we first saw that we have a parent here with three children. And now, as I told you this init process will serve as a parent for all the processes created by the user. So, these are the processes that will be created by the users. So, init over here, it created two child processes inetd and dtlogin. So, these are the children of"}
{"text": " INIT. And here we have INETD with process ID 140 and DT login with process ID 251. So, this INETD process, it is responsible for the networking functions. So, this process is for networking functions. And this DT login, it serves as the"}
{"text": " X window session for the user. So, this DT login will serve as the login screen. It is a process that brings the login screen for the user. Alright, so let us continue in this path and then we will come back here and see what this means. So, first of all as I told you, INETD is the process responsible for networking functionalities like telnet and FTP."}
{"text": " And we see here, it created the telnet process over here. So, telnet is started over here with process id 7776. And from here, it in turn created the csh which stands for the c shell. So, it is a shell process over here. So, using this shell process, a user can interact with the system. So, it created this shell process with"}
{"text": " PID 7778 and from here the user started two processes. One is the Netscape browser and then the Emacs editor. So, Netscape is a browser and the PID of this Netscape process is 7785. And also the user started an Emacs editor. Emacs is a editor like a text editor that we have."}
{"text": " And the process id of this process is 8108. So, these two are created or started from the C shell over here. So, this is how the process tree continues making children of their children. So, we came from here, this was the child, and this has its child, and this is the child of this one, and these two are the children of this one."}
{"text": " Alright, now we come this side. And here, as I told you DT login is responsible for the user login screen. And when this process runs, it provides an X window session for the user. And as I told you, here the X session process is created as the child of this DT login with process ID 294. And which in turn creates the STD shell process with PID 340."}
{"text": " And here again, the C shell is opened, right? Which is the shell with PID 1400. And from this shell, the user can issue commands like ls and cat. So, if you are using Linux based system, you may know the meaning of ls and cat commands. Like for example, ls is used for listing all the files that are there in a particular directory or a folder."}
{"text": " So, ls and cat. So, these kind of commands are there in Linux based systems, and it is issued using the terminal you may remember. So, shell is also like that. From the shell you can issue those commands like ls and cat. Alright. So, this ls and cat are sub processes or children of this csh process which is over here. And same way, this x session is the child of this dt login. std shell is the child of x session."}
{"text": " And C shell is the child of STD shell. And these two are the children of this CSH. So, this is how a typical tree of processes looks like on a solar array system. Now, since we saw how processes are created, there are few things that we need to remember."}
{"text": " When a process creates a new process, two possibilities exist in terms of execution. So, let us see what are the two possibilities. So, the first possibility is, the parent continues to execute concurrently with its children. And the second possibility is, the parent waits until some or all of its children have terminated."}
{"text": " So, when a process is created by another process, so, we have the parent process and the child process or the children process, all right? So, when the execution takes place, it is possible that the parent continues to execute concurrently with its children. That means, along with the execution of the children, the parent process also will be executing concurrently or at the same time they are executing, that is what it means."}
{"text": " Otherwise, the next possibility is the parent waits until some of its children have terminated. Or the next possibility is that the parent waits for its children process to complete some of its execution. And once the children have terminated, the parent will resume its execution. So, even when resources are allocated, we know that processes are allocated certain resources. So, let's say that there is a process with certain resources,"}
{"text": " And, when that process creates its sub process or its children, then the children may have all the resources that the parent was having or it may have a subset or a part of the resources that the parent is having. So, these are also two possibilities in terms of resource allocation. The children can have all of the resources from the parent or some of the resources from the parent."}
{"text": " So, depending on all those things, the parent can continue executing concurrently with his children or the parent can wait until some of his children have terminated. Alright. So, in terms of address space also, there are two possibilities as above."}
{"text": " there are also two possibilities in terms of address space of the new process. So, let's see what they are. So, first of all, the child process is a duplicate of the parent process. That means, it has the same program and data as the parent. Or the second possibility is, the child process has a new program loaded into it."}
{"text": " So, these are two possibilities in terms of address space of the new process that is created by the parent. So, what are they? First possibility is the child is exactly the duplicate of the parent process. And what do we mean by duplicate? It means that it has the same program and data as the parent. So, what is a process first of all? A process is a program in execution."}
{"text": " So, the program will have the program to be executed and some of the data that is required. So, in here it says that when the child is a duplicate of the parent, the child also has the same program and data as the parent. That is one possibility. And another possibility is,"}
{"text": " The child process has a new program loaded into it. So, in the second possibility, the child process can have a new program loaded into it, which is different from what the parent had. The parent may be running one program, and the child may be created in order to run another program which is required by the parent. So, that is another possibility. So, these are the two possibilities each in terms of execution and in terms of address space of the new process."}
{"text": " So, these are some of the things that you need to remember about process creation. I hope with this you have a basic idea of how processes are created. And this is an important topic under operations of processes. So, I hope this was clear to you. Thank you for watching and see you in the next one."}
{"text": " Okay. So this is the first lecture on eigenvalues and eigenvectors. And that's a big subject that will take up most of the rest of the course. It's a, again, matrices are square."}
{"text": " And we're looking now for some special numbers, the eigenvalues, and some special vectors, the eigenvectors. And so this lecture is mostly about what are these numbers? And then the other lectures are how do we use them? Why do we want them? Okay. So what's an eigenvector? Maybe I'll start with eigenvector."}
{"text": " What's an eigenvector? So I have a matrix A. OK. What does a matrix do? It acts on vectors. It multiplies vectors x. So the way that matrix A acts is in goes a vector x and out comes a vector Ax. It's like a function."}
{"text": " With a, with a function in calculus, in goes a number x, out comes f of x. Here in linear algebra we're up in more dimensions, in goes a vector x, out comes a vector Ax. And the vectors I'm specially interested in are the ones that come out in the same direction that they went in. That won't be typical. Most vectors,"}
{"text": " Ax is in points in some different direction. But there are certain vectors where Ax comes out parallel to x. And those are the eigenvectors. So Ax parallel to x. Those are the eigenvectors."}
{"text": " And what do I mean by parallel? Oh, much easier to just state it in an equation. Ax is some multiple, and everybody calls that multiple lambda, of x. That's our big equation. We look for special vectors, and remember, most vectors won't be eigenvectors."}
{"text": " that for which Ax is in the same direction as x and by same direction I allow it to be the very opposite direction, I allow lambda to be negative or zero. Well, I guess we've met the eigenvectors that have eigenvalue zero. Those are in the same direction, but they're in a kind of very special way."}
{"text": " So this is the eigenvector x, lambda, whatever this multiplying factor is, whether it's six or minus six or zero or even some imaginary number, that's the eigenvalue. So there's the eigenvalue, there's the eigenvector. Let's just take a second on eigenvalue zero."}
{"text": " From the point of view of eigenvalues, that's no special deal. That's, we have an eigenvector. If the eigenvalue happened to be zero, that would mean that Ax was zero x, in other words, zero. So what would x, where would we look for, what are the x's, what are the eigenvectors with eigenvalue zero? They're the guys in the null space. Ax equals zero. So if our matrix is singular, let me write this down."}
{"text": " If A is singular, then that, what does singular mean? It means that it takes some vector x into zero, some non-zero vector, that's what, or will be the eigenvector, into zero, then lambda equals zero is an eigenvalue."}
{"text": " We're interested in all eigenvalues now. Lambda equals zero is not, like, so special anymore. OK. So the question is, how do we find these x's and lambdas? And notice, we don't have an equation Ax equal b anymore. I can't use elimination. I've got the, I've got two unknowns and in fact they're multiplied together. Lambda and x are both unknowns here."}
{"text": " So we need a good idea of how to find them. But before I do that, and that's where determinants will come in, can I just give you some matrices? Like, here you go. Take the matrix, a projection matrix. OK, so suppose we have a plane."}
{"text": " And our matrix P is what I've called A, now I'm going to call it P for the moment, because it's, I'm thinking, OK, let's look at a projection matrix. What are the eigenvalues of a projection matrix? So that's my question. What are the x's, the eigenvectors, and the lambdas, the eigenvalues, for, and now let me say, a projection matrix."}
{"text": " My, my point is that we, it, before we get into determinants and, and formulas and all that stuff, let's take some matrices where we know what they do. We know that if we take a vector b, what this matrix does is it projects it down to Pb. So is b an eigenvector in, in that picture? Is that vector b an eigenvector?"}
{"text": " No. So B is not an eigenvector because P B, its projection is in a different direction. So now tell me what vectors are eigenvectors of P? What vectors do get projected in the same direction that they start? So answer."}
{"text": " Tell me some x's. In this picture, where could I start with a vector b or x, do its projection, and end up in the same direction? Well, that would happen if the vector was right in that plane already. If the vector x was, so let the vector x, so x, any vector, any x,"}
{"text": " in the plane will be an eigenvector. And what will happen when I multiply by p, when I project a vector x, I called it b here because this is our familiar picture, but now I'm going to say that b was no good for our purposes. I'm interested in a vector x that's actually in the plane, and I project it and what do I get back?"}
{"text": " x, of course. Doesn't move. So any x in the plane is unchanged by p, and what's that telling me? That's telling me that x is an eigenvector, and it's also telling me what's the eigenvalue. Which is, just compare it with that, the eigenvalue of the multiplier is just one. Good."}
{"text": " So we have actually a whole plane of eigenvectors. Now I ask, are there any other eigenvectors? And I expect the answer to be yes, because I would like to get three, if I'm in three dimensions, I would like to hope for three independent eigenvectors, two of them in the plane and one not in the plane. OK. So this guy B that I drew there was not any good. What's the right eigenvector?"}
{"text": " that's not in the plane. The good one is the one that's perpendicular to the plane. There's another good x, because what's the projection, so these are eigenvectors, another guy here would be another eigenvector, but now here's another one. Any x that's perpendicular to the plane,"}
{"text": " What's Px for that, for that vector? What's the projection of this guy perpendicular to the plane? It is zero, of course. So it's a, there's the null space, Px and for those guys are zero, or zero x if we like, and the eigenvalue is zero."}
{"text": " So my answer to the question is, what are the eigenvalues for a projection matrix? There they are. One and zero. OK. I, I, I, I, we, we, we know projection matrices. We can write them down as that A, A transpose A inverse A transpose thing, but without doing that from the, from the picture we can see what are the eigenvectors."}
{"text": " OK. Are there other matrices? Let me take a second example. How about a permutation matrix? What about the matrix, I'll call it A now, 0 1 1 0. Can you tell me a vector x? See, we'll have a system soon enough, so I would like to just do these couple of examples just"}
{"text": " see the picture before we let it all go into a system where that matrix isn't anything special, because it is special. And what, so what vector could I multiply by and end up in the same direction? Can you spot an eigenvector for this guy? It, that's a matrix that,"}
{"text": " permutes x1 and x2, right, it switches the first the two components of x, how could the vector with its"}
{"text": " x2 x1, permuted, turn out to be a multiple of x1 x2, the vector we start with. Can you tell me an eigenvector here for this guy? x equal. What is, actually, can you tell me one vector that has eigenvalue one? So what vector would have eigenvalue one? So that if I permute it, it doesn't change."}
{"text": " There, that could be one one, thanks. One one. OK, take that vector one one. That will be an eigenvector, because if I do Ax, I get one one. So that's the eigenvalue is one. Great. That's one eigenvalue. But I have here a two by two matrix, and I figure there's going to be a second eigenvalue."}
{"text": " And eigenvector. Now, what about that? What's a vector, OK, maybe we can just, like, guess it. A vector that the other, actually this one that I'm thinking of is going to be a vector that has eigenvalue minus one. That's my, that's going to be my other eigenvalue for this matrix."}
{"text": " that's the, notice the nice positive or not negative matrix but an eigenvalue is going to come out negative, and can you guess, spot the x that will work for that? So I want a vector when I multiply by A, which reverses the two components, I want the thing to come out minus the original. So what shall I send in in that case?"}
{"text": " If I send in negative one one, then when I apply A, I get, I do that multiplication and I get one negative one, so it's reverse sign. So Ax is minus x. Lambda is minus one, Ax, so Ax was x there, and Ax is minus x."}
{"text": " Can I just mention, like, jump ahead and point out, a special little fact about eigenvalues. N by n matrices will have n eigenvalues. And it's not like let's suppose n is three or four or more. It's not so easy to find them."}
{"text": " we'd have a third degree or a fourth degree or an nth degree equation. But here's one nice fact. There's one pleasant fact. That the sum of the eigenvalues equals the sum down the diagonal. That's called the trace, and I put that in the lecture content specifically. So this is a neat fact, a fact that"}
{"text": " Sum, the sum of the lambdas, add up the lambdas, equals the sum, what would you like me to, how shall I write that down? What I want to say in words is the sum down the diagonal of A."}
{"text": " Shall I write a one one plus a two two plus plus a n n. That's add up the diagonal entries. In this example, it's zero. In other words, once I found this eigenvalue of one, I knew the other one had to be minus one in this two by two case, because in the two by two case, which is a good one to look,"}
{"text": " to, play with, the trace tells you right away what the other eigenvalue is. So if I tell you one eigenvalue, you could tell me the other one. We'll, we'll have that, we'll, we'll see that again. OK. Now can I?"}
{"text": " I could give more examples, but maybe it's time to face the equation Ax equal lambda x and figure how are we going to find x and lambda. Okay. So the question now is how to find eigenvalues and eigenvectors. How to solve how to solve"}
{"text": " Ax equal lambda x when we've got two unknowns both in the equation. OK. Here's the trick. Simple idea. Bring this onto the same side. Rewrite. Bring this over as a minus lambda times the identity x equals"}
{"text": " Zero, right? I have Ax minus lambda x, so I brought that over and I've got zero left on the right-hand side. OK. I don't know lambda and I don't know x, but I do know something here. What I know is if I'm going to be able to solve this thing, for some x that's not the zero vector, that's a useless eigenvector, doesn't count."}
{"text": " What I know now is that this matrix must be what? If I'm going to be able, if there is an x, I don't care if I, I don't, right now I don't know what it is. I'm going to find lambda first, actually."}
{"text": " But if there is an x, it tells me that this matrix, this special combination, which is like the matrix A with lambda shifted by lambda, shifted by lambda i, that it has to be singular. This matrix must be singular, otherwise the only x would be the zero x and zero interest. OK. So this is singular."}
{"text": " What do I now know about singular matrices? Their determinant is zero. So from the fact that that has to be singular, I know that the determinant of A minus lambda I has to be zero."}
{"text": " I've got an equation for lambda, the key equation. It's called the characteristic equation. Or the eigenvalue equation. And that, in other words, I'm now in a position to find lambda first. So I, I, this is, the idea will be to find lambda first."}
{"text": " And actually, I won't find one lambda, I'll find n different lambdas. Well, n lambdas, maybe not n different ones. A lambda could be repeated. A repeated lambda is the source of all trouble in 18.06. So let's hope for the moment that they're not repeated."}
{"text": " They're, they're, they were different, right? One and minus one in that, in that, for that permutation. OK. So, and after I found this lambda, can I just look ahead? How am I going to find x? After I have found this lambda, the lambda being this, one of the numbers that makes this matrix singular, then, of course, finding x is just by elimination."}
{"text": " Right? It's just, now I've got a singular matrix, I'm looking for the null space. We're experts at finding the null space. You know, you do elimination, you identify the, the, the pivot columns and so on, you're, and give values to the free variables."}
{"text": " Probably there'll only be one free variable, we'll give it the value one, like there, and we find the other variable. OK."}
{"text": " Finding x second will be a doable job. Let's go, let's look at the first job of finding lambda. OK. Can I take another example? And let's work that one out. OK. So let me take the example, say, let me make it easy. Three, three, one and one. So I've made it easy, I've made it two by two."}
{"text": " I made it symmetric and I even made it constant down the diagonal. So the more like special properties I stick into the matrix, the more special outcome I get for the eigenvalues. For example, this symmetric matrix, I know that it'll come out with"}
{"text": " Real eigenvalues. The eigenvalues will turn out to be nice real numbers. And up in our previous example, that was a symmetric matrix. Yeah, actually, well read. That was a symmetric matrix. Its eigenvalues were nice real numbers, one and minus one. And do you notice anything about its eigenvectors? Anything particular about those two vectors, one one and minus one one?"}
{"text": " They just happen to be, no, I can't say they just happen to be because the whole point is that they had to be. What, what are they? They're perpendicular. The vector, when I, if I see a vector one one and a one and a minus one one, my mind immediately takes that dot product because it's zero. Those vectors are perpendicular. That'll happen here, too. Well, let's find the eigenvalues. Actually, the, oh, my example's too easy."}
{"text": " My example is too easy. Let me tell you in advance what's going to happen. May I? Or shall I do the determinant of A minus lambda and then point out at the end? Will you remind me after I've found the eigenvalues to say why they were easy from the example we did? OK."}
{"text": " of A minus lambda I. So that's a determinant. And what's, what is this thing? It's the matrix A with lambda removed from the diagonal. So the diagonal matrix is shifted and then I'm taking the determinant. OK. So I multiply this out. So what is that determinant?"}
{"text": " You notice I didn't take lambda away from all the entries. It's lambda I, so it's lambda along the diagonal. So I get three minus lambda squared and then minus one, right? And I want that to be zero. Well, I'm going to simplify."}
{"text": " And what will I get? So if I multiply this out, I get lambda squared minus six lambda plus what? Plus eight."}
{"text": " And that I'm going to set to zero. And I'm going to solve it. So, and it's a quadratic equation, I can use factorization, I can use a quadratic formula, I'll get two lengths. Before I do it, tell me, what's that number six that's showing up in this equation? It's a trace."}
{"text": " And while we're at it, what's the number eight that's showing up in this equation? It's the determinant. That our matrix has determinant eight. So in a two by two case, it's really nice. It's lambda squared minus the trace times lambda, the trace is the linear coefficient, and plus the determinant, the constant term. OK."}
{"text": " Let's, can we find the roots? I guess the easy way is to factor that as something times something. If we couldn't factor it, then we'd have to use the old b squared minus four ac formula, but I think we can factor that into lambda minus what times lambda minus what? Can you do that factorization? Four and two? Lambda minus four times lambda minus two."}
{"text": " So the eigenvalues are four and two. So the eigenvalues are one eigenvalue, lambda one, let's say, is four. Lambda two, the other eigenvalue is two. The eigenvalues are four and two. And then I can go for the eigenvectors. You see, I got the eigenvalues first."}
{"text": " four and two, now for the eigenvectors. So what are the eigenvectors? There are these guys in the null space when I take away, when I make the matrix singular by taking four I or two I away. So we got to do those separately. Let me find the eigenvector for four first. So I'll subtract four, so A minus four I,"}
{"text": " is, so taking four away, we'll put minus ones there. And what's the point about that matrix? If four is an eigenvalue, then A-4I had better be a what kind of matrix? Singular. If that matrix isn't singular, the four wasn't correct."}
{"text": " But we're OK, that matrix is singular, and what's the x now? The x is in the null space. So what's the x1 that goes with the lambda one? So that A, so this is now I'm doing A x1 is lambda one x1."}
{"text": " So I took A minus lambda one I, that's this matrix, and now I'm looking for the x1 in its null space, and who is it? What's the vector x in the null space? Of course it's one one. So that's the eigenvector that goes with that eigenvalue. Now how about the eigenvector that goes with the other eigenvalue? Can I do that with erasing? I take A minus two I."}
{"text": " So now I take two away from the diagonal and that leaves me with a one and a one. So A-2I has again produced a singular matrix, as it had to. I'm looking for the null space of that guy. What vector is in its null space? Well, of course, a whole line of vectors."}
{"text": " So when I say the eigenvector, I'm not speaking correctly. There's a whole line of eigenvectors, and you just, I just want a basis. And for a line, I just want one vector, but you could, you know, there's some freedom in choosing that one, but choose a reasonable one. What's a vector in the null space of that? Well, the natural vector to pick as the eigenvector with lambda two is?"}
{"text": " minus one one. If I did elimination on that vector and set that the free variable to be one, I would get minus one and get that eigenvector. So do you see then that I've got eigenvector, eigenvalue, eigenvector, eigenvalue for this, for this matrix and now comes that"}
{"text": " thing that I wanted to be reminded of. What's the relation between that problem and let me write just above what we found here, A equals zero one one zero. That had eigenvalues one and minus one and eigenvectors one one and eigenvector minus one one."}
{"text": " And what do you notice? What's, how is this matrix related to that matrix? How are those two matrices related? Well, one is just three I more than the other one, right? I just took that matrix and I, I took this matrix and I added three I."}
{"text": " So my question is, what happened to the eigenvalues and what happened to the eigenvectors? That's the, that's like the question we keep asking now in this chapter. If I do something to the matrix, what happens if I, or I know something about the matrix, what's the conclusion for its eigenvectors and eigenvalues?"}
{"text": " Those eigenvalues and eigenvectors are going to tell us important information about the matrix. And here, what are we seeing? What's happening to these eigenvalues, one and minus one, when I add three i? It just added three to the eigenvalues. I got four and two. Three more than one and minus one."}
{"text": " What happened to the eigenvectors? Nothing at all. One one is and minus and one and minus one one are still the eigenvectors. In other words, simple but useful observation. If I add three I to a matrix, its eigenvectors don't change and its eigenvalues are three bigger. Let's just see why. Let me keep all this on the same board."}
{"text": " Suppose I have a matrix A, and Ax equal lambda x. Now I add three i to that matrix. Do you see what the eigenvalues and eigenvectors are going to or how they're coming out? If, so if Ax equals lambda x, then"}
{"text": " This other new matrix, I just have an Ax, which is lambda x, and I have a three x from the three x, so it's just, I mean, it's just sitting there. Lambda plus three x. So if this had eigenvalue lambda, this has eigenvalue lambda plus three, and the x, the eigenvector, is the same x for both matrices."}
{"text": " OK. So that's, great. Of course, it's special. We got the new matrix by adding three I. Suppose I had added another matrix. Suppose I know the eigenvalues and eigenvectors of A. So this is, this, this little board here is going to be not so great."}
{"text": " Suppose I have a matrix A and it has an eigenvector x with an eigenvalue length."}
{"text": " And now I add on some other matrix. So what I'm asking you is, if you know the eigenvalues of A and you know the eigenvalues of B, let me say suppose B and so this is if, let me put an if here, if A x equals lambda x, fine, and B has, has eigenvalues, what shall we call them?"}
{"text": " Alpha one and alpha, say, I'll use alpha for the eigenvalues of B for no good reason. What I'm going to ask is, how about A plus B? Let me give you what you might think first."}
{"text": " OK, if Ax equals lambda x, and if b has an eigenvalue alpha, then am I allowed to say, what's the matter with this argument? It's wrong. What I'm going to write up is wrong. I'm going to say bx is alpha x, add those up, and you get a plus bx equals lambda plus alpha x."}
{"text": " So you would think that if you knew the eigenvalues of A and you knew the eigenvalues of B, then if you added, you would know the eigenvalues of A plus B. But that's false. A plus B, well, when B was three I, that worked great. But this is not so great. And what's the matter with that argument there?"}
{"text": " We have no reason to believe that x is also an eigenvector of b. b has some eigenvalues, but it's got some different eigenvectors."}
{"text": " Normally. It's a different matrix. I don't know anything special. If I don't know anything special, then as far as I know, it's got some different eigenvector y, and when I add, I get just rush. I mean, I get it. I can add, but I don't learn anything. So not so great is A plus B."}
{"text": " Normally the eigenvalues of A plus B or A times B are not eigenvalues of A plus eigenvalues of B. Eigenvalues are not, like, linear. Or, and they don't multiply. Because eigenvectors are usually different and there's just no way to find out what A plus B does to a vector. OK."}
{"text": " Caution. Don't, if B is a multiple of the identity, great. But if B is some general matrix, then for A plus B, you've got to find, you've got to solve the eigenvalue problem. OK. Now I want to do another example that brings out another point about eigenvalues. Let me make this example a rotation matrix."}
{"text": " OK. So here's another example. So a rotate oh, I better call it Q. I often use Q for"}
{"text": " For rotations, because those are the, like, very special, very important examples of orthogonal matrices, let me make it a ninety-degree rotation. So that my matrix is going to be the one that rotates every vector by ninety degrees. So do you remember that matrix?"}
{"text": " It's the cosine of ninety degrees, which is zero, the sine of ninety degrees, which is one, minus the sine of ninety, the cosine of ninety. So that matrix deserves the letter Q, it's an orthogonal matrix, very, very orthogonal matrix."}
{"text": " Now I'm interested in its eigenvalues and eigenvectors. Two by two, it can't be that tough. We know that the eigenvalues add to zero. Actually, we know something already here. The eigen- what's the sum of the two eigenvalues? Just tell me what I just said."}
{"text": " Zero, right, from that trace business. The sum of the eigenvalues is going to come out zero. And the product of the eigenvalues, did I tell you about the determinant being the product of the eigenvalues? No, but that's a good thing to know. We pointed out how that eight appeared in the quadratic equation. So let me just say this."}
{"text": " is zero plus zero, obviously, and that's the sum, that's lambda one plus lambda two. Now the other neat fact is that the determinant, what's the determinant of that matrix? One. And that is lambda one times lambda two."}
{"text": " In our example, the one we worked out, we, the eigenvalues came out four and two, their product was eight, that it had to be eight because we factored into lambda minus four times lambda minus two that gave us the constant term eight, and that was the determinant. OK. What I'm leading up to with this example is that something's going to go wrong."}
{"text": " Something goes wrong for a rotation, because what vector can come out parallel to itself after a rotation? If this matrix rotates every vector by ninety degrees, what could be an eigenvector? You see, we're going to have trouble."}
{"text": " Well, our picture of eigenvectors, of coming out in the same direction that they went in, there won't be any. And with eigenvalues we're going to have trouble. From these equations. Let's see. Why am I expecting trouble? The first equation says that the eigenvalues add to zero. So there's a plus and a minus."}
{"text": " But then the second equation says that the product is plus one. And we're in trouble. But there's a way out. So how, let's do the usual stuff, look at determinant of Q minus lambda I, it'll, so I'll just follow the rules, take the determinant, subtract lambda from the diagonal, where I had zeros,"}
{"text": " The rest is the same, rest of Q is just copy. Compute that determinant. OK, so what does that determinant equal? Lambda squared minus minus one plus one. What's up?"}
{"text": " There's my equation, my equation for the eigenvalues is lambda squared plus one equals zero. What are the eigenvalues lambda one and lambda two? They're I, whatever that is, and minus it, right."}
{"text": " Those are the right numbers. They add to zero, as the trace requires, and they multiply to one, as the determinant requires. But they don't happen to be real numbers, even though the matrix was perfectly real. So this can happen. Complex numbers are going to have to enter eighteen oh six at this moment."}
{"text": " Boom. Right. All right. If I just choose good matrices that have real eigenvalues, we can postpone that evil day. But just so you see, so I'll try to do that. But it's out there. That a matrix, a perfectly real matrix could have, give a perfectly"}
{"text": " Innocent-looking quadratic thing, but the roots of that quadratic can be complex numbers. And of course you, everybody knows that they're, what do you know about the complex numbers? So now let's just spend one more minute on this bad possibility of complex numbers. We do know a little information about the two complex numbers. They're complex conjugates of each other."}
{"text": " If lambda is an eigenvalue, then when I change, when I go, you remember what complex conjugates are? You switch the sign of the imaginary part. Well, this was only imaginary. It had no real part. So we just switched its sign."}
{"text": " So eigenvalues come in pairs like that, but they're complex. A complex conjugate pair. And that can happen with a perfectly real matrix. And as a matter of fact, so that was, like, my point earlier, that if a matrix was symmetric, it wouldn't happen. So if we stick to matrices that are symmetric or, like, close to symmetric, then the eigenvalues will stay real."}
{"text": " But if we move far away from symmetric, and that's as far as you can move, because that matrix is, how is Q transpose related to Q for that matrix? That matrix is anti-symmetric. Q transpose is minus Q. That's the very opposite of symmetry. When I flip across the diagonal, I reverse all the sides."}
{"text": " Those are the guys that have pure imaginary eigenvalues. So they're the extreme case, and in between are matrices that are not symmetric or anti-symmetric, but they have partly a symmetric part and an anti-symmetric part. OK. So I'm doing a bunch of examples here to show the possibilities."}
{"text": " The good possibilities being perpendicular eigenvectors, real eigenvalues. The bad possibilities being complex eigenvalues. We could say that's bad. There's another even worse. I'm getting through the bad things here today. Then the next lecture can, can,"}
{"text": " can be like pure happiness. OK. Here's one more bad thing that could happen. So again, I'll do it with an example. Suppose my matrix is, suppose I take this three three one and I change that guy to zero. What are the eigenvalues of that matrix?"}
{"text": " What are the eigenvectors? This is always our question. Of course, the next sections are going to show why, why do we care, but for the moment, this lecture is introducing them, and let's just find them. OK. What are the eigenvalues of that matrix? Let me tell you, at a glance, we could answer that question. Because the matrix is triangular."}
{"text": " It's really useful to know if you've got properties like a triangular matrix, it's very useful to know, you can read the eigenvalues off, they're right on the diagonal. So the eigenvalue is three and also three. Three is a repeated eigenvalue. But let's see that happen. Let me do it right. The determinant of A minus lambda I,"}
{"text": " What I always have to do is this determinant, I take away lambda from the diagonal, I leave the rest, I compute the determinant, so I get a three minus lambda times a three minus lambda and nothing. So that's where the triangular part came in."}
{"text": " Triangular part, the one thing we know about triangular matrices is the determinant is just the product down the diagonal. And in this case, it's this thing repeated, so lambda one is one, sorry, lambda one is three, and lambda two is three. That was easy. I mean, no, why should I be pessimistic about a matrix whose eigenvalues can be read off right away?"}
{"text": " The problem with this matrix is in the eigenvectors. So let's go to the eigenvectors. So how do I find the eigenvectors? I'm looking for a couple of eigenvectors. So I take the eigenvalue. What do I do now? You remember I solved A-lambda I x equals zero? And what is A-lambda I x?"}
{"text": " So take three away and I get this matrix zero zero zero one, right? Times x is supposed to give me zero, right? That's my big equation for x. Now I'm looking for x, the eigenvector. So I took A-lambda I x and what kind of a matrix am I supposed to have here?"}
{"text": " Singular, right? Supposed to be singular. And then it's got some vectors, which it is. So it's got some vector x in the null space. And what's the, what's, give me a basis for the null space, for that guy. Tell me what's, what's a vector x in the null space, so that'll be the, the eigenvector that goes with I, lambda one equals three. The eigenvector is, so what's in the null space? One zero, is it?"}
{"text": " Now, what's the other eigenvector? What's the eigenvector that goes with lambda two? Well, lambda two is three again. So I get the same thing again. Give me another vector. I want it to be independent. If I'm going to write down an x2, I'm never going to let it be dependent on x1. I'm looking for independent eigenvectors and what's the conclusion?"}
{"text": " There isn't one. This is a degenerate matrix. It's only got one line of eigenvectors instead of two. It's, it's the, this possibility of a repeated eigenvalue opens this further possibility of a shortage of eigenvectors."}
{"text": " And so there's no second independent eigenvector x2. So it's a matrix, it's a two by two matrix, but with only one independent eigenvector. So that will be, those are matrices that, where eigenvectors are, are, don't give the complete story."}
{"text": " OK, my lecture on Monday will give the complete story for all the other lectures. Thanks. Have a good weekend. A real New England weekend."}
{"text": " In this lecture, we will be discussing a solved problem on the shortest job first scheduling. In the previous lecture, we have already discussed about this algorithm and we have seen how it works and what are its properties. So, here we will be seeing a solved problem on this sjf scheduling algorithm. And this problem was also asked in GATE 2014 in computer science. Alright. So, let's see what is this problem and how we can solve it. So, here is the problem. An operating system uses shortest remaining time first scheduling algorithm"}
{"text": " for preemptive scheduling of processes. Consider the following set of processes with their arrival times and burst times in milliseconds. So, what the question says is that an operating system uses the shortest remaining time for scheduling algorithm."}
{"text": " So, we have already seen in the previous lecture that shortest remaining time for scheduling algorithm is another name for this shortest job for scheduling algorithm. And it is using a preemptive type of scheduling for the processes. And then, the arrival times and burst times are given in milliseconds as shown in this table. So, we have four processes p1 to p4, and the arrival times are given here in milliseconds, and the burst times are given here in milliseconds."}
{"text": " Now, the question is the average waiting time in milliseconds of the processes is blank. So, we are supposed to find out what is the average waiting time of these processes. And we have four options. a. 4.5 b. 5.0 c. 5.5 and d. 6.5"}
{"text": " So, let's see how we can solve this and how we can find the average waiting time for these four processes if they are using shortest remaining time for scheduling algorithm for preemptive scheduling of processes. So, remember it is preemptive that means when a process is using the CPU if other processes of shorter time comes then that process will be preempted means a process that was using the CPU can be preempted. The CPU can be taken away from it and given to the process that has the shorter remaining time."}
{"text": " Alright. Now, let us solve this problem. I have just copied down the above table here, so that it fits on the screen. It's the same table. So, in order to solve the problem, we have to find the waiting times for each of these processes one by one. And after that, we have to calculate the average waiting times. So, for that what we have to do is, we have to first form the Gantt chart for this set of four processes."}
{"text": " So, let us see how can we plot the Gantt chart for this set of four processes. So, here is the Gantt chart for this set of four processes p1 to p4. So, if we look at this table, we see that the first process to arrive was process p1 at time zero. So, process p1 arrived at time zero."}
{"text": " And then, since it was the first process to arrive, and since there were no other processes at that time, the CPU was given to process p1. So, here in the Gantt chart, we see that at time 0, p1 arrives, and p1 gets the CPU at time 0 and begins its execution. Now, if we look at this table, we see that at time 2, p2 has arrived."}
{"text": " So, when p2 arrives, we see that the burst time of p2 is 4 which is less than that of p1 which is 12. So, p2 has to be given the CPU. So, what will happen is p1 will be preempted. That means the CPU will be taken away from p1 and p2 will be given the CPU because it has a shorter burst time as compared to p1."}
{"text": " So, at the second millisecond, P2 arrives and the CPU is given to P2. P1 is taken out. So, P2 is now executing and if you look at the table, P3 arrives at time three or the third millisecond. And what is the burst time for P3? It is six milliseconds. Now, let's see what was happening in the Gantt chart. P2 was executing. So, P2 started its execution from the second millisecond."}
{"text": " And at the third millisecond, what happened? P2 completed one millisecond of its execution. So, what is the burst time of P2? It is four. So, at the third millisecond, P2 completed one millisecond of its execution. So, at time three, P2's burst time or the remaining time is now three milliseconds."}
{"text": " Now, p2 is having 3 milliseconds to be executed and at that time p3 arrives and the burst time of p3 is 6 milliseconds which is greater than that of p2. So, p2 will not be disturbed and it will be allowed to continue its execution. So, it is continuing its execution and up to what? Up to the 6th millisecond because p2's burst time is 4 milliseconds. So, 2 plus 4 is 6. So, up to the 6th millisecond p2 continues its execution."}
{"text": " Now, if we see at the 6th millisecond P2 releases the CPU. So, now who is going to get the CPU next? Is it P4? No, it is not P4 because the arrival time of P4 itself is 8 milliseconds. But we are only at the 6th millisecond right now."}
{"text": " So, what are the other processes that we have now? We have p1 and let us see what is the burst time of p1. Is it 12? It is not 12 now because p1 already completed 2 milliseconds of its execution. So, the burst time of p1 is now 10 milliseconds. So, we have p1 with burst time of 10 milliseconds and p2 has already completed its execution. So, p2 is not to be considered anymore. And we have p3 whose burst time is 6 milliseconds."}
{"text": " So, we have p1 and p3. So, p1 it is 10 and p3 is 6. So, which is the smaller one? It is p3. So, p3 will get the CPU at the 6 millisecond here. So, p3 begins its execution. And now let's see what happens. So, as p3 begins its execution, it goes from 6 millisecond to 7 millisecond. Then from 7 millisecond to 8 millisecond. And at that 8 millisecond, p4 arrives."}
{"text": " and the burst time of P4 is 5 milliseconds. So, will P4 get the CPU? If you just look at this table, you may think that yeah P4 should get the CPU because P4's burst time is 5 which is less than that of P3 which is 6. But, if we closely observe in this table, we know that P4 arrived at the 8th millisecond. So, let us see what is the status of P3 at the 8th millisecond."}
{"text": " At the 8th millisecond, p3 already completed 2 milliseconds of execution from 6 to 7 and 7 to 8. So, let us see what is the total burst time of p3. It is 6 milliseconds. So, since it already executed 2 milliseconds, 6 minus that 2 will give us 4 milliseconds."}
{"text": " So, at the time 8 when p4 arrives, the remaining burst time of p3 is 4 milliseconds which is less than that of p4 that is 5. So, p3's remaining time is 4 milliseconds which is less than that of the burst time of p4 which is 5 milliseconds. So, p3 will not be disturbed."}
{"text": " P3 will be allowed to continue its execution and it will continue until it finishes. So, the total burst time of P3 is 6 milliseconds. So, 6 plus 6 is 12. So, up to the 12th millisecond P3 executes. Now, what are the remaining processes that we have? Let us see. So, P2 has completed, P3 also has completed."}
{"text": " Now, we have only P4 and P1. Now, what are the burst times? We know that P1's remaining burst time is 10 milliseconds and P4 which has not even got the CPU once, its burst time is 5 milliseconds. So, if we compare P1 and P4, the smaller one is P4. So, P4 is the one going to get the CPU. So, P4 gets the CPU at 12 milliseconds and it will execute for how long?"}
{"text": " for 5 milliseconds. So, 12 plus 5 is 17. Now, at the 17th millisecond, the last one which is P1 will get the CPU, and it will continue execution for 10 milliseconds. So, 17 plus 10 is 27. So, at the 27th millisecond, P1 completes its execution, and here we have the complete Gantt chart for this set of four processes."}
{"text": " So, we have to always keep in mind that this is preemptive and whenever a process arrives, we have to closely observe what is the status of the process that is executing currently. We have to see its remaining burst time. Not the total burst time but the remaining burst time. And depending upon that, you have to compare with the process that arrives and whichever is lesser will get the CPU. So, that is how you form the Gantt chart for a preemptive shortest remaining time first scheduling."}
{"text": " So, how do we calculate the waiting times? We have already discussed the formula in the previous lecture. So, this is the formula. The waiting time is the total waiting time minus number of milliseconds the process executed minus the arrival time. So, the waiting time of a process is calculated by seeing the total waiting time which is visible in this Gantt chart and from that we subtract the number of milliseconds the process executed prior to the total waiting time."}
{"text": " And from there we subtract the arrival time. So, that will give us the waiting time for a particular process. So, let us calculate that one by one for processes p1 to p4. So, here are the waiting times for processes p1 to p4. So, for p1 what is the waiting time? The total waiting time of p1. So, let us see where is p1. p1 lastly executed over here. And what was the total waiting time? It was 17 milliseconds. So, we have 17"}
{"text": " minus the number of milliseconds the process executed prior to that. What is that? If you see in this Gantt chart, p1 already executed 2 milliseconds before coming here. So, minus that number of milliseconds the process executed which is 2 milliseconds minus the arrival time of p1 that is zero. So, if you subtract this, we will get 15 milliseconds which is the waiting time for p1."}
{"text": " And similarly for p2, what is the total waiting time? We see that p2 is seen only here in the Gantt chart. And the total waiting time was 2 milliseconds. And the number of milliseconds the process executed before that, we see that p2 never executed before that. So,"}
{"text": " It is zero and the arrival time of p2 that is 2 milliseconds. So, minus 2. That will give us 2 minus 0 minus 2 that is 0 milliseconds. So, if you look in this Gantt chart also, we can understand that p2 arrived at the second millisecond and as soon as it arrived, it got the CPU. So, it did not have to wait. So, we have zero."}
{"text": " Then, similarly for P3, what is the total waiting time? P3 got the CPU at the 6th millisecond. So, the total waiting time for P3 is 6 milliseconds minus the number of milliseconds it executed prior to that. We don't have P3 before. So, that is also zero. And then the arrival time of P3, that is 3 milliseconds. So, 6 minus 0 minus 3 is 3 milliseconds."}
{"text": " And then finally for p4, if you see what is the total waiting time, it is 12 milliseconds. So, 12 minus number of milliseconds it executed prior to that. We don't have p4 prior to that. So, it is zero. And then the arrival time of p4 is 8 milliseconds. So,"}
{"text": " 12 minus 0 minus 8 which gives us 4 milliseconds. So, here we have calculated the waiting times for processes P1 to P4. Now, we can easily calculate the average waiting time. So, the average waiting time is 15 plus 0 plus 3 plus 4 divided by the total number of processes which is 4. And that gives us 5.5 milliseconds."}
{"text": " So, this is the average waiting time for the processes P1 to P4. So, we are getting 5.5 milliseconds. So, let us see if we have 5.5 milliseconds in our option. So, coming back to the question, if we see the options, here we have option C which is 5.5 milliseconds. So, option C is the answer to this question. So, I hope this was clear to you how we calculate the waiting times for a operating system that uses the shortest remaining time for scheduling for"}
{"text": " preemptive scheduling of processes. So, thank you for watching and see you in the next one."}
{"text": " In this lecture, we are going to discuss about another solved problem on process synchronization, and this problem is from GATE 2019 CS paper. All right. So, let's see what is the question. Consider three concurrent processes P1, P2, and P3 as shown below, which access a shared variable d that has been initialized to 100. So, we have three processes P1, P2, and P3, and they are accessing this shared variable d. So, this variable d is shared between P1, P2, and P3."}
{"text": " That means, all of p1, p2, and p3 can read from d, they can update the value of d. So, the initial value of d is set to 100. Now, what does p1 do? p1 sets d equal to d plus 20. So, it adds 20 to the current value of d."}
{"text": " and p2 subtracts 50 from the value of d, and what p3 does is, it will add 10 to the value of d. So, these are what the three processes p1, p2, and p3 are capable of doing. So, now let's see what is the question. So, the question says, the processes are executed on a uniprocessor system running a time shared operating system."}
{"text": " If the minimum and maximum possible values of d after the three processes have completed execution are x and y respectively, then the value of y minus x blank. So, here it says that, these processes are executed on a uniprocessor system. That means, it is a system in which only one process can run at a time, and it is running a time shared operating system. That means, each process will be given a particular amount of time to execute, after which it will be preempted, and then the next process will be given the chance."}
{"text": " So, there will be a time slice for each of the process to carry out their executions. So, it says here, if the minimum and maximum possible values of d after the three processes have completed execution are x and y respectively, then what is the value of y minus x? So, here we need to consider what are the maximum and minimum values of d that is possible."}
{"text": " If the processes p1, p2, and p3 all completes execution in some order, which we don't know, which we have to figure out, we have to find out what is the minimum possible value of d that can be there and what is the maximum possible value of d that can be there. So, we have to find out some particular order, if these processes are executed, what is the minimum possible value of d and the maximum possible value of d."}
{"text": " So, here we are considering that x is the minimum possible value and y is the maximum possible value. What is the value of y minus x? That means, what is the difference between the maximum value and the minimum value? So, we have three options, 80, 130, 50 or none of these. So, let us see how we can solve this."}
{"text": " First of all, there are many orders in which they can execute. So, we have to figure out the order in which it will give the maximum value and the order in which they can give the minimum value of d. And keep in mind that, the operations that can be performed by these processes p1, p2, and p3 are the read operation. It can read the value of d."}
{"text": " and it can calculate the value of d. So, there are calculations that we see here. p1 is doing this, p2 is doing this, and p3 is doing this, and then they can update the value of d. So, these are the three operations that can be performed. Read, calculate, and update. We see that the initial value of d is set to 100. So, that is given in the equation. It is initialized to 100. We have processes p1, p2, and p3. So, we need to figure out"}
{"text": " If this process executes in some order, what is the maximum and minimum values that we can have? So, first of all, let's try to find out the minimum value. Let's start with process p2 because p2 is doing the subtract operation. So, let's assume that if we go in this order, we can get the minimum value."}
{"text": " So, what is the first value of d that we have? It is 100. So, let's say that p2 is now going to begin its execution. So, what p2 will do? First, it will read the value of d. What is the value of d? The first value of d is equal to 100. So, p2 just read the value of d. Now, before it calculates, let's say that the time is over and it got preempted. And once it gets preempted, now let's say p1 is the next one who gets a chance."}
{"text": " So, p1 when it will read, it will see that the value of d is also equal to 100 because d was only read by p2 and it did not modify anything. So, the value of d still remains as 100. Now, what will p1 do? Let's say that it is also allowed to calculate an update."}
{"text": " P1 will set the value of d equal to d plus 20. So, it will add 20 to it and hence what will it give? It will give the value 120. So, the value of d becomes 120 now. Now, let's say that P3 gets the chance."}
{"text": " Now, when p3 will read, what is the value of d that it will see? This is the latest value of d that is there. According to p3, the value of d is 120 and what will it do? It will add 10 to it. Let's say that it is allowed to do the calculation and the updation also. So, the value becomes 130. So, p1 has completed, read, calculate and update. p3 also has completed, read, calculate and update. But, what about p2?"}
{"text": " P2 just read the value of d and before it calculated and updated, it was preempted. So, what will happen here? It is still thinking that the value of d is equal to 100. So, according to P2, the value of d is still 100. We know that the final value here we have is now 130."}
{"text": " But, p2 when it has read, at that time the value was 100. So, if it is not reading again, it is still having that value as 100. So, now it will do the calculation. So, what is the calculation? d minus 50. So, it will subtract 50 from here, and what is the value that it will have? The value is 50."}
{"text": " This is the value that is given by p2. So, if we execute in this order, and if we see that p2 gets preempted in that way, then the minimum possible value that we can have is 50. So, 50 is the minimum value that we have for d. So, we have found the minimum value which is x. Now, we have to find the maximum value. So, again let's say that we have these processes p1, p2, and p3."}
{"text": " So, in this case, we have to find the maximum value. So, let's say that we are starting from p1. So, we see that p1 is the one that adds the most value to d. So, that is why we will start from p1. It is not always the case, but let's just assume that that is going to be the case, and let's just start from p1. So, p1 will first read. So, what is the value of d? The value of d is 100. And then, before p1 could calculate and update, let's say that it gets preempted. So, it gets preempted, and the control goes to p2, let's say."}
{"text": " So, for p2, the value of d is still equal to 100, and let's say that p2 is allowed to read, calculate, and update. So, what does p2 do? It is subtracting 50 from it. So, it subtracts 50 from it, and then it makes the value equal to 50. Okay. So, this is the value that we have for d that is updated by p2."}
{"text": " Now, let's say that p1 gets back the control again here. So, if p1 gets back the control here again, then what will happen? According to p1, d is equal to 100. It already read the value of d equal to 100, but it did not calculate an update. So, it will not read again. It is just going to calculate an update. So, what does p1 do? p1 adds 20 to the value of d. So, plus 20 which makes it 120. So, it updates a value. Now, p3 gets a chance."}
{"text": " So, according to p3, when it will try to read, what will it read? It will read the final value which is 120. So, that is the latest value, and what does it do? It will add 10 to it. So, it adds 10 to it, giving the value 130. This is the final value of d that we have here, and we see this is the maximum value that we can get. So, you may be thinking, why did we make some of the process preempt after reading and not allow it to calculate and update?"}
{"text": " Only if we do in that way, we are able to get the maximum value. So, you have to check like this, in which way are we able to get the maximum values of d. This 130 is the maximum value that we can get, and the minimum value is 50. So, we got the values of x and y. So, x is equal to 50, which is the minimum value, and y is equal to 130, that is the maximum value."}
{"text": " Okay. So, now we have the values of x and y, and our question was to find out what is y minus x. So, what is y minus x? 130 minus 50, which is equal to 80. This is our answer. And do we have it in the equation? Yes. Option a is 80. So, this is the difference between the maximum and the minimum values that we can have for the value of d, if this processes p1, p2, and p3 are executed."}
{"text": " So, in this way, you have to figure out what is the maximum and minimum values that we can get if the processes are preempted in some order. All right. So, that is how you will be solving this question. So, I hope this was clear to you. Thank you for watching and see you in the next one."}
{"text": " In this lecture, we will be discussing another solved problem on first come first served scheduling. So, this is the second problem that we are discussing on the FCFS scheduling algorithm. Alright. So, let's see what is the problem and let's see how we can solve it. So, here is the problem. The arrival times and burst times of a set of six processes are given in the table below."}
{"text": " So, we have a table here where the arrival times and burst times for a set of six processes are given. So, the processes are denoted with process IDs P1 to P6. So, here is a question. If FCFS scheduling algorithm is followed, and there is one unit of overhead in scheduling the processes, find the efficiency of the algorithm. So, it says here that for the set of six processes, when they arrive at these times,"}
{"text": " and when they have this unit of burst times, and if they are following a first come first serve scheduling algorithm, and there is one unit of overhead in scheduling the processes, we have to find the efficiency of this algorithm. Alright. So, before we go into that, let us try to understand what does this term mean. There is one unit of overhead in scheduling the processes."}
{"text": " So, we already know how FCFS scheduling algorithm works. The process that comes first will be served first or given the CPU first. That's what we mean. Now, by this one unit of overhead in scheduling processes, what we mean is that when a process arrives in the ready queue and is to be given the CPU,"}
{"text": " the CPU cannot be given just at that particular instant. That means, exactly at that time, the CPU cannot be given to the process. The system has a delay, a slight delay of one unit before it assigns the CPU to each processes. So, whenever a process arrives, the system will have one unit delay in assigning the CPU to the process."}
{"text": " And even when the CPU is switched between processes, there will be one unit of time delay in switching the CPU between the two processes. So, one unit of time delay will be there. So, that is what we mean by one unit of overhead in scheduling the processes."}
{"text": " So, if it is like this, then what will be the efficiency of this particular algorithm for this particular set of processes if they arrive at this particular set of times and if they have this particular set of burst times. Let us try to find that out. So, first of all what we are going to do is, we have to draw the Gantt chart for this. So, let us see how we can form the Gantt chart for this set of processes following this method. So, coming to the solution, we are going to form the Gantt chart and this is how the Gantt chart for this set of processes will look like."}
{"text": " So, let me explain this Gantt chart to you. It looks a bit different from the previous Gantt chart that we have formed in the previous solved example that we discussed in the previous lecture. And why is that? That is because we are having this del in this Gantt chart. And what is this del? This del denotes the unit overhead in scheduling the processes. Because in the equation we said that there is one unit of overhead in scheduling the processes."}
{"text": " So, that one unit of delay is denoted by this del over here in this Gantt chart. Alright. So, let's see how we have formed this Gantt chart over here. So, we see that processes p1 to p6, they arrived at these units of time. So, p1 arrived at zero unit of time, p2 at one, p3 at two,"}
{"text": " P4 at 3, P5 at 4 and P6 at 5. So, the arrival times are 0, 1, 2, 3, 4, 5 and these are the burst times. So, which is the first process that arrived? It is P1. It arrived at the zeroth unit of time. So, here we are following FCFS scheduling algorithm which is first come first served. So, P1 should be the one that should be served first or given the CPU first."}
{"text": " So, here at 0th unit of time, P1 arrives. But, as we know that there is one unit of overhead in scheduling, as I told you, the CPU cannot be assigned directly at that time itself, but there will be a slight delay of one unit of time."}
{"text": " So, even though p1 arrived at zero unit of time, there is a delay of one unit of time. So, that is why we have shown this del over here. So, from zero to one, that means for one unit of time, this del is shown, and exactly at time one, p1 will get the CPU for its execution. So, after this delay of one unit, p1 gets the CPU for its execution."}
{"text": " Now, how long will p1 use the CPU? The burst time. We have to check the burst time for p1. What is it? It is 3 units of time. So, p1 will use the CPU for 3 units of time. So, 1 plus 3 gives us 4. So, the completion time of p1 is 4 units of time."}
{"text": " Now, again if we look at the table here, we see that p2 arrives at 1, the time 1. So, p2 should be the next one. So, if you observe this table, it is 0, 1, 2, 3, 4, 5. So, obviously, the order of arrival is p1, p2, p3, p4."}
{"text": " P5, P6. So, it is easy to remember for this example. So, P2 is the next one that should get the CPU. But, as we know that there is one unit of overhead in scheduling the processes. Again, after P1 releases the CPU, before P2 gets the CPU, there will be one unit delay. So, 4 to 5, there is less delay over here."}
{"text": " Now, at the fifth unit of time, P2 will get the CPU. And how long will P2 execute? It will execute for two units of time. So, from five to seven. Five plus two is seven. So, P2 executes for two units of time, and the completion time is seven."}
{"text": " Now, again, the next process is p3, but p3 will have to wait for one unit of time. So, again, 7 to 8 is the delay. And then, at the 8th unit of time, p3 gets the CPU and executes for one unit of time. So, 8 plus 1 is 9. So, p3 executes for one unit of time."}
{"text": " And again, before P4 gets the CPU, there is a delay of 1 unit of time. So, 9 plus 1 is 10. So, there is this delay here. And when P4 gets the CPU, it has to execute for 4 units of time. So, 10 plus 4 is 14. So, P4 executes for 4 units of time. Hence, the completion time is 14."}
{"text": " Then again, before p5 gets the CPU, we have to wait for 1 unit of time. So, it comes from 14 to 15. And p5 executes for 5 units of time. So, from 15 to 20. 15 plus 5 is 20. So, p5 uses the CPU up to the 20th time. And then again, there is a delay of 1 unit of time. So, 20 plus 1, 21. And then lastly, p6 gets the CPU, and it has to use the CPU for 2 units of time."}
{"text": " So, at the 21th unit of time, P6 got the CPU and it executes for 2 units of time. So, 21 plus 2 is 23. So, this is how we form the Gantt chart for this set of 6 processes when there is a unit overhead in scheduling the processes and when they arrive at this particular times with this particular burst times. So, if we see the entire time it took for these 6 processes to complete execution was 23 units of time."}
{"text": " Alright. So, we have this information with us, and with this let us try to calculate the efficiency of this algorithm, and let's see how we can do that. So, to find the efficiency of this algorithm, there are certain values that we need to first calculate, and let's see what they are. So, the first one is the useless time or the wasted time."}
{"text": " So, we see that this del which was the overhead in scheduling the processes is the time that is wasted. That time was not being utilized by any of the processes, and it is the useless time or the wasted time. So, how much time did we waste? We have 1, 2, 3, 4, 5, 6."}
{"text": " So, we have six units of del over here. And we already said that the overhead is for one unit of time. So, all this del represents one unit of time. So, six del into one unit of time. Hence, we have six units of time that is wasted or which was useless. And then next we have the total time. The total time that was taken for this entire processes to complete their execution."}
{"text": " So, if you look at the Gantt chart, it is 23. The last process P6 completed its execution at the 23rd unit of time. So, the total time is 23 units. And then, we have the useful time. So, from these two values, we can calculate the useful time. So, what is the useful time? The useful time will be the total time minus the useless or the wasted time. So, the useful time will be 23 units, which is the total time taken by these processes to complete their executions."}
{"text": " minus the useless time or the wasted time, which is six units of time. So, that gives us 17 units. So, the useful time is 17 units. All right. So, from this, now let us calculate the efficiency. So, the efficiency will be calculated like this. Useful time divided by the total time. The useful time that was spent divided by the total time that was taken."}
{"text": " So, what is the useful time? It is 17 units. And what is the total time that was taken? It is 23 units. So, if we divide 17 by 23, we get 0.7391. And if we convert it to percentage, it is 73.91%. So, this is the efficiency of this algorithm for this particular set of processes when they arrived at the particular given arrival times."}
{"text": " with the given burst times, and when there is a overhead of one unit of time in scheduling the processes, and when they follow the first come first served scheduling algorithm. So, that is how you calculate the efficiency of a particular algorithm, depending upon the type of processes, and depending upon the delays that is given. So, I hope this was clear to you. Thank you for watching, and see you in the next one."}
{"text": " In this lecture, we will be discussing another solved problem on priority scheduling. So, let us see what is this problem and how we can solve it. So, here is a problem. Consider the set of processes with arrival times given in milliseconds, CPU burst time given in milliseconds, and priority as shown below."}
{"text": " And here higher numbers represent higher priority. If the CPU scheduling policy is priority non-preemptive, calculate the average waiting time and average turnaround time. So, in the previous lecture that we have discussed, we solved a problem that was based on preemptive priority scheduling."}
{"text": " But, this question is based on non-preemptive priority scheduling. And, here we have to calculate the average waiting time and the average turnaround time for this set of processes with process IDs p1 to p5, where their arrival times given here in milliseconds, burst times given in milliseconds, and priorities given here. And, also note that in this problem,"}
{"text": " higher number represents higher priority. So, in the previous problem that we solved, the lower the value, the higher was the priority. But in this case, the higher the value, the higher will be the priority. So, if you look at this priority list, five is the highest priority and two is the lowest priority. So, I am taking this example because you should be familiar with the different kind of problems that can be there."}
{"text": " So, in some cases, the lower number may represent higher priority, and in some cases, the higher number may represent the higher priority. So, pay close attention to what the question asks, otherwise you may make a mistake. So, given this information, our task is to calculate the average waiting time and the average turnaround time. So, let's see how we can do that."}
{"text": " So, in order to solve the problem, I have copied down the same table here again. And the first step as we have already discussed many times is to form the GAN chart for this set of processes. Now, remember that in the equation it was said that this is a non-preemptive priority scheduling. So, when we say non-preemptive, what it means is when one process gets the CPU for its execution, then until and unless it completes its execution,"}
{"text": " No other process will take the CPU away from it. That means it will never be preempted. So, keep this in mind when we are forming the Gantt chart. Alright. So, let's see how the Gantt chart for this can be formed. So, here is the Gantt chart for this set of processes P1 to P5."}
{"text": " So, let's see what happens. Let's see which is the first process that arrives. If you look at the table, we see that p1 arrives at time zero. So, p1 is the first process to arrive. Since there were no processes at that time and since p1 was the first one, it gets the CPU and begins its execution."}
{"text": " And how long will p1 execute? It will execute for four milliseconds because that is the burst time of p1. And then, no processes will disturb p1 until and unless it completes its execution. Because this is a non-preemptive practice scheduling. And also the priority of p1 is two. So, since there were no other processes at that time, we don't have to worry about the priority for this case."}
{"text": " Now, let's see. P1 is continuing its execution, and then at one millisecond, P2 arrives. And let's see what is the condition in our Gantt chart at that time. So, at one millisecond, P1 is already executing. Now, if you see here, and if you check the priority, you see that it's having a priority of three."}
{"text": " Now, if you compare the priority of p1 and p2, we see that p2 has a higher priority. So, keep in mind that in this case, the higher the numbers, the higher is the priority. So, p2 has a priority of three, which is higher than that of p1. But, will it be preempted? It will not be preempted because this is a non-preemptive scheduling. So, even though the priority of p2 is greater than that of p1, p1 will still not be disturbed. It will be allowed to continue its execution."}
{"text": " So, till the fourth millisecond, p1 continues its execution. So, if you look at this table, we see that at two milliseconds, p3 also arrived, and at the third millisecond, p4 also arrives, and at four milliseconds, p5 also arrives."}
{"text": " So, when p1 was continuing execution from 0 to 4 milliseconds, at this portion of time, all the other processes have also arrived. And if you check the priorities, we see that p2 has priority of 3, p3 has a priority of 4, and p4 and p5 both has priorities of 5."}
{"text": " And we see that all these priorities are greater than that of p1 which is 2. But, even then p1 will not be disturbed because this is a non preemptive priority scheduling. So, now we see that when p1 was executing from 0 to 4, all these other processes have already arrived and are now waiting at the ready queue. Alright. Now, at the fourth millisecond p1 completes its execution. So, p1 finishes its execution and the remaining processes are p2, p3, p4 and p5."}
{"text": " Now, they have all arrived and they are all waiting at the ready queue. So, we don't have to worry about this arrival times anymore. So, what we have to see is, which among this set of four processors has the highest priority. So, if we check, here we have 3, 4, 5, 5. So, we see that P4 and P5, they are having the highest priority. So, either P4 or P5 should be getting the CPU."}
{"text": " Now, if you look, we see that P4 and P5 has the same priority. So, who should get the CPU? There is a tie over here. Now, if we have this kind of a tie, in order to break the tie, we will be using the FCFS scheduling. That means, the first come first serve scheduling."}
{"text": " So, if two processes are having the same priorities, then the process that arrived first among them will be the first to get the CPU. So, if you see here, P4 arrived at three milliseconds, and P5 arrived at four milliseconds. So, P4 was the first one to arrive."}
{"text": " So, we will be giving the CPU to P4. So, P4 gets the CPU, and it will continue its execution for how many milliseconds? 5 milliseconds, because that is the burst time of P4. So, from 4 to 9 milliseconds. 4 plus 5 is 9. So, up to the 9th millisecond, P4 will continue its execution."}
{"text": " So, after P4 releases the CPU, who will get the CPU? It's obvious, it is P5 because P5 also had the same priority, but since P4 arrived earlier, the CPU was given to P4. So, next the CPU will be given to P5, and how long will P5 execute? It will execute for 2 milliseconds. So, from 9 to 11, 9 plus 2, 11, up to the 11th millisecond, P5 uses the CPU for its execution."}
{"text": " Alright. So, now we see that p1 completed, p4 completed, p5 also completed. So, the remaining processes are p2 and p3. Now, among p2 and p3, who has the highest priority? We see that p3 has a priority of 4, which is higher than that of the priority of p2, which is 3."}
{"text": " So, p3 will be the next one to get the CPU when p5 releases it. So, p3 gets the CPU when p5 releases it. And how long will it execute? It will execute just for one millisecond, which is the burst time of p3. So, from 11 to 12 milliseconds, p3 executes. And then, the final process that we have is p2. So, p2 will now get the CPU after p3 releases it at 12 milliseconds."}
{"text": " And P2 will execute for 3 milliseconds which is the burst time of P2. So, 12 plus 3 is 15. So, up to the 15th millisecond, P2 uses the CPU, and at this point, all the processes have completed their execution. So, this is how we form the Gantt chart for a set of processes when they follow a non-preemptive priority scheduling."}
{"text": " So, here, since it is non-preemptive, it is a bit easier to form the Gantt chart because you are not going to preempt any processes. But, keep in mind the arrival time. See the arrival times and see the priorities. So, in this case, when P1 was executing from 0 to 4 milliseconds, all the other processes already arrived and were waiting in the ready queue. So, we just had to see the priorities of those processes and assign the CPU to them one by one based on the highest priority."}
{"text": " So, now we have the Gantt chart. Now, what we have to do is, we have to calculate the average turnaround time and the average waiting times. So, in order to calculate that, first we have to calculate the turnaround times and the waiting times for these set of processes one by one. So, let's see if we can recall the formula for that. So, here is a formula."}
{"text": " So, these formulas are same as the ones that we use for some of the other scheduling algorithms when they follow the non-preemptive form of scheduling. So, the turnaround time is the completion time minus the arrival time. So, we need to see when a process completed its execution, and from that if we subtract the arrival time, then we get the turnaround time."}
{"text": " And the waiting time is the turnaround time that we calculated here minus the burst time. That will give us a waiting time. So, let us calculate the turnaround time and waiting time for all these processes one by one. Alright. So, here we have a table in which we will be calculating the turnaround times and the waiting times. So, first of all, we need to find out the completion times because that is required for calculating the turnaround time. So, we have process with process ids p1 to p5, the same thing."}
{"text": " And let us see the completion times for this set of processes. So, for P1, what is the completion time? So, for getting the completion time, just look at the Gantt chart and see when the process released the CPU or completed its execution. So, if you see P1, it completed its execution at 4 milliseconds. So, that is the completion time of process P1. And for P2, what is the completion time? It is 15 milliseconds."}
{"text": " And for P3, it is 12 milliseconds. For P4, it is 9 milliseconds. And for P5, it is 11 milliseconds. So, this is very easy. Just look at the Gantt chart and fill this up. Alright. So, let's calculate the turnaround time. So, for process P1, what is the turnaround time? It is the completion time minus the arrival time. So, what is the completion time of process P1? It is 4 milliseconds. What is the arrival time? It is 0 milliseconds. So, what will be the turnaround time? It is 4 minus 0, which is 4 milliseconds."}
{"text": " So, similarly for p2, what is the completion time? It is 15. And what is the arrival time? It is 1 milliseconds. So, what will be the turnaround time? It is 15 minus 1, which is 14 milliseconds. And for p3, what is the completion time? It is 12 milliseconds. And what is the arrival time? The arrival time of p3 is 2 milliseconds. So, what will be the turnaround time? The turnaround time is 12 minus 2, which is 10 milliseconds. And similarly for p4, the completion time is 9."}
{"text": " And then the arrival time is 3. So, the turnaround time will be 9 minus 3 which is 6 milliseconds. And similarly for p5, the completion time is 11 milliseconds. And the arrival time of p5 is 4 milliseconds. So, that gives us a turnaround time of 11 minus 4 which is 7 milliseconds. So, hence we have found the turnaround times for the set of processes p1 to p5. Now, we can calculate the waiting times. So, the waiting times can be calculated by"}
{"text": " turnaround time minus the burst time. So, we have already calculated the turnaround times. So, from that, we have to subtract the burst times from this table. So, that will give us a waiting time. So, let's see. For process P1, the turnaround time is four milliseconds, and what is the burst time of P1? It is four milliseconds. So, what is the waiting time of P1? It is four minus four, which is zero milliseconds. So, you see that P1 was the first process to arrive, and even though it had a priority of two,"}
{"text": " Since it was the first process to arrive and since there were no processes at that time, P1 was given the CPU and it did not have to wait at all. And since this was a non-preemptive priority scheduling, P1 was not disturbed until its execution was complete. So, P1 did not have to wait at all. So, that is why the waiting time of P1 is zero milliseconds."}
{"text": " So, similarly for p2, what will be the waiting time? It is the turnaround time 14 minus the burst time of p2, which is 3 milliseconds. So, that gives us 14 minus 3, 11 milliseconds. And for p3, it will be turnaround time 10 minus the burst time, which is 1. That gives us 10 minus 1, that is 9 milliseconds. And for p4,"}
{"text": " The turnaround time is 6, and then the burst time of P4 is 5. So, that will give us a waiting time of 6 minus 5, that is 1 millisecond. And finally, for P5, the turnaround time is 7, and the burst time is 2. So, we have a waiting time 7 minus 2, that is 5 milliseconds. So, we have also calculated the waiting time for this set of processes P1 to P5."}
{"text": " So, now calculation of the average turnaround time and average waiting times are very easy. So, how do we do it? The average turnaround time is 4 plus 14 plus 10 plus 6 plus 7 divided by the number of processes which is 5 which gives us 41 divided by 5 which is 8.2 milliseconds. And similarly, the average waiting time is 0 plus 11 plus 9 plus 1 plus 5 divided by the number of processes which is 5. That gives us 26 divided by 5 which is 5.2 milliseconds."}
{"text": " So, our question was to calculate the average turnaround time and the average waiting times for this set of processes when they follow a non-preemptive practice scheduling, and we have done that. So, even here we see that the most important thing is to form the Gantt chart, and after you form the Gantt chart, if you remember these formulas, we can easily calculate the turnaround times and waiting times and calculate the final answer. And even this formula, you don't have to memorize it. I have already explained how we come to this formula in the"}
{"text": " previous lectures. So, using that, remember how we arrive at this formula and keep it in mind, and it will be very easy to proceed with this kind of calculations. So, I hope the way we solve this problem was clear to you. Thank you for watching and see you in the next one."}
{"text": " Hey guys, this is part two of my introduction to classes and objects. And in this video, I'm going to talk about how multiple classes and objects can interact with each other. So let's get started. Now, just a quick recap of the last video, we created this class called Robot with the three attributes, name, color, and weight. Name was a string, color was a string as well, and weight was an integer."}
{"text": " and it had only one function called introduceSelf. And when this function is run, it'll just print out, my name is name, whatever the name is. And then, out of this class, we created two objects. The first one was this one, a robot object with the name Tom, color red, and weight 30, to show that it's 30 pounds. And the second object was a robot object with the name Jerry, color blue, and weight 40."}
{"text": " and we put the first object in this variable called r1, and then we put the second object in this variable called r2. Now, let's say on top of that, we have another class here. This class is going to be called Person to represent any person you want to represent, and it's going to have three attributes."}
{"text": " name, which is going to be a string, personality, which is also going to be a string, and isSitting, which is going to be a boolean, which means this is going to be either true or false, and if this is true, that will mean that this particular person is sitting, and if this value is false, that'll mean that this person is not sitting."}
{"text": " Using this class, we'll be able to create a couple of objects here as well. And the first object here might look like this. This is going to be a person object, of course, with the name Alice, personality, aggressive, and is sitting, false. So this person is not sitting, she's probably standing."}
{"text": " And the second object here might look like this. This is a person object with the name Becky, personality talktive, and isSitting true. And let's put the first object here, the person named Alice, to this variable called p1, and then let's put the second object here to p2, to show that this is person1 and this is person2."}
{"text": " And let's say this Person class has a few methods, or a few functions as well. SitDown and StandUp. All they're gonna do is gonna be pretty simple. When you run SitDown, this function, on, let's say, this particular object, p1, by saying p1.sitDown, it'll just turn the isSitting value to true, because that person will be sitting."}
{"text": " And then if the isSitting value is already true, when you run sitDown on that object, it'll just stay at true. And the same thing with standUp, it's just gonna do the opposite. So if you run standUp on p2, by writing p2.standUp, it's gonna turn the isSitting value to false, and then if it's already false, it's just not gonna do anything."}
{"text": " Now, having these two classes and these two sets of objects separately is fine, but is there any way to somehow make them interact with each other, and somehow show the relationships between these two sets of objects? One situation when you might want to do this is, for example, when you want to say that a person, a particular person, owns a particular robot."}
{"text": " So, for example, this person named Becky might own this robot named Tom, and this person, Alice, might own this other robot, Jerry. So, how can we express that? One way to show that is having an extra attribute to the Person class."}
{"text": " And that attribute might be called something like RobotOwned. This is going to be the particular robot that's owned by this person. And this is going to be a robot object. So for example, if you want to show that Alice owns Jerry, which is in this variable called r2, you can just set the RobotOwned attribute of this person object to r2."}
{"text": " And this is going to show that P1 owns R2. And then you can do the same thing for P2, Becky. If you want to show that this person owns this robot, which is in the R1 variable, you can just set the robot own attribute of this person to R1. And this is one very common way of expressing the relationships between multiple classes and objects."}
{"text": " Okay, let's now see how we can actually implement that using code. I'm going to use Java as an example here, but other languages like Python are going to be usually pretty similar. And let's just quickly recap what we did in the last video. We defined a class called Robot by writing class Robot curly brackets,"}
{"text": " And this class had three attributes, or three instance variables, string name, string color, and integer weight. And we also defined a constructor for creating a new object out of this class, and that one took three arguments, string n, string c, int w,"}
{"text": " And it created a new object, and set that object's name, this.name, to n, and that object's color, that new object's color, to c, and that weight, that object's weight, to w. And this class had one method too, of course, introduceSelf, and that one printed, my name is whatever this object's name is."}
{"text": " And then we used the constructor that we defined ourselves to create a couple of objects. The first object had the name Tom, color red, and weight 30, and so on. And then we were able to, of course, use this function, introduceSelf, by writing r1.introduceSelf and r2.introduceSelf."}
{"text": " And just a quick note, if you want to implement this yourself, you'll be able to put both of these blocks of code in a single file. And then for me, I'm going to call it TestRobotAndPersonJava, and you'll be able to find a link to this file in the description below as well. Okay, moving forward, to implement what I explained earlier, each person owning a particular robot, let's create a Person class by writing, of course, class Person curly brackets."}
{"text": " And then this Person class will have these attributes, StringName, StringPersonality, and Boolean isSitting. And of course, Boolean just means that isSitting will be either true or false. And then to show that each person owns a particular robot, we'll need to add another attribute, of course, called RobotOwned."}
{"text": " And this RobotOwn, the value of this attribute, will be a Robot object, so the type of this attribute will need to be Robot. And then, just like we did with the Robot class, we can create a constructor here as well. This constructor is going to be called Person, because we need to call a constructor the same name as the class. So this is Person, which takes three arguments, string n, string p, and Boolean, i,"}
{"text": " And then once we create this object by using this constructor, this.name, that new object's name will be n, the given string, and then this new object's personality will be p, which is another given argument."}
{"text": " and then that object's isSitting attribute, isSitting instance variable, will be the given i. And let's just quickly define the other methods we had in this class as well. One of them was called sitDown. This is just going to simply set this object's isSitting value to true,"}
{"text": " And then, the opposite of sitDown, which is standUp, that one sets this object's isSitting instance variable, or attribute, to be false. And note here that if this.isSitting is already false when you run standUp, this is not going to do anything, because it's basically resetting this value to be false again."}
{"text": " Okay, at this point, you can create a Person object by saying new Person, Alice, Aggressive, and False. So this is going to create a new Person object with the name Alice, personality Aggressive, and isSitting False, and we can assign that to a variable called p1 with the type Person."}
{"text": " And let's do the same thing for a second person object. This person's name will be Becky, personality will be Talkative, and she will be sitting, so isSitting will be true. And then we're going to put that in P2. After that, if you want to show that the first person here, Alice, owns the second robot here, named Jerry, it's going to be pretty simple. You just need to write p1.robotOwn equals r2."}
{"text": " And this sets the attribute, the robot-owned attribute of p1 to r2. And then we can do the same thing for p2 as well. If you want to show that the second person, Becky, owns the first robot, Tom, you can just write p2.robot-owned equals r1."}
{"text": " And that way, p2's robot.own attribute will be r1. And once you have that in place, you'll be able to do stuff like this as well. Here, I just wrote p1.robot.own.introduceSelf() So basically, p1.robot.own will give us r2, because that's the robot p1 owns."}
{"text": " And so this line is the same as saying r2, the introduced self. So when you execute this line, this is going to print out, my name is Jerry, because that's the name of r2. And then we can do the same thing with p2 here, the second person."}
{"text": " So, once we write p2.robotown.introduceSelf, p2.robotown will give us r1, so this is the same as saying r1.introduceSelf, and of course, this line, once executed, will print out, my name is Tom, because that's the name of r1."}
{"text": " So that's how you can express the relationships between robots and person objects, but can we do something similar within the same class? So for example, what if you had these five robots, and each of them can be expressed as a robot object, and what if you wanted to show that, for example,"}
{"text": " These two robots are friends with each other, and these two robots are friends with each other, and so on. Or it could be something like, this robot is looking at this other robot, and this robot is looking at this robot, and so on. How can we show something like this?"}
{"text": " Well, it'll actually be pretty similar to what we saw earlier. So let's take a look at the Robot class here. So far, it's the same. It's exactly the same as what we had earlier. We have name, color, and weight as attributes, and then Robot, Constructor, and then the introduceCell function."}
{"text": " All you need to do on top of this is you just need to add an extra attribute called, let's say, lookingAt. So this is going to be the robot, this particular robot is currently looking at, and this is going to be a robot object, and so the type here is robot."}
{"text": " So, if you want to say, for example, that the first robot, Tom, is looking at the second robot, Jerry, you just need to set the lookingAt attribute of r1 to r2. You can do that just like that, by saying r1.lookingAt equals r2. And then, if you want to show also that r2 is also looking at r1, you can just write this,"}
{"text": " r2.lookingAt equals r1. And that sets the lookingAt attribute of r2 to r1, so that r2 is now looking at r1 as well. So this was a little bit silly example, you know, a bunch of robots just looking at each other, but you'll be able to use exactly the same idea to implement more realistic things too."}
{"text": " So for example, if you're trying to implement a Twitter-like system or an Instagram-like system, you want to be able to say, this robot is following this other robot, or this person is following this other person, and then this person is following this person, and so on. To show something like that, you can just change the name of this looking at attribute from looking at to following, and then pretty much do exactly the same thing as what we did earlier."}
{"text": " Okay, so that wraps up my introduction to classes and objects. If there's any related topic that you want me to cover in the future though, just let me know in the comment below. And special thanks to Brilliant.org for sponsoring this video. So in my next video in this series, I'm planning to cover the topic of linked lists. But actually, once you understood the concepts you learned in this video, you'll be able to start learning, you know, more advanced data structures like graphs and trees."}
{"text": " So if you want to jump ahead and start learning these concepts on your own, you might want to check out Brilliant. In their Computer Science Algorithms course, they have a section about graphs, and I think this would be perfect for someone who's just starting to learn data structures and algorithms."}
{"text": " Like I said in my previous videos, solving problems is a really good way to solidify the computer science knowledge you've gained passively by watching videos or reading something. I think Brilliant can be a good complement to this course because it gives you a good way to practice what you've learned through solving problems. So if you want to complement your passive learning with more active learning like solving problems, just go to brilliant.org slash csdojo."}
{"text": " This will let them know that you came from here, and you get 20% off their annual subscription through that link too. Okay, thanks as always for watching my videos, and thanks so much for being part of Dojo Gang. And, uh, I'll see you guys in the next video."}
{"text": " We are going to represent a doubly linked list. Logically we have discussed in previous video introduction of doubly linked list. Fine. So now we are going to create a doubly linked list having three nodes only and after that we are going to display the data like 7, 1 and 3. This is how we are going to display the data."}
{"text": " So first of all, you go through the video of introduction to doubly linked list. I'll provide you the link of that video in the side button. You can check out there. Now see how we can represent a node of a doubly linked list that we have already discussed in the previous video. So I'm going to write here that thing."}
{"text": " So this is how we are going to represent a node of a doubly linked list. Data type is a struct node. Three parts of this node are there. Data. One is next pointer. One is previous pointer. This pointer is going to store address of next node. And this previous pointer is going to store address of previous node. Right."}
{"text": " So now one head pointer is also there. We are going to maintain this pointer. We have this pointer when we are dealing with the program. So this pointer is what? Containing address of the first node. You can say it is a pointer to the first node. So this is how we are going to declare a pointer. This is name of the pointer. This is a pointer. That is why we are writing here asterisk and this is a pointer to node."}
{"text": " which day which address it is going to store address of this node fine so here you will write address of that variable whose address this pointer is going to store so now the type of this node is what struct node we have defined our own data type that is struct node see here directly you cannot write seven this will give an error why so because when you are writing this thing it means you have just declared you have just defined your own data type"}
{"text": " The memory is not been allotted yet. Fine. So you cannot directly write here. You cannot store any value here. First of all, we will declare a variable, either a variable of this struct node type or a pointer. Using that variable or that pointer, we can access the members of structure. So I hope you know the concept of structures, how we can use the structure in C language. Fine. Now, globally we declare this thing."}
{"text": " because if you globally declare this data type and this pointer then in any function you can use this head pointer and this data type fine because in this case we are going to declare two functions one is create and one is display. So globally out of the main function and out of all those functions I am going to declare this. Now I am going to define a function that is create."}
{"text": " So, now I am going to write down the code to create this linked list. See it is very much similar to the singly linked list code. In that case we have seen how to create a singly linked list. So, first of all we have to create a node to store this data to insert the data in the linked list. Initially we assume that this list is empty right. So, if list is empty then in head pointer you are going to store what 0."}
{"text": " So you can initialize this head pointer with 0. I am going to write down that thing also. So now first of all we are going to create this node dynamically. Dynamically we are going to assign the memory to this node. And how you can dynamically allocate the memory using malloc function. The malloc function syntax we have already discussed many times when we were discussing linked list concept. So how you will write down that thing."}
{"text": " the syntax says you will write that malloc keyword and here the size you want for this node the size you want how much size 4 for this 4 for this and 4 for this so here what we will write here we will write size of in bracket you will write the data type the data type is what struct node so now automatically how many bytes would be allocated"}
{"text": " 12 bytes should be allocated. And what malloc function will return? It will return a pointer to the first byte of that allocated block. Now, suppose this block has been allocated in the memory. How many bytes? 12 bytes and the 12 bytes are there in this one. Three parts are there of this node, this, this and this. And the address of first byte is 250. So the address of this block is 250. So that is why malloc is going to return this."}
{"text": " address so you can say it's going to return what a pointer to the first byte or you can say that void pointer and now you have to store this address into some another pointer obviously we are going to store this address into a pointer na we use a pointer variable so we are going to declare one another pointer variable suppose here I am declaring asterisk new node"}
{"text": " this is newly created node for this I am taking new node see if you don't declare globally then here within this create function you can also declare what you can write struct node asterisk new node so if you are using this pointer only within this function so better you declare this new node pointer locally not globally so now this will return a void pointer and this new node is what it is a pointer to node because type is struct node so you have to typecast this thing how to typecast this you will write what"}
{"text": " struct node asterisk right and whatever this malloc will return where you will we are going to store that thing in new node so here you will write what"}
{"text": " new node so this is how the memory dynamically the memory has been allocated to this new node. So here you can see this new node is a pointer that has been created and this pointer is going to store what whatever malloc will return that is 250 it is going to store 250 so it will point here now right."}
{"text": " Now, this has been created. Now, we ask from the user which data he wants to insert. Suppose, I have inserted 7. Using printf and scanf, we are going to take input from the user. So, how you will write? In scanf, what you will write? %d and we cannot directly access this data. How you can access this? Members of structure either using"}
{"text": " that variable of this type or a pointer. So we have declared here pointer. So now how you can access the part of this newly created node using this pointer. So here what you will write address of first of all the pointer name. Then this arrow symbol and which part you want to access data part. So data I want to access. See how you will draw this arrow symbol simply that hyphen and angular bracket. And if you don't write this thing another method is what you can also write something like this."}
{"text": " asterisk name of the pointer and then dot and which field you want to access here I want to access data so you can write down this thing here so suppose here I have entered 7 so here and here first of all we will store what null so how you will store null here simply you will write what new node you want to access this part so name of this pointer is what we have taken previous"}
{"text": " previous is equal to 0 and new no next is also 0."}
{"text": " so now this is done now we want to insert this newly created node in the linked list at starting head is equal to null so here you can write within this function you can also write head is equal to zero see this is the case head is equal to null so how you can insert this thing here simply you have to update this fine in head pointer what you will store the address of this"}
{"text": " node address is 250 so here you will store 250 so now head is pointing here right and in the next node also 0 there is no next node there is no previous node that is also 0 so simply what you will write here in head we are going to store head is equal to from where you can get 250 see this pointer is also containing 250 because this is pointed to this node so in head you can write new node"}
{"text": " right if head is equal to 0 in that case now we have one node in the linked list now I want to insert another node the second node in that case head is not null now head is containing 250 so in that case how you will insert so in else part what you will write"}
{"text": " So now see in the link list I have only one node I have only one node inserted now I want to insert another node. So suppose I have created one another node by running this code again. Again the memory has been allocated dynamically and suppose the address is 200 this 200 would be passed here the new node. So here this new node pointer is containing the value 200. It means it is now pointing to this node."}
{"text": " And the data we have entered that is 1 and the previous pointer is containing null and next pointer is also containing null. Now see."}
{"text": " if head is equal to is equal to null but head is not null now control will go into else part now how we are going to insert this node here now which link you have to update see here in doubly linked list we are going we you have to update two links fine see now if you want to insert this after this one so this node is going to contain address of this node because this would be the next node so that is this 200 200 would be here so here rather than 0 we will store 200"}
{"text": " fine by doing this you can establish this link but this is not done now this also you have to update this thing also because every node is going to contain address of its previous node also so now here in this part which you are going to update this thing and what should be there that is 100 address of the previous node now we have established this link also"}
{"text": " So now if I ask how you can access this part so simply you will say my pointer to this node is this head so simply what we can write head of next next this pointer is next head of next is equal to from where you will get this 200 from this new node because new node is containing address 200 is equal to new node."}
{"text": " So one link has been updated. Now I'll ask how to update this link. How you will access this part of this node. Then you will say ma'am we have appointed to this node that is new node. So we can access this using new node. So new node and the name of this part is previous. Name of previous is equal to from where you will get this hundred address of previous node and in head we have hundred. So here we can store head."}
{"text": " and this is done now now you will say that this is done now fine okay fine we have inserted this thing now the problem comes when i want to insert a third node now see now i have created another node running by running this code again this node we have inserted this two here the data here and both the previous and next pointer is containing null now if head is equal to null but head is 100 so head is not null now we are going to"}
{"text": " do this else part now we are going to run this code now see what happens here first line is head of next is equal to new node head head is containing 100 using this we can access this node head next means this one so here we will store new node so what is the value in new node see we have created this new this node so this address is would be contained in this new node pointer so here this new node is now containing 300"}
{"text": " It means it is pointing to here. So now according to this logic the new node this 300 would be stored in head next head of next that is here. So here 300. It means what this pointer is now pointing to this node 300. It means this link has been broken."}
{"text": " but that should not be a case. Next line also new node previous. New node previous is here and is equal to head. Head means 100. So it is pointing to here. So now this is also pointing to here. So that is not correct. So this logic is not correct. Now what you will do here we will take another"}
{"text": " pointer to node you can say temp. This logic we have already discussed in the singly linked list also. So now within this function we can here within this function we can declare another pointer that is temp you can say. Now how we are using this temp see now. Now temp is another pointer"}
{"text": " now what you will do we cannot move this head we will move this temp first of all point to this then this then this then this like this fine so now what you will do when you insert the first node if head null then you will insert this node in that case head is also pointing here and you will set what temp will also point here you will write something like this so here what you can write head is equal to"}
{"text": " temp is equal to new node. So both head and this temp is pointing to this now this first pointer in the node. So now what you will write in else part. So now I am taking a case that we have inserted one node and I am going to insert second node after that we will insert the third node right. So I have created this node I have inserted the data 1 here we have 0 0 and new node is a pointer that is pointing to this node and containing the address of this node."}
{"text": " fine so now what you will write in else part how you will update this thing and this thing how you can access this part either using head or using temp so here I am accessing this using temp so I can write temp of next is equal to address of this from where I can get this from new node is equal to new node so now this is containing 200 means"}
{"text": " we have established one link so now you have to establish this thing also how you can access this thing using new node previous is equal to you will store here what the address of previous one right so now I will write here address of previous one is in temp so I will write here temp"}
{"text": " we are not going to write here head because we have discussed if you write here head what problem would be there. So, I will write here temp. So, this has been said that is 100. So, it is going to point now here. One more thing what you will do now we are going to move this temp right. So, now, temp is equal"}
{"text": " temp is pointing to this node now temp would be pointing to this node that is we are going to store 200 so from where you can get 200 from this new node so temp is equal to new node and this is the closing of else part so now temp is containing 200 and temp is now pointing to"}
{"text": " this node now both new node and temp is pointing to this node we have successfully inserted the second node now see if you want to insert the third node we have created this node right we have inserted the data here we have null and null head is equal to zero head is not equal to zero so we are going to enter into else part now see in else part what we have written temp next here what you have to do you have to update this thing and this thing"}
{"text": " right this is going to contain address of next node and this pointer is going to contain address of previous node we are going to update two links so now how we can access this thing see here in this case now new node is pointing to this node because we have created new node so here in this new node pointer this 300 would be stored now this new node is not pointing here after creating third node it is pointing to here now see how we can access this part"}
{"text": " using a pointer obviously and we have we have a pointer temp pointing to this node so we don't have any problem that is why we are taking another pointer temp temp next temp is 200 temp next is 0 this what you will store here new node new node is containing 300 so here you will store 300 it means it is going to point here 300 is address of next"}
{"text": " node one link has been established now second this how you can access this part using new node previous new node previous is equal to what value will store here address of previous node that is 200 from where we can get 200 temp is containing 200 so is equal to temp now here 200 so it means it is going to point here and again one more thing temp is equal to new node now temp is equal to new node that is 300 so now temp is pointing to"}
{"text": " here right that is why I am taking this stamp. Again if you insert fourth node no problem in that case new node would be pointing there when you will create the fourth node and we have the address of this previous node. So, we can easily update the links."}
{"text": " right so that is why I am taking this temp now if you want to run I want to write a program something like this after inserting first node it will ask do you want to continue if you will press one then you can insert the second node if you again press one then you can insert third node so you can insert as much as many nodes as you want so now for that thing you can write after this else part you can write same this thing we have discussed in singly linked list"}
{"text": " See you can write the choice of the user and here you can write type 0 or 1. If the user press 0, it means he don't want to continue. If user press 1, it means he wants to continue, right? So now for taking the input from the user, you are going to declare one another variable that is choice. So we can declare this choice variable within this function somewhere here. Suppose I'm taking here int choice, right?"}
{"text": " and in starting I am taking choice is equal to 1 so when the user enter 1 the choice is 1 it means new node should be created again again and again so that is why you are going to write this code this code into a loop fine so here before this line before this line new node is equal to struck node here you will write what while choice"}
{"text": " it means when choice is equal to zero when you will pass zero here this code will not be executed so that is why"}
{"text": " Here you can start while loop and here you can close this while loop. And if you press 0 it means the new node would not be created. If you press 1 it means here 1 would be passed. So this code would be run again. So this is how you can create as many nodes as you want in a linked list. Now suppose after inserting 7, 1 and 3 again it will ask do you want to continue and you have pressed 0."}
{"text": " It means this code would not run again. So after this you can call what display function and this list should be printed that is 7 1 and 2. So how the display function will work that function is same as singly linked list function."}
{"text": " The coding would be exactly same that we have discussed in singly linked list fine. So I am just going to write down that code here just for a brush up. You can write down this code. You can pause the video and you can note this code. So I'm going to rub this now. So now this is the code for the display function for displaying the content of this list. This code is same exactly same as the code of singly linked list. We have discussed this code."}
{"text": " in that case in detail so i'm not going to discuss it in detail here right this is the same we have discussed one we have taken one temp another pointer we are going to start here first of all temp is going to point from here temp is equal to head so here and one by one we are going to print the data and then we will move temp see we are going to print the data then we will move temp is equal to temp next then print the data again we will move until"}
{"text": " temp not equal to 0. It means when temp becomes 0 then you are going to stop right and in main function you can call the create function also and this display function also and see this thing we have declared globally outside of main function and outside of both the create and display function."}
{"text": " so in next video i'll discuss how to insert a node in singly linked list at beginning also at any position also and at end also and after that how to delete data how to delete node from a doubly linked list so i'll see you in the next video till then bye take care"}
{"text": " Hi guys, welcome back. In this video we will discuss how to construct a binary tree from preorder and in-order traversal. So see this one is the preorder traversal of a tree and this one is in-order traversal of a binary tree and you are supposed to construct a binary tree from these traversals. See as we all know preorder is root then left and then"}
{"text": " right fine and the in order traversal is left then root and then right."}
{"text": " Now, first of all when you see you are supposed to construct a tree or you can say binary tree your first step is to find out the root of that tree ok. Now, how you can find out root of the tree from these traversals fine from in order traversal you cannot find root because"}
{"text": " Root is in the middle of left and right part. We can't say which one is root. Kaha pe uska middle hoga, kitne elements to the left of that root and how many elements are to the right of that root. Fine? So you can find out root of the element from, root of the tree from this preorder traversal. Because in preorder traversal, root is always first. Firstly traversed. So in preorder traversal, we will scan this data from this left to right. Now first is"}
{"text": " Now 1 would be root because starting main apne preorder traversal mein kya hai? Root will always be traversed. Now the 1 would be root of our binary tree. Fine. Now next step is to find out its left subtree and right subtree."}
{"text": " Now how you will find out the element of left subtree and the element of right subtree from this inorder traversal. See from this inorder traversal find out where is this one. This one. It is our one and this one is our"}
{"text": " root now see to the left of root left sub tree is there and to the right of root that right part or you can say the right sub tree would be there. So, one all the elements to the left of this one would be the left sub tree and all the elements to the right would form the right sub tree fine. So, in the left to the left of this sub tree how many elements and which elements are there"}
{"text": " 8, 4, 10, 9, 11, 2 and 5. These are to the left of this and to the right 6, 3 and 7, 6, 3 and 7. These elements will form the right subtree."}
{"text": " Fine, now see, now first of all, you can construct this left subtree or you can construct the right subtree. Fine, we'll go to the left part. Now, out of these elements, which should be the root of this left subtree? See, our tree is complete till this level. We have only find this one as a root. Now, from these elements, find out which one would be the root of this left subtree. Now, how this is to be find out?"}
{"text": " from this preorder traversal fine. The rule is out of these elements fine see out of these elements the element which is coming first in this preorder traversal when you will scan this traversal from left to right"}
{"text": " That first element would be the root of this left subtree. Find out, out of these elements which is coming first. When you will go from here to here, one is already there. Now second, see out of these elements we found this two. Now two would be root of this."}
{"text": " left sub tree now out of these elements which are the left of this two and which are which elements are right of this two how you will find out left and right left and right find out we will go to the in order traversal find out the location of two here we have this"}
{"text": " Now, this one is our root. All the elements to the left would be the left sub-tree and all the elements to the right of this two would be right sub-tree. Out of these elements, fine. So, out of these elements, two is root and all the elements to the left. Kaun kaunch elements hain? To the left of this two, we have eight, four, ten, nine and eleven."}
{"text": " These elements would be to the left of this 2 and to the right of this 2 we have only this 5 only 1. Fine only 5 we have. Now our problem is divided into you know that sub problem. Now we have these elements only. Now out of these elements find out which would be the root of this left subtree left subtree of this 2."}
{"text": " 8, 4, 10, 9, 11. And to find out the root, we will go to the preorder traversal. Out of these elements, the element which is coming first when you scan this preorder from left to right, that would be the root of this left circle. Out of 8, 4, 10, 9, 11, which element is coming first when you will go from left to right? 4 is coming first. Out of 8, 4, 10, 9, 11, 4 is coming first. Now, 4 would be"}
{"text": " root of this left subtree. Now left and right of this 4 would be which elements would be to the left of this 4 and which elements are to the right of this 4. Yeh find out karne ke liye we will go to the inorder traversal. Now find out the location of 4. Here we have this 4. Fine. 4 is our root."}
{"text": " root ke left mein kya hoga left sub tree and root ke right mein kya hoga jitne elements honge that will form a right sub tree. Now to the left of 4 we have 8 out of these elements only. We are not going to check 6, 3, 7 out of these elements only. 4 ke left mein apne paas kya hai 8. Now 8 would be the left of this 4 and 10, 9, 11. 10, 9, 11 are 10, 9, 11. These are to the"}
{"text": " right of this 4 fine. Now here we have only one element that's fine. Now construct the subtree from 10 9 and 11 fine. Now out of these elements which would be the root and to find out the root we will go to the preorder traversal. Now find out which elements from these elements from 10 9 and 11 which element is coming first when you go from here to here."}
{"text": " 10, 9, 11. I guess 9. 10 or 11 are coming after this. 9. So 9 would be root. Fine. Now this out of 10 and 11 which would be to the left of 9 and which would be to the right of this 9. We will find the left and right part when you will go to this inorder traversal. Now locate this 9 in this inorder traversal. Here we have this 9."}
{"text": " And 10 is to the left of 9 and 11 is to the right of 9. So left of 9, left of this root would be the left part. So 10 would be to the left of 9 and 11 would be to the right of 9."}
{"text": " So this is our left subtree. We are done with our left subtree. Now come to the right subtree. Right subtree we have only 6, 3 and 7. 3 elements. Which would be the root of this right subtree? Find out. Out of 6, 3 and 7 which is coming first? When you traverse this preorder from this, scan this preorder traversal from left to right. 6, 3 and 7. 3. 3 is coming first. 6 and 7 are coming after this 3. So 3 would be?"}
{"text": " root now out of 6 and 7 which element would be to the left of this and which element to the right of this 3 to find out this we will go to the in order traversal now locate this 3 in this in order traversal here we have this 3 and 3 is our root and 6 is to the left of 3 and 7 is to the right of 3 so 6 would be to the left part of this 3 and 7 would be"}
{"text": " right part of this tree fine. So, this is our binary tree and you can construct this tree from this preorder and this inorder traversal. If you want to verify it then you can find out preorder and inorder traversal of this tree and if preorder and inorder are same as given in the question then you can say our trees you have formed a right binary tree."}
{"text": " So, I'll see you in the next video, till then bye bye, take care."}
{"text": " of this sorting algorithm. See first of all we have discussed many sorting algorithms all those sorting algorithms are comparison sort."}
{"text": " fine bubble selection, merge, quick heap all, all are comparison sorts. We are going to compare the values given and after comparing the values either we are going to swap the values or we are not going to swap the values, fine. But this sorting algorithm is not a comparison sort. We are not going to compare the values. Then how we are going to sort? See we are going to sort the values according to the according to the keys, the key value"}
{"text": " fine or you can say the main funda in this sorting algorithm is you are going to count see as the name suggest counting. So, you are going to count the number of elements having distinct key values."}
{"text": " or you can say different key values. Now, what is this key value? How we are going to count the number of elements? How we are going to sort? We are going to see this with the help of an example. So, see let us suppose you are given this array fine and we are going to sort this array."}
{"text": " See although you can apply that any comparison sort merge sort quick sort and the time complexity for that the best time complexity would be n log n you cannot get better than n log n. But how we can sort in linear time you can say order of n time is it possible sometimes it is possible see sometimes we are going to see the time complexity of this counting sort and how we are going to sort this."}
{"text": " So see here in this array 0 is 1 2 3 4 times 1 is also repeated 2 is also repeated I guess 5 is also repeated something like this. So here total number of elements are 17 fine and all the elements are in the range of see from 0 to"}
{"text": " 0 to see minimum element is 0 maximum element find out the maximum element in this array maximum element is I guess 7. So, range is from 0 to 7 fine. So, you can say here k value is 7. So, here you can say we have an array having k different elements right."}
{"text": " and may be in this array values can be duplicate values can be there. So, how to sort this array? So, here the situation is first case is first case is suppose the array name is a all the elements in the array would be in the range of 0 to k fine or second case may be this"}
{"text": " Elements belongs to any integer may be 0, negative, positive, very large integer, very small integer something like this with k different values."}
{"text": " So, we are going to check this case. So, here for this case we are going to apply another sorting algorithm because here values can be negative. So, this counting sort we will discuss that will not work on the negative values fine. So, condition is here the array should contain no negative values and the values should be in the range of 0 to"}
{"text": " Somewhere in some numericals you are given this k value in the question only, but somewhere it is not given. So, you can find out k value just you just you check out the maximum element in this maximum element is 7 fine. So, k value would be 7."}
{"text": " right and range would be from 0 to k. So, first of all we will discuss this case range would be from 0 to k with the help of an example then we are also going to see some another variants of this counting sort ok. So, let us take this example this is the array the name of the array is a total number of elements in this array is 17 index is from 0 to 16 fine and k value is what"}
{"text": " The range you can check out the minimum is 0, the maximum element is 9, fine. So, range is from 0 to 9 or you can say the k value is 9, fine. Now, the first step is what?"}
{"text": " We are going to count, see I have told you counting the elements having distinct key values, key value means this, this 2, this is the key value, 1 this is the key value, fine. How many times this 2 is there in this array, you are going to count that thing, 1, 2, 3, 4, fine. How many times 1 is there in this array, 1, 2 and 3, 3 times, like this you are going to count the elements, fine."}
{"text": " And after counting obviously you are going to store those elements in somewhere. So for storing that count we are going to take another array and I am going to take the name of the array as count. Right? Now the size of this count array would be this k plus 1. So 9 is there. See range is from 0 to 9. So 10 elements would be there."}
{"text": " range this size would be k plus 1 or you can say range plus 1. So, let us suppose this array is there another array. So, index would be from 0 to 9 same as the range of this array."}
{"text": " Now, we are going to count the frequency or counting the elements having distinct key values c. So, c what should be there in this count array? The key value is 2, this 2 is how many times 1, 2, 3, 4."}
{"text": " we should have 4 see 1 the key value is 1 1 is how many times 1 2 and 3 so here 1 is there and this is how many times 3 times and next 0 0 is how many times 1 2 3 3 like this you will you you are going to fill this array but now we will see how we are going to fill this array actually how we are going to write down 4 here how we are going to count"}
{"text": " the number of elements fine how we are going to write down the code see. First of all we are going to take one variable i."}
{"text": " fine here the value is 2 right so the value is 2 in this in this count array go to the index 2 this is the index 2 and at starting the value in this count array would be 0 you are going to initialize this count array would be 0 all the values right fine. Now see this 2 go to the index 2 and increment this value now it becomes 1 you are going"}
{"text": " Now i would be at this place. You are going to increment this i. Now here value is 1. Now go to this index 1 and increment this value. This is now 1. Now again increment i. Value is 1. Again go to the index 1 and increment this value. We have 1. So after incrementing the value becomes 2. Now next is 0."}
{"text": " Go to the 0th index, increment this value 1. Now next is 2. Go to the index 2, increment this value, that is 2. Next is 5. Go to the index 5, increment this value. Next is 4. Go to the 4th index, increment this value. Next is 0. Go to 0th index and increment this value 2. Next is 2. Fine. Go to index 2 and increment this value, that is 3. Next is 8."}
{"text": " Value is 8. Fine. So, go to the index 8, increment this value. Next is 7. Index 7, increment this value. Next is also 7. Go to index 7, increment this value again. Next is 9. Go to index 9, increment this value. Next is 2. Go to index 2, increment this value. That is 4. Next is 0. Go to this 0th index, increment this value. 1. Go to index 1, increment this value."}
{"text": " then last is 9 go to the index 9 increment this value fine this is how we are going to fill this count array you can check out this 9 is how many times 1 and 2 this 8 is how many times only 1 fine how we are going to write down the code for this see we are going to take one for loop we are going to take one variable i, i would be started from 0"}
{"text": " and i would move till here less than n or you can say less than equal to n minus 1 n is 17 and i plus plus now how to fill this count array you are going to write down code for that you are going to increment this value count array value fine see first of all what you have done you have just checked this value that is 2 and you have gone to the index 2 and then increment this value"}
{"text": " fine so how we are going to access this value array name is a and i this is how we are going to access the value of an array i hope you know fine now you find 2 now you go to this index index 2 and name is count fine index is same not 2 and 2 so here you will write"}
{"text": " count because this the value of this a of i is just an index of this array so count brackets a and i and now we will do plus plus so here you can write plus plus."}
{"text": " or here you can write plus plus post increment or pre increment in this case both will be same. This is what you have done at starting only when you are going to take this array you are going to initialize this array with zeros for i is equal to 0, i less than equal to k, k and count of i is equal to 0. So, now next step is now you have you have"}
{"text": " the elements, the frequency of the elements, fine. But now you are supposed to find out the actual position of these elements in the sorted array. See, after sorting the array would be something like this. See, after sorting, after sorting array would be something like this, fine. This is unsorted array, this is sorted array, right. So, this 0 would be from 0 to"}
{"text": " The index would be from 0 to 2, fine. First 3 position for 0, then position for 1 is 3, 4, 5. These position 3 to 5. Position for this 2 is 6, 7, 8, 9 from index 6 to 9."}
{"text": " This is 10, 11, 12, 13, 14, 15, and 16. For 9th, the position would be 15 and 16. Now, how you will come to know that the position of 1 is from 3 to 4, from index 3 to 4? How you will come to know that the position for the 7 is? Because from here you can say that"}
{"text": " 7 or 2 times in this array, but what is the position in this sorted array at index 12 and 13. So, now, we are going to update this count array fine such that this count array contains the actual position of the elements fine. See how we are going to do that? We are going to update this array I am going to update this count array."}
{"text": " this is same count array, we are going to update in the same array, fine. See, first value would be as it is, the value at index 0, that would be as it is. We are going to start a loop from here only, from the first index, fine. After these three 0s, after three 0s, for next three, for next three positions, one would be there."}
{"text": " So, the position of 1 would be, see after these 3 zeros, so 3 plus 3 that is 6, up to 6, see index is 5, but position is 6, 1, 2, 3, 4, 5, 6, right. So, here we are going to, we are going to take the count now, that is why we are going to take the 6. How we are going to find out this position 5, I am going to tell you."}
{"text": " later fine. Now, after 1 next 4 would be 2. So, position of this 2 would be 6 plus 4 that is 10 till 10 here. See index is 9, but position is 10 this is how we are going to update this array."}
{"text": " So, now, next is this for this 3 10 plus 0 that is 10 only 10 plus this 1 this next element that is 11 10 plus 1 is 12 position for 6 is 12 plus 0 that is 12 for 7 for 7 that would be 12 plus 2 that is 14 for 8 14 plus 1 15 15 plus 2."}
{"text": " For 9 it is 17. So this is how now the updated count array. So now this array is going to reflect the actual position of this element in the sorted array. Now I am going to write down the code. Fine. See how to update this count array. See. One for loop would be there. We are going to start the for loop from 1. So i is equal to 1."}
{"text": " i less than equal to k value k is 9 so i less than equal to 9 and i plus plus now how we are going to update this see we have done what we have just taken this 3 value as it is then 3 plus next fine 6 then 6 plus next 10 like this we have done so how we are going to do this see"}
{"text": " this count of i would be count of i plus count of i minus 1. See i we have started from 1 that is why count 1 here count 1 this count 1 would be 3 plus 3 that is 6 means count of i plus previous value i minus 1 sorry i minus 1."}
{"text": " So this is how we are going to update this array. Now we are going to build the output array. How we are going to build this array, this output array. See, we have taken one another array. The name is suppose B. The size is same as the original array. Having element 17, total element 17. How we are going to fill this array? This array would be sorted array. See this is our original array. We are going to scan this array from right to left. From here."}
{"text": " we are going to take one variable why I am going to start from here I am going to tell you that thing also see first of all suppose I am going to start from here the value is 9 right key value is 9 so what you have to do in count in count array you just you just go see this is our updated count array we are going to see this array now we are not going to see this one so see just go to the index 9 this is index 9"}
{"text": " Value is 9, go to index 9 in count array. But we cannot store 9 at 17 because we don't have 17. This is the count but we are actually working on the index. So first of all we are going to decrement this by 1, 17 minus 1 that is 16 and in the output array go to the index 16 and store this 9. This is the actual place for this 9."}
{"text": " Now decrement i, now i is at this place, find out the value at this, that is 1. Now go to the index 1 in this counter, index 1 value is 6, but we are not going to store 1 here. Why so? Because this is count value, but we are going to store at index 5."}
{"text": " So first of all we are going to decrement this by 1 that is 5 and now we are going to store at 5 here we got 1. Why we have started from here? See you can start from here you will get sorted array but I am going to start from here just to maintain the stability of this counting sort."}
{"text": " Now what is that stability of sort? See let us suppose in this case, this is 9 and this is 9. Both are same 9 and 9. The position of this is 12, index is 12 and index is 16. So this 9 is before this 9. The position is 12."}
{"text": " before this 9. So in sorted array this 9 should be before this 9 only. The position of this 9 should be before this 9. That is the stability that is the stable sort. Although we can write in the sorted array you can write this 9 here and this 9 at this place."}
{"text": " but the value is same obviously the array would be sorted but this will not maintain the stability of the sorting algorithm fine if you start from here only that is why to maintain just the stability I am going to start from here now decrement i now here value is 0 go to the index 0 value is 3 first decrement this value that is 2 now in this output array at index 2 store 0"}
{"text": " Next decrement i value is 2 go to the index 2 value is 10 but first of all decrement this that is 9 and now at 9th index store what 2."}
{"text": " now again decrement value is 9 now see again go to the index 9 at index 9 updated value is 16 but first of all we are going to decrement this that is 15 and at 15th index in output array you are going to store this 9 so see as you can see here"}
{"text": " This 9 is at place 15 and this 9 is at 16 and 15 is before 16 or you can say less than 16. So this is how we are going to maintain the stability. Fine. Now decrement again i 7. Now go to the index 7. Here is 7 in the updated count sort value is 14. First of all decrement this that is 13 and at the index 13 now store 7."}
{"text": " again decrement i value we have again 7 go to the index 7 value is 13 first of all decrement this that is 12 now at index 12 store 7 decrement this that is 8 go to the index 8 value is 15 decrement this that is 14 at 14th store 8."}
{"text": " decrement this so the value is 2 now go to the index 2 in this count array at index 2 value is 9 first decrement this value that is 8 at 8th index now we are going to store this value 2 decrement this i value now 0 go to the index 0 value is 2 decrement this 1 we are going to store 0 here."}
{"text": " Decrement this one, value is 4, go to the index 4, here the value is 11, decrement this first of all 10, at 10th index we are going to store 4. Now decrement this, here the element is 5, key value is 5, go to the index 5, at index 5 in the count array, here the value is number is 12, decrement this first of all that is 11, at 11 we are going to store now 5."}
{"text": " fine again decrement i value now here the key value is 2 go to the index 2 here the value is 8 decrement this first of all 7 now at 7 we are going to store 2 now go to this place value is 0 go to the index 0 here we have 1 decrement this that is 0 at this at the 0th index we are going to store 0."}
{"text": " Again decrement i value, here the key value is 1, go to the index 1, value is 5, decrement this first of all 4, at 4 we are going to store 1. Again decrement 1, go to this index 1, value is 4, decrement this that is 3, at third we are going to store 1."}
{"text": " now decrement this 2 now at index 2 value is 7 see updated value is 7 we are going to decrement this that is 6 at 6 we are going to place this 2 now fine and we are going to stop because we have reached to 0th index now you can see this is the sorted array"}
{"text": " We have taken another array that is B. Now simply what you will do, you simply copy the content of this array, the element of this array to this array with a for loop. Now how to write down this thing into code? How to build this array? See, we have just"}
{"text": " this is one for loop for this, this is for loop for this updated count and now this for loop is for building this output array, fine. We have started our for loop from here, fine. So, i value would be n minus 1 till i greater than equal to 0 and i minus minus, fine. Now, within this for loop what you will write?"}
{"text": " First of all what we have done we are going to take this value and you are going to place this value in the sorted array after finding proper position using this count array fine. So take this value this value how to take this value array name is a and a of i see"}
{"text": " This is how we are going to access this element. Now where to put this element? To this side what you will write? We are going to put this element in array B. But first of all you have to find out the proper index in this B. For that index what you will do? You will use count array. Fine? And in count array also for finding this index."}
{"text": " you will use this value right see the value is 9 so same we are going to index 9 fine see so this is how we are going to write count a of i."}
{"text": " See let us suppose a of i is 9, so count 9, count of 9, this index. Now what we have done, decrement this index first of all."}
{"text": " So, we will decrement this minus minus see first we will decrement then we are going to store so pre decrement. So, after decrementing the value is what we have got 16 fine. Now, this 16 is the index in this array B where we are going to store this value fine. So, this is the index and name is array B."}
{"text": " So, in b array this is the index you are going to calculate where you are going to store the value a of i fine. This is how you are going to build this array. So, now, at last one another for loop would be there just to copy the value of this array into the original array. So, what you can write after this for loop for i is equal to 0 to i is equal to less than n or less than equal to n minus 1."}
{"text": " I plus plus just copy the content here, array name is A, we are going to copy the content of B into A, this is how we are going to code this thing, fine. This the logic, this logic, these 4, 4 loops you are going to write in a function that is you can take count sort, the name would be maybe count"}
{"text": " so in count sort you can pass array or you can say the number of elements and sometimes k value would also be passed it is given then you can pass the k value fine or if you will not pass the k value here you can calculate within this function you can calculate the k value just find out the maximum element from the given array that could be the k value fine and just take"}
{"text": " initialize a array count I guess you can take this one thus sorry the size would be k plus 1 something like this. Take another array that is b and this b would be same as"}
{"text": " the size of original array. If n elements then b of n something like this. So, I guess you can write down this count sort initialize or declare this count array or b array something like this. This is the main logic these 4 loops and just call this count sort function into main function. See now what is the time complexity for this count sort?"}
{"text": " time complexity would be what? See time complexity is what just find out the calculations for the 4 loops given in the program. How many 4 loops? 1, 2, 3, 4. How many times the statements written within the 4 loops has been executed? How many times? See this 4 loop this statement has been executed for n times fine n times plus this 4 loop k times"}
{"text": " this for loop also n times and this for loop also from 0 to n means n times. So, maybe something like this 3 n plus k or you can say order of n plus k this would be the time complexity n plus k where k is given the range n is number of elements in the array."}
{"text": " So if k is suppose a constant you can say so you can neglect this k and you can say order of n. In linear time you can sort the elements. One drawback of this count sort algorithm can be say this k value should be feasible."}
{"text": " What is that mean? Let us suppose you are taking an array A and having 100 elements in the array. Here we have taken 17 only and in that array we have 100 elements and let us suppose k value is 10000. Now what will happen? You are going to create"}
{"text": " count array and the size of this count array would be how much from 0 to 10,000. In these locations only 100 elements would be there only 100 elements. So, many many places in this count sort would be 0 0 0 0 something like this fine. So, this should not be a case in this case this applying of this count sort is not feasible."}
{"text": " So, the upper bound, the upper bound for this k should be, this k should be order of n, n means number of elements in the array."}
{"text": " upper limit for this k would be number of elements in the, number of elements is 100, then k can be 100. It's not like it can be 100, it can be 2n, it can be 5n, it can be 6n, something like this, but it cannot be approximately n square."}
{"text": " So, this is the bound for this k, this k should be order of n and second topic is this count sort will not work for negative values and floating point values. You can modify this count sort for negative values after modification it can work, maybe you can apply some normalization methods."}
{"text": " minus negative values are there. So how you can normalize this, how you can apply, how you can modify this count."}
{"text": " just find out this minus value is 5. So, just add this 5 to all the values minus 5 plus 5 0 plus 5 6 plus 5 5 plus 5 11 plus 5 14 plus 5 is 6 plus 5 is 5 and here we have 0. Now, this is the array the range would be here is see from 0 to 14 you can say."}
{"text": " fine and again after sorting you can again decrement this you can again do minus 5 from the result. So this is how you can normalize the negative values and you can apply this count sort but this logic directly cannot be applied on negative values and floating point values."}
{"text": " Plus one more drawback of this count sort is what? It cannot be applied if the values are different in any range. There is no proper or specific range. See the values. Different values are there in any range."}
{"text": " So we cannot apply count sort on this algorithm it is better to apply now radix sort for this in such kind of example. Radix sort also use count sort but in that case we apply that radix sort in digits on digits first in this then this then this and then on this."}
{"text": " So, if you apply on the digits then you can say k value would always be from 0 to 9 because these values would be from 0 to 9. Each digit can be either 0, 1, 2 up to 9. So, k values would be 0 to 9."}
{"text": " So how we can apply this count sort in the radix sort, we'll discuss in the next video as well as I'll write down a piece of code for this that radix sort algorithm. Fine, so I'll see you in the next video till then bye bye take care."}
{"text": " All right, good afternoon, welcome back. Oh, that's not on, that would be a thing."}
{"text": " There we go. All right, so Lab 4 grades are back. So there's no feedback on it, so I'll upload to your repository the actual breakdown of the marks. I've already posted what TAs graded what part. So Lab 4 stuff I'll upload when I get back on the train after this lecture."}
{"text": " So lab five going ish, going okay. I added more test cases to lab five. You guys are oddly quiet. I don't know if it means you haven't started yet, which isn't good. Yeah?"}
{"text": " You know what I mean? Because the instructions on the document, I don't know if it was on purpose. It was pretty short, vague. Yeah, because you're meant to read it a little bit. Because the lab, you're only writing like 100 lines of code if that."}
{"text": " So yeah, mostly it's reading. I can add a bit, just ask questions if you have more. I think I answered the same thing. It's like, you don't need that many functions to actually do this lab. So you can ask, but yeah, you can ask, I'll add more context to it. But yeah, part of it was reading it, but I can add more context if you want. I'm a very spoiled software guy. I like doc strings and like very clearly"}
{"text": " Okay, all right, well, I'll do that after, so. Yeah, all right, so today, page replacement, so the fun stuff."}
{"text": " So we've kind of explored disk. We've explored memory. We've explored CPUs and know that each of them kind of have its own cache. What we've been talking about so far, fastest speed memory on your computer are the registers, which are on the CPU. They're going to be the fastest things. But there's always this capacity speed trade-off. And also, the speed trade-off is typically also a price trade-off."}
{"text": " So you have a few registers. They're really, really fast, but there's not very many of them. Maybe there's only 64, 32 even, maybe even 16 on some systems."}
{"text": " Then below that, there is RAM actually on your CPU die itself that acts as a cache for the memory. And typically, this will be a bit bigger. It'll be like in the megabyte size. Some of the big ones now have like 128 megabyte L3 cache or whatever."}
{"text": " So that's as quick as you can get on your CPU, but capacity is bigger, but it's going to be slower, and there's different levels of cache. Each are smaller and less capacity than the other ones."}
{"text": " So below that is memory, so that's RAM, your random access memory, all of your volatile memory that gets wiped whenever you reboot your computer. That's pretty fast, the capacity is pretty good, and it's not that expensive, and that's typically in the gigabyte ranges, so like 64 gigabytes of memory is not typically uncommon now."}
{"text": " And then below that, there's your NVMe, so that's starting to get into the disk drives, that's what we talked about a few lectures ago. So the fastest version of that is called NVMe, so that's non-volatile memory. So it uses some principles of memory, but whenever you power down your machine and power it back up, all your files are still there, so that's the non-volatile part of it."}
{"text": " Then below that are SSDs, or solid-state disks, which are going to be higher capacity and cheaper, but also a lot slower. And then below that, there's hard disk drives, which many of you have never seen before. Those are the mechanical drives that go around. Sometimes people call them spinning rust, because they like making fun of them. And then below this, you'll see tape drives. I guarantee none of you have ever seen tape drives. Wait, how many of you have ever saw a VHS tape?"}
{"text": " We got a few VHSers. Oh, we got excited. Is that like nostalgic now? OK, cool. So the tape technology, like it writes stuff directly on tape, well, that actually applies to computers too. And they can actually store, if you go super crazy with it, tapes can store terabytes and terabytes of information. And they are dirt cheap, but they are also dirt slow. But that is something like Google"}
{"text": " And IBM and all those companies that store massive amounts of archival data that will never be written again or that they will use very, very infrequently are actually written to tape drives, kind of like a VHS tape. But they will actually store terabytes of information. But they're really, really slow because,"}
{"text": " If you actually, you can look at YouTube and see some of these videos. So there's actual physical tapes. And if you want to retrieve information, you get to see the machine go physically grab a tape, put it in the machine, and then read it really, really slow. So that's actually used, but no one in their same mind is going to use it. Yep. Yeah, so floppy drives are like magnetic, but their capacity is really, really bad. The floppy drives are like,"}
{"text": " 1.4 megabytes. So no one's ever going to really use those. And the actual floppy disks that actually flop, I forget how big those are. But those are even before my time. But yeah, they're just old. But it's the same principle. It's like magnetic disk storage kind of."}
{"text": " OK, so part of this diagram for all the memory, if you are properly using the memory hierarchies, you want to create this fun little illusion where each level pretends to be as fast as the speed above it, but have the capacity of the layer below it. So if you're using the disk, like non-volatile memory, like a really fast SSD drive, ideally, you want it to be as fast as memory, but also have its own capacity."}
{"text": " and maybe even a higher capacity if there's even a slower disk on the machine that is bigger. So we can use this. Today we'll be talking about bridging this gap between persistent storage and your actual physical RAM or actual memory on the machine."}
{"text": " So when you're using your machine, you're using your processes, you might notice that even if you look at the actual RAM used by a process, the total amount of RAM used by every single process on your machine can actually exceed the amount of physical RAM on your machine, even though it's all in use."}
{"text": " So how it does this is it will go ahead and cache any memory that's not in use and throw it on the disk drive. So if you need it, it can go grab it from the disk drive. If you don't, it just stays there, and it can swap in and out whenever it wants. So you might notice this whenever your computer is running slow. Or has anyone ever seen a file on Windows called the page file or the swap file or something like that?"}
{"text": " So if some of you go browsing around and, where is it, see Windows or something like that, or maybe it's in the root drive, I forget, there's a gigantic file that's like 8 gigabytes or something like that that says PageSys or something like that. That's basically a cache for your RAM that, if you actually run out of physical memory, it will start offloading some of that storage to that file, which would be on disk."}
{"text": " So the idea behind that is you only keep pages in memory that are actually referenced, and then you put others on disk. And sometimes you have the nice property, like we saw before, if your disk block sizes are the same as your page sizes, well, you can just throw them on there kind of willy-nilly. And whenever you need to access that information again, you can read it back from disk and put it back into memory whenever you need it."}
{"text": " So today we'll be talking about page replacement algorithms, which is just picking which memory to swap to disk when you need to access something that is not currently in memory. So there's four main algorithms we'll go over today. There's optimal."}
{"text": " which is just replace the page that won't be used for the longest. And this is completely impractical because this is looking into the future, and it's mostly just for evaluating your page algorithm, knowing what the benchmark is for the best you can do. And then there's another strategy, which might be intriguing and easy to implement. There's random page replacement, where you just randomly throw it a page disk and swap it out."}
{"text": " Then there's also our good old first in, first out, which would replace the oldest page first. We've been using first in, first out. That seems to be the default for every single problem we have to do in operating systems. And then the last one we'll look into today is least recently used. So the idea behind that is we replace the page that hasn't been used in the longest time, because the process is probably done with that for now, and it's accessing other pages."}
{"text": " So for all of this, we're going to assume that it's a silly assumption, but we'll assume that our physical memory can only hold four pages at a time. And whenever we access memory, we want it to be, or whenever we access a page, we want it to be in memory. But initially, all of the pages are already on disk, just so we have something to do. And we'll use this for every lecture, or every example in this lecture."}
{"text": " So our goal for page replacement is whenever you swap in a page, you want to swap in a page that will be used continually. And our goal is to reduce the number of page faults because each page fault is terribly slow because it actually has to read it physically from disk, which, as we know, is a lot slower than actual memory. So that's our criteria is basically the number of page faults. Yep."}
{"text": " Yeah, so in this case, so we can generate page faults a few ways. So page faults can just be that it's not mapped. Or you can use page faults for other things. So like Lab 5, you're using page faults for copy on write. For this, we're going to use page faults to actually read in information from disk. So you can use page faults for a variety of different purposes. And this is just another one of fooling the system to thinking it has more memory accessible than it actually has."}
{"text": " So again, we're assuming our physical memory only holds four pages. And then I'll just tell you the accesses in terms of what page it accesses. So in this example, we're accessing page 1, 2, 3, 4, then 1, 2, 5, 1, 2, 3, 4, 5."}
{"text": " So at the top of all these, I'll put whatever page we're accessing. So in this case, we're accessing page 1. And within the box at the bottom is what is currently in physical memory. And whenever I color a page red in physical memory, that means we read it from disk and we put it into physical memory."}
{"text": " So if our first access into page 1, initially there would be nothing in memory because that is our assumption. So I would have to read it from disk and read that page into memory. So it is now red, indicating a page fault, and I read it from the disk into memory. All right, same page. I have to say that joke. All right, so now if I access page 2, also not in memory, so I have to bring it to disk."}
{"text": " or sorry, I have to bring it, yeah, I have to read it from disk into memory, so I would read page two, and I can hold four pages in memory, so I don't have to kick anything out, so I would just have page one and two in memory now. Similarly for page three, same thing, I read it from disk, put it into memory, and now it is in memory, I can hold four pages, so I'm still good."}
{"text": " Now I access page four, same idea. It's not in memory yet, I read it from disk. Now it's in memory and now my memory is full because it is at capacity because I can only hold four pages."}
{"text": " So now if I try and access page one, I don't have to read anything from disk because I already have it in memory. So now there's nothing read. There's no pages in read because it's already in memory. I don't have to do anything. You could also think of this as a cache hit if you want or whatever you want. So same thing is going to happen for page two. It's already in memory."}
{"text": " No problem there, don't have to do anything. So the interesting thing happens when we access page five. So when we access page five, we need to bring it into memory, but in this case, since it's full, we have to kick something out. So now our problem is we have to kick out either one, two, three, or four, and which one would we like to kick out? So votes for kicking out one."}
{"text": " We like 1. Votes for kicking out 2. Votes for kicking out 3. Some of us don't like 3. Votes for kicking out 4."}
{"text": " Most of us don't like 4. More enthusiastic for 4. So this one says we're trying to do the optimal thing. So let's do a hypothetical and do what no one wanted. So if we kick out page 1 now, so we replace page 1 with page 5 in memory, then whenever we do the next access of page 1, well, we just kicked it out, so we have to reload it again. So that's a big waste of time."}
{"text": " So if we're doing the optimal thing, we will kick out whatever page is not going to be used for the longest time. So you can start at 5 and then go up to argue about it until you have one page remaining. So between page 1, 2, 3, and 4, well, the next page I access is 1, so I'm not going to kick it out."}
{"text": " Then after that, I access page 2, so I'm not going to kick it out. Then after that, I access page 3, so I'm not going to kick it out. And then at this point, I only have one page remaining, so I would kick out page 4. So I now replace page 4 with page 5. Yep? But then eventually, we still have to remove one of them, right? Yeah, so I removed 4. But then whether we remove 1 or 4, we're doing only one removal?"}
{"text": " So I still have to swap it out because it's not in memory, but I just have to pick something to kick out, right? So if I picked one to kick out, in the next access, it wouldn't be in and I'd have to load it back again, right? Yeah, you have to load back four eventually in this case, but it also might be the case that I never access four again."}
{"text": " or something else, and it could be way longer than this. It's hard to get big picture examples from this, because I have to fit it on a slide and explain it. So now, because we replaced page 4 with page 5, well, we essentially looked at the future. So our next three axes are all going to already be in memory."}
{"text": " So we're all good. We access page 1, already there, don't have to load it from disk. Page 2, same idea. Page 3, same idea. And now we get to page 4. So now when we are loading in page 4, well,"}
{"text": " we're stuck, we actually have to load it in to memory now, and we need to kick out a page. So we can kick out 1, 2, 3, or 5. And in this case, there is a bunch of correct answers."}
{"text": " If I look ahead, my next access is to 5. So I don't want to replace page 5 because I would just have to reload it again anyways, which would be slow. But I don't use 1, 2, or 3 anytime in the future. So I can pick any one of those in this case to kick out. In this case, I'll just kick out 1. So I would replace page 1 with page 4. And then I'm good. Next access is page 5. It's already in the cache, yep, or memory."}
{"text": " Yeah, so we'll see in other examples with the same sequence. So it's optimal in the sense that we're reducing the number of page faults because we're delaying it as long as possible. So for this case, we didn't have to reload anything for three accesses in a row. Well, if we pick the wrong thing, we would have to reload it immediately, right? Yeah."}
{"text": " Yeah, here we're trying to just minimize the number of page faults. And if we look into the future, that's the lowest number of page faults we can get for that sequence. There's another question? No? Yeah? I'm still a little confused. How does it know which one is used? Like, replace the page that won't be used for the longest, how does it know?"}
{"text": " Yeah, so the question is, how do we know which one? So in this case, we have the sequence, and we can look at it. So this is just to evaluate them, because we're looking in the future. So we already know the entire sequence. Yeah, so in this case, we already know the entire sequence. So this is mostly, if you're analyzing these types of algorithms, well, you would record the number of page accesses, and then analyze it after the fact, and you can compare it to the optimal."}
{"text": " So here, our goal of this is just to count the number of page faults. In this case, it makes it really easy. You just count the number of red numbers. So for this sequence, with this algorithm, there are six page faults. So we can remember that because we'll very shortly make very poor decisions."}
{"text": " So poor decision, let's use FIFO, because we always use FIFO as like a first try thing. So same accesses, same problem, except this time we're not doing optimal. We're doing first in, first out, which will not look at the future. So you'll probably find it make a bunch of very poor and borderline silly decisions. So."}
{"text": " The only thing we can't avoid is the four accesses at the beginning, because there's nothing in memory. So the first four are going to look the same, where we have to bring them into memory from disk. So everyone OK with doing that? So I can just skip it for the rest of the other ones? OK. So the next access is going to follow the same suit as optimal. We're accessing page 1 already in memory. No problem."}
{"text": " Already there. Our next access, page 2. Already in memory. No problem. Already there. Now here is our decision. So now we can't look into the future. We have to look into the past. So we'd want to access page 5."}
{"text": " It is not in memory. We have to kick something out. So we have to kick out 1, 2, 3, or 4. So between 1, 2, 3, or 4, what did we add first? So 1. Anyone? So 1 was the first access. So that was the first thing we added in memory. And you can pretty much look backwards and see that, oh, yeah, we added 1 to memory first. So that's the first one we got to kick out."}
{"text": " So if we're doing FIFO, I added one first, so it's the first one out. So we replace one with page five, which you can see is going to be a bit of a problem. So we just kicked out page one, replaced it with page five. And now our next access is page one."}
{"text": " Crap, I just kicked it out. So I have to reload it again from the disk. So now I have to pick, do I kick out page 5, page 2, page 3, or page 4? Well, yeah, in this case, I would have to pick out page 2, because that is the, with all the ones remaining, that's the oldest one. And it also kind of looks like a diagonal line when you look at it with the red numbers like this. So that's an easy way to do it really, really fast."}
{"text": " So I had to kick out number two. So now in memory, I have five, one, three, and four. And then I do my next access. My next access is to page two, the one I just kicked out. Oh, jeez, this sucks. So I have to pick one to replace. Now I replace page three because it's the oldest one. All right, great, doing a great job here. Now I access page three, the one I just kicked out again."}
{"text": " So I have to do this again, and the oldest one now is page four, so I kick it out. Oh, okay, my next access is to page four. Wow, I'm doing a real good job here. You can see how this is kind of a crappy approach. So between what is remaining in memory now, one, or five, one, two, and three, five is now the oldest, so I kick it out."}
{"text": " So I replace five with four, and now I have four, one, two, three in memory. And now I finally access page five, which again, I have to bring back in and now my oldest is one. So this would be my final access where I bring it in. So now if I count the number of page faults here or count the number of red, which there is an access, which there is a lot of, how many page faults do I have now?"}
{"text": " I'll pretend I heard 10. Yeah, I see 10 mouth. So now I have 10 page faults. So this decision was clearly the bad one. So optimal was 6. And now if I did FIFO, I did 10. So it was way, way worse for this memory trace. So any questions about that? Yeah? Why don't we replace individual bytes?"}
{"text": " So the question is, why don't we replace individual bytes instead of pages? So if we replace individual bytes instead of pages, first, your hard disk does not like accessing bytes. It only accesses blocks at a time. And two, it's the same reason why we do it for our memory subsystem, because things are really, really slow. So if we can bring in a page at a time, it's way faster. Good question, though. OK, so let's do something fun."}
{"text": " This was FIFO. We had four pages we could hold in memory. So let's do this again. Same sequence, same everything, except now I have less memory. So I only have three pages I can hold in memory."}
{"text": " If I can only hold three pages in memory, my memory is smaller. That kind of makes me suspect that I should have more page faults because I have less room to store things. Sorry. So if I have less memory, it makes sense that I have more page faults, right? Because I have less room to store stuff. Everyone agree with that? Or the other way, if I have more memory, I should have less page faults. Yep."}
{"text": " Kind of, yeah. OK, yeah. So what you might expect by looking at this is, OK, well, let's go the other way. So if I have more pages, I will have less page faults. So if I started here where I had four, well, if I can hold five pages in memory, I'll just have the five page faults when I initially load them in. And then that's it, because I can fit everything. So if I have five pages, I'll have five page faults."}
{"text": " If I have four pages in memory, I have 10 page faults. You might expect that trend to continue where if I have three pages or less physical memory, I'll have more page faults because it won't fit."}
{"text": " But let's just make it smaller now. So we'll do the same FIFO thing, but instead of this time, instead of having four pages, we can only hold three pages in memory. So our first three accesses are going to be the same because we need to load it into memory from disk."}
{"text": " So now, this will kind of give us the intuition behind it that this is bad, because whenever we access page four, well, that generates a page fault, and we have to kick something out, which should be worse than before, because we didn't even have to kick something out whenever we accessed page four, because we had room for it. So, if we access page four, we have to kick out one, two, or three. In this case, it's FIFO again, so we're gonna kick out page one,"}
{"text": " So we kick out page one, load in four, and this is what our access looks like, and now it's looking real bad for this, because our next access is to page one, which we just kicked out. So we're going to have to load it back into memory, and we're going to have to kick out the oldest one, which would be page two, which looks real bad. So now we have five page faults in a row. We're not doing too good."}
{"text": " So our next access is to page 2, which, again, we just kicked out of memory. We are doing very, very crappy here. So we have to kick out whatever the oldest one is. In this case, it's page 3. So we would replace page 3 with page 2. OK, so things still aren't looking good. So our next access is to page 5."}
{"text": " We have to bring it into memory. We have to kick out the oldest one, which if we're doing that waterfall thing is now page four. So we kick out page four, replace it with five. So everyone on the same track right now, we're all good."}
{"text": " Okay, so this is where our luck changes a little bit. So now our next access is to page one. Thankfully, it's already in memory. So that is a hit and not a page fault. So that's good. Next access."}
{"text": " is to page two, altering memory. We're all good. Next one is to page three. Page three, we have to load in from disk into memory and replace the oldest one. In this case, the oldest one is page one again. So we replace page one with page three. So now in memory, we have five, three, and two. Now we're going to access page four."}
{"text": " When we access page 4, we replace 2, because that is now the oldest one. So now in memory, we'll have 5, 3, and 4. And then our last access is to page 5, which thankfully is already there. So now we have this. So how many page faults is that? 9."}
{"text": " which is less than before. So we have less memory and less page faults, which seems a bit weird. So if you took that to its extreme, if you wanna speed up your computer and make page faults less common, just get a smaller hard drive, right? It's everyone's solution to everything. So that might imply that this isn't used. So this thing actually has, oop, yeah,"}
{"text": " Yeah, so. Is it always the case, or maybe it's just like for that sequence, having a smaller page size is less of a problem? Yeah, so the question is, is that always the case? And the answer is, someone has gone far into depth for that problem. So there is a name for this. So it's called Bellade's Anomaly, and it actually formalizes it more. And it says, in general, more page frames cause more page faults."}
{"text": " And this is a problem with all of the FIFO algorithms. It doesn't exist in an least recently used, or LRU, that we'll see much later, or stack-based ones. So in fact, for that question, they actually wrote a paper about it. Some mathematical people wrote a paper that's in Greek that I can't read. But they figured it out in, like, 2010 that it's actually unbounded. So given any sequence,"}
{"text": " or any combination of it, you can come up with a sequence that gets an arbitrary number of page faults. So that's fun. If you really like math, you can go read that paper. If you have any questions about that paper, don't ask me, because yeah, I did engineering, not math."}
{"text": " So for all other algorithms, your intuition is correct, where if you increase the number of page frames or increase the amount of memory you have, it will decrease the number of page faults, which is more what you actually expect. So this is just for FIFO algorithms, which is kind of a fun thing. All right, so last one for the day. We'll do least recently used. Is that a question? Yeah."}
{"text": " Yeah, so if you go with the extreme cases, you can come up with different ones. But this is like, yeah, for the non-trivial cases, they can come up with any one."}
{"text": " OK, but for us, we don't really care because we're not going to use FIFO because it's garbage. So the first one we actually will use, which we'll see is kind of impractical, but we can actually argue about it, is least recently used. So it doesn't look into the future. It just looks at the usage pattern in the past to kind of predict the future."}
{"text": " So again, same accesses, same everything as before. We'll go back to four pages and do the same tie, or sorry, and do the same accesses. So our first four going to look exactly the same where we have to bring it into memory from disk. Then again, our next two accesses are going to be the same. So one and two are already in memory. So we don't have to replace anything. So we're all good."}
{"text": " Our first question comes in now is now if we we are replacing or if we need to read in page five"}
{"text": " Again, we need to replace page 1, 2, 3, or 4. So least recently used is as the name implies. You go backwards in time, and whatever has been used or whatever is the least recently used or whatever hasn't been used in the longest is the one you kick out. So if we start at page 5 and look backwards, well,"}
{"text": " Right before five, we use page two, so we're not gonna kick out page two, so it's safe. Then we look at page, then it access page one, if we go backwards, so we're not gonna kick out page one, so it's safe. And then if we look back another one,"}
{"text": " It used four, so we're not gonna kick out four, so it's safe. So there's only one page remaining in memory, and that's poor old three. So three hasn't been used in the longest, so it's outta here. So we would replace five with three. So any question about that?"}
{"text": " Fairly-ish straightforward. OK, so now we actually made a good decision this time for a change. So our next access is to page 1. And this is typically how memory accesses actually happen on your machine if you use a page."}
{"text": " Typically, you're running a program, something like that. You'll access the next thing in the array, which will typically be on the same page. Or you'll execute the next instruction, which will probably also be on the same page. So this is more like memory access patterns you'll actually see on your machine. So access page 1, we're all good. It's already there. So we don't have to replace anything. Then we access page 2."}
{"text": " Again, already there, don't have to kick anything out. Now when we access page three, oh shucks, now we have to kick something out again."}
{"text": " So again, we look backwards in times to see what has been used least recently. So if we go backwards, we can't kick out two because it was used right before, two safe. We also can't kick out one because it was just used, so one safe. And we also can't kick out five because it was used right before that, so five safe. So by process of elimination,"}
{"text": " 4 is the one we kick out, which will prove to be a bad decision, but hey, we made it. So we kick out 4 and we replace it with 3. And now we access page 4, which unfortunately we just kicked out. So it will do the same thing. So we'll look backwards. We have to kick out page 1, 2, 3, or 5. So we'll go backwards. So we're not kicking out page 3. We're not kicking out page 2."}
{"text": " We're not kicking out page one, we're kicking out page five, which again, unlucky decision."}
{"text": " So we kick out page five with page four, and we end up with this in memory. Now we access page five, and we have to do the same thing. We have to kick out one of them. So again, we'd go backwards. We're not kicking out four. We're not kicking out three. We're not kicking out two. So we're kicking out one. So we replace one with five, and this would be our final answer."}
{"text": " So if we count the number of page faults here, well, 1, 2, 3, 4, 5, 6, 7, 8. So now we have eight page faults. So it was better than FIFO, wasn't as good as optimal, but it was clearly an improvement over FIFO. So any questions about that? Yep."}
{"text": " Oh, yeah, so the question is, if it's done sequentially, when would we have a tie? So you would have a tie only in the case of multiple cores or multiple processors that might actually try and access the same thing at the same time. So for these questions, they're all sequential if we assume one core, so there won't be a tie. But that's mostly there for practical matters. If it looks like a tie, you just used FIFO to break it."}
{"text": " OK, so this least recently used kind of sucks practically. So it actually works fairly well. It's just whenever you go to implement it, it is a pain. So if you want to implement this in hardware, well, you have to search all the pages. So you have to search all the pages in memory and actually do the traversal, which is like order n, which really, really sucks."}
{"text": " So you could implement it, and you'd keep a counter for each page that essentially says, oh, when was I last accessed? And then if you have to replace a page, well, you could save that clock. You save the time on each page, and then you search them all to find whatever the oldest one is, and then you kick out the oldest one. But that involves"}
{"text": " Saving a clock for every page, which is going to take some space, and scanning through every page, which is going to be really, really, really, really slow."}
{"text": " You could do it in software. We could be like, oh, yeah, well, linked lists are 01. They're constant time. That's great. So let's just create a doubly linked list of pages. And then for each page reference, well, I would just move it to the front of the list. And that way, I maintain that the order of my linked list is the order of accesses. So if you just have an access to it, then it goes to the front of the list."}
{"text": " So if you do that, well, then your link list is actually ordered by access time without having to store it explicitly because you're just moving it up."}
{"text": " Now for replacement, that's really, really simple. You could just look at the back of the list and say I'm removing that page. But the problem with this is that the constant really, really, really, really matters because that constant of adding that page to the front of the list"}
{"text": " happens for every single memory access on your machine. So every single byte, you would have to do essentially six pointer updates for every memory operation you use on your machine. So it would slow down your computer by a factor of a lot, by several hundred probably."}
{"text": " on each reference, so it's not going to be practical whatsoever. And there's also, it's even worse if you assume multiple processors because you would have one queue and then, say, eight processors trying to all manage that queue at one time. And as we know from Lab 4, that's a data race. So all the processors would have to contend with updating that list, so it'd even be worse than that constant time thing."}
{"text": " So this would just be absolutely abysmal, and you just couldn't do it. So what we settle for is an approximate least recently used. And we think that is OK, because least recently used is kind of an approximation of the optimal algorithm. If you think about it, it's just using the past to predict the future instead of actually knowing the future."}
{"text": " So there's a lot of different tweaks you can do to implement more efficiently. So next lecture, we will look at the clock algorithm. But there's also a bunch of different ones. There's least frequently used, which is a little bit different, where it counts the number of usages. There's using two hardware queues. There's adaptive cache. There's all types of different algorithms with different trade-offs. And we will just see one particular one that's a bit more easy to understand in the next lecture."}
{"text": " All right, so any questions? Next lecture will be a fun one because I animated a little clock. It's lots of fun. So goal of today, we use page replacement algorithms to reduce the number of page faults because we're now taking advantage of disk being bigger and trying to fool our operating system into using more memory than it physically has."}
{"text": " So we saw four algorithms. We saw optimal, which is good for comparison, but not realistic. Random, we didn't do an example of it, because as the name implies, it's random. But if you actually analyze how well random works, well, it actually works surprisingly well. It beats FIFO quite handedly, because"}
{"text": " In practicality, it avoids the worst case. If you just randomly make a decision, you can't really make a bad one, or you're least likely to make the worst decision possible, which FIFO tends to do. So it actually kind of works in practice. FIFO, we saw, kind of easy to implement, but has that anomaly where"}
{"text": " We give it more RAM, and we have more page faults, which kind of sucks. And then lastly, we saw least recently used, which gets close to optimal, but it's expensive to implement. But it's the first one we saw that's actually practical. So with that, just remember, pulling for you, we're on the stage."}
{"text": " using this binary search will take less time than the linear search right. Now what is the working principle of this binary search we are going to discuss with the help of an example right. Now see one prerequisite of this binary search is or you can say the requirement of this binary search algorithm is what the array should be sorted. See here you can see I have taken this example but the data in this array is what sorted right."}
{"text": " If the data is not sorted then you cannot apply binary search on that array. You have to first sort the array then you can apply binary search for searching. So here the precondition for this binary search is the array should be sorted. That is not a case in linear search. That linear search works fine on the sorted array as well as on unsorted array. Now we will see how this binary search algorithm will work."}
{"text": " work fine see so now we are going to search for the data or you can say key 59 is this 59 present in this area or not and if present your code should return where this 59 is present the index at which this 59 is"}
{"text": " present see one more important point about this binary search algorithm is what it is divide and conquer technique it means it is going to divide the array into two halves recursively divide the array now how recursively it will divide the array into sub arrays we are going to see see in this case we are going to find out the middle element of the array fine so"}
{"text": " we are going to take two variables first is here left variable and we are going to point left here means l value is 0 next variable is right and the value of this right is 9 or you can say n minus 1 so in this algorithm we are going to find out the mid position of the array from where we are going to divide the array into two halves fine see"}
{"text": " First of all, the left is 0 and the right is 9 in this case. Now find out the mid of this one. How to find out mid? L plus R divide by 2. L plus R divide by 2 and we are going to take the floor value of this one. 0 plus 9 divide by 2 is what? 4.5. Floor value is 4. So mid is what? 4. So at index 4, we are having"}
{"text": " mid now now here three cases can be there first case is the data you want to find out is equal to the data at the mid position fine second case is the data is less than the data which is at mid position or third case is the data you want to find out the key you want to find out find out is greater than the data which is at mid position so"}
{"text": " So these are three cases. Find data is equal to this mid, data is less than this A of mid and data is greater than A of mid. Three cases can be there. Now see, here the data is 59 and mid is 4. Now what is that A of 4? A of 4 the data is 25. So here the case is this one. The data is 59 and 59 is greater than A of mid. A of mid is 25."}
{"text": " right so now we can say that this data is present to the right of this mid in this subarray in this subarray now we have divided this array into two parts one is this one and one is this one now we can say this 59 is present to the right of this mid now how you can say this because we know that the array is sorted"}
{"text": " And if array is sorted, then all the data which is greater than 25 must be present to the right of this 25. Now we are going to search only in this array. We have divided our search space. First our search space is this one. After first comparison, we have divided it into half. Now this is our search space. We are going to search from here to here now."}
{"text": " So, if this is the case then this left then this left variable should be moved here only to the right here this side towards the right. So, now, here we have our left our left now becomes mid plus 1 because we are going to work only in this array now and r is as it is that is 9."}
{"text": " again repeat the same step find out mid 5 plus 9 14 divided by 2 is 7 mid is what 7 now now mid is what here 7 now again 3 cases can be there now check data is 59 is 63 same as 59 no now the case is here 59 is the data is less than 63 this second case data is less than a of mid"}
{"text": " Now what you can say data is present to the left of 63 here only because data is less than 63 and array is sorted. So now so now if data is present to the left of mid to the left of mid in that case what you will do left would be as it is 5 and this right would be moved towards this side. So now right becomes mid minus 1 now here we have right."}
{"text": " because now we are going to work only in this space here only we again divided the array into two parts that is why I was saying we recursively divide the array into two parts fine until you find the element so now r is what 6 mid minus 1 7 minus 1 is 6 now again find out the mid 5 plus 6 is 11 by 2 that is 5.5 floor value is 5 so mid is now here"}
{"text": " L is also 5 and mid is also 5 now. Right? Now check. Is 59 same as A of mid? No. 59 is greater than A of mid."}
{"text": " It means 59 is present to the right of mid to the right area of this mid right. And if this is present the data is present to the right of the mid in that case what we will do we will move left towards this side means left becomes mid plus 1 now right. So, left becomes mid plus 1 that is 5 plus 1 is 6 right remains as it is. So, now here we have left and here we have right only."}
{"text": " So if left and right are pointing at same index, it means in this we have only one element. In the array we have now only one element. So now we have only 59. See, I can find out middle. 6 plus 6 and divide by 2 is 6. Now mid is also here at 6. Now check, if data is equal to a of mid, 59 is equal to a of mid, yes."}
{"text": " Now this is the stopping condition. We found the data. So now here you are going to stop and you are going to return mid. Return mid means you are going to return the index 6 where the data is present, fine. So this is the one stopping condition. Now second case is if data is not present in the array. In that case when you are going to stop your searching algorithm. Let us take that case only, that case also."}
{"text": " Is 25 equal to 59? Is this you want to search? No. So second case is this data. This data is what? This data is greater than the data which is at mid position. So here the case is this one. The data is 59 and 59 is greater than A of mid. A of mid is 25."}
{"text": " right so now we can say that this data is present to the right of this mid in this subarray in this subarray now we have divided this array into two parts one is this one and one is this one now we can say this 59 is present to the right of this mid now how you can say this because we know that the array is sorted"}
{"text": " and if array is sorted then all the data which is greater than 25 must be present to the right of this 25. Now we are going to search only in this array. We have divided our search space. First our search space is this one. After first comparison we have divided it into half. Now this is our search space. We are going to search from here to here now."}
{"text": " So, if this is the case then this left then this left variable should be moved here only to the right here this side towards the right. So, now here we have our left our left now becomes mid plus 1 because we are going to work only in this array now and r is as it is that is 9."}
{"text": " again repeat the same step find out mid 5 plus 9 14 divided by 2 is 7 mid is what 7 now now mid is what here 7 now again 3 cases can be there now check data is 59 is 63 same as 59 no now the case is here 59 is the data is less than 63 this second case data is less than a of mid"}
{"text": " Now what you can say data is present to the left of 63 here only because data is less than 63 and array sorted. So now so now if data is present to the left of mid to the left of mid in that case what you will do left would be as it is 5 and this right would be moved towards this side. So now right becomes mid minus 1 now here we have right."}
{"text": " because now we are going to work only in this space here only we again divided the array into two parts that is why I was saying we recursively divide the array into two parts fine until you find the element so now r is what 6 mid minus 1 7 minus 1 is 6 now again find out the mid 5 plus 6 is 11 by 2 that is 5.5 floor value is 5 so mid is now here"}
{"text": " L is also 5 and mid is also 5 now. Right? Now check. Is 59 same as A of mid? No. 59 is greater than A of mid."}
{"text": " It means 59 is present to the right of mid to the right area of this mid right. And if this is present the data is present to the right of the mid in that case what we will do we will move left towards this side means left becomes mid plus 1 now right. So, left becomes mid plus 1 that is 5 plus 1 is 6 right remains as it is. So, now here we have left and here we have right only."}
{"text": " So if left and right are pointing at same index, it means in this we have only one element. In the array we have now only one element. So now we have only 59. See, I can find out middle. 6 plus 6 and divide by 2 is 6. Now mid is also here at 6. Now check, if data is equal to a of mid, 59 is equal to a of mid, yes."}
{"text": " Now this is the stopping condition. We found the data. So now here you are going to stop and you are going to return mid."}
{"text": " return mid means you are going to return the index 6 where the data is present fine. So, this is the one stopping condition. Now, second case is if data is not present in the array in that case when you are going to stop your searching algorithm let us take that case only that case also. Now, let us take you want to find out 60 see 60 is not present here now we will see."}
{"text": " Same l is here only and right is here only. Now left is 0 and right is 9. Mid is what? 4. At 4, you have what? 25. Here we have mid. This is not equal to 60. 60 is greater than this 25. So data is present to the right of 25. If data is present to the right of this one, then we are going to move this left. Left becomes mid plus 1 here."}
{"text": " Now left is 4 plus 1 is 5 and right remains as it is. Again find out the middle element that is 7. Now mid is at here only. Now check data is 60 is 60 is equal to 63 a of mid no first case no that is not true."}
{"text": " Data is less than a of mid. Second case is true. If less than, it means the data is present to the left of left of 63. Then we are going to work in this array. Left becomes as it is in that case. In that case, right becomes mid minus 1. So here we are going to shift this right."}
{"text": " now right becomes mid minus 1 that is 6 again the middle element that is 5 so now mid is at 5 right here all here we have mid now check if data is equal to mid 60 is equal to 45 no 60 is greater than mid this condition is true if greater than if greater than"}
{"text": " then data would be to the right of this, right of mid. So, in that case we are going to move this left to this side. So, left this l becomes now mid plus 1 that is 6 and right remains as it is. So, now, here we have what left and right both. Now, middle element is 6, now middle 6, now here also we have"}
{"text": " mid now check this data 60 is equal to this mid no this 60 is what greater than this data it means the data is present to the right of this 59 right and if data is present to the right array then we are going to move this l l becomes mid plus 1 now l becomes 6 plus 1 is 7 and r remains as it is now this is the stopping condition here."}
{"text": " this l value if l value becomes greater than r value it means data is not present here."}
{"text": " we are going to repeat these steps find out the mid checking these conditions till l is less than right because here we have taken left here we have taken right once this left becomes greater than right they have crossed each other it means data is not present so this is the stopping condition in that case if data is not present right now I am going to write a piece of code for this binary search see I am going to create a function binary search"}
{"text": " In this, I am going to pass array A, total number of elements in the array and the data you want to search. So, now first of all what we have done, we have taken l is equal to 0 and r is equal to n minus 1, n is 10, so r was 9, fine. And after that we have calculated what, mid. So, now mid is equal to l plus r divided by 2."}
{"text": " right after calculating mid we are checked three conditions right three cases can be there. So, we have checked if data is equal to is equal to a of mid if this is true then you will do what return mid here you are returning some integer value. So, the data type would be int right if this condition is not true else"}
{"text": " data is less than a of mid if data is less than a of mid less than a of mid less than means data is present to the left side of this mid it means r value would be moved l value remains as it is so now r becomes mid minus 1."}
{"text": " And the third case is data is present to the right of this mid. In that case, you will move left. Left becomes mid plus 1. Else, L becomes mid plus 1. And you are going to repeat these steps."}
{"text": " left l is less than r once l becomes greater than r it means data not found right so you are going to repeat these steps so you are going to write down these steps in a loop that is while l is less than r till then these steps would be repeated if l is not less than r it means obviously l would be greater than r so here you can return what"}
{"text": " minus 1, minus 1 means data is not present right and you can close this function."}
{"text": " So this is how the binary search is going to work. Now what is the time complexity for this algorithm? See we are reducing the search space by half. At first search space was this one again by half again by half again by half like this. So if such kind of behavior exists in that case time complexity would always be order"}
{"text": " log n in worst case it is order of log n and what is the time complexity in best case see suppose I am going to find the data 25 data is 25 at first I am calculating l plus 9 plus 0 divided by 2 that is 4 and at 4 is mid is at 4 now here only I got 25 so this is what the best case in best case time complexity would be order of"}
{"text": " 1 right and in worst cases it is order of log n. See now why I am saying this order of log n I am going to tell you with the help of an example. See let us take these two cases I am just going to take these two for loops simple for loops I am going to calculate the time complexity for this and this also. Time complexity means we are going to find out within this for loop this statements is going to execute how many times."}
{"text": " right that is the time complexity now in this case in this case how many times the statement within this for loop would be executed see i is equal to 1 i less than 100 here n is equal to 100 here also n is equal to 100 fine."}
{"text": " So, this is going to be executed now i into 2 here I am going to double the value of i. So, now, next time becomes i value becomes 2, 2 is also less than 100 now again it would be executed now next time it becomes 4."}
{"text": " 4 is also less than 100 now next time it becomes 8 next 16 32 64 and after that it becomes what 128 128 and 128 is not less than 100 so this is not going to be executed so how many times this statement would be executed 1 2 3 4 5 6 7 7 times and n value was 100 for the value 100 how many times this statement would be executed only for 7 times"}
{"text": " right same here in this case n value is 100 how many times this would be executed at first i is equal to 100 now i am going to divide the i value by 2 i am going to divide it by half next time 50 50 is greater than equal to 1 okay next is 25 25 is also it would be executed next time divide by 2 is 12 next time 6 next time"}
{"text": " three next time one next time if you divide it becomes what zero zero is not greater than equal to one so it is going to stop it is not going to execute now here also seven times one two three four five six seven seven times here also n value is hundred right i hope you know the formula of this thing log of base b and n is equal to k it means it means this b"}
{"text": " b of b power k is equal to n right this is the formula if this is the case then you can say that b of k is equal to n if you if this is the case b of k is equal to n it means you can say log of p n is equal to k now here n is equal to 100 now if you put log of 2 and 100 what you can write 2 raised to power"}
{"text": " 2 raised to power what 7 because 2 raised to power 6 is what 64 and 64 is not. So, I can write 2 raised to power 7 that is 128. So, I can write 7, but I cannot write 6 because 64 is less than 100, but greater than value we can write. So, we can take here 2 raised to power approximately 7. So, it means it becomes what 7 only right because base is also 2 and here also 2 it means we just take only the power that is 7."}
{"text": " So, the time complexity how many times this loop has been executed log n times."}
{"text": " right here also you can see log n times. So, if such kind of behavior occurs if loop is going to doubles or loop is going to half in that case always the time complexity is order of log n. So, in binary search also we are going to divide the space by half then again half then again half."}
{"text": " So, this is the case. So, the time complexity would be log n here and this log n is far better than the order of n that is the time complexity of linear search. That is why I was saying that this is the most popular searching algorithm because of this time complexity only. In the worst case the time complexity is order of log n. In average case also the time complexity is order of log n."}
{"text": " So this is all about binary search. I hope you got this concept why we are writing the code like this. Maybe this this case can be little bit confusing why we are taking the time complexity log n but I hope you got this fine. So I'll see you in the next video till then bye take care."}
{"text": " you"}
{"text": " you"}
{"text": " Alrighty, welcome back to 1.05. Thank you for joining me today. So, didn't see any questions on the Discord or anything like that. Could either be a really good sign or a really bad sign. Just in case, we will go ahead and leapfrog the other sections a little bit."}
{"text": " and move on to the next topic so you can start the next lab, and also get some more questions going. So this will have some familiarities with the last lecture, but we won't tie them together until the next one. So we kind of need another piece of our programming puzzle. So we have loops for repetition. So they help us not repeat each other, like I said."}
{"text": " If I have to count all the way up to seven, that's too much for me and I can't do it anymore. So we have loops for going ahead and doing the same operation over and over again. But what about if we have multiple variables? Loops can't really help us. So like what if we want to take, I don't know, the average of a bunch of grades. So let's say we do something like this."}
{"text": " So, if I want to take the average of five grades, what we know so far is, well, I have to declare a variable for each grade, and then I have to initialize it to whatever their grade is, and then to calculate the average, well, I have to do grade one, plus grade two, plus grade three, plus grade four, plus grade five, all divided by five to calculate the average."}
{"text": " So that will work. And our average would be 78. But that kind of sucks, right? If I want to add another grade, what do I have to do? I have to declare another variable, grade. So let's see. Let's say I got 2%, so doing good. And then I have to remember to go ahead and I have to change this. So I have to add it here. Then I have to remember to divide by 6. And that's just a whole mess."}
{"text": " We want to be real programmers. We want to be lazy. We don't want to do any of that crap. We want to just be able to add a new value and just have it calculated for us, right? We want to be lazy. Being a lazy programmer is a very good thing. So here's what we had before. So calculating the average of five grades, five individual variables we have to declare, have to do our average calculation, print out the average,"}
{"text": " And every time we want to add a new grade, that means we have to add a new variable. That means we have to add it to the average calculation. We have to change the divisor. Kind of a mess, but this is all familiar to us, right? We all know how to do this. All right, at least one thumbs up. So error-prone, we don't have to remember to do lots of things if we were just adding a single value."}
{"text": " So that's where arrays come in. So they're for groups of related values. So we can declare a number of integers all at once. So at first, this won't seem that useful, but bear with me. So the syntax for declaring arrays looks like a normal variable declaration. So type followed by a name, except there's these weird square brackets. So it's square brackets and then an array size. And that array size is going to be"}
{"text": " How many numbers of this type are we going to declare all at once? So the type that is the type for each value or element of the array is what we call individual values specifically in an array."}
{"text": " Then we have to give the array a name, and it will be representing a group of numbers. So you should probably call it whatever that group is. And then the array size, which is just going to be an integer, which is the number of values you actually want to create all at once."}
{"text": " And then if we declare them all, we just have a big group of numbers. We want to be able to access each number individually. So how we access each number is in an expression. We can just use square brackets. So after you've declared an array,"}
{"text": " In an expression, you just access it by using the array name, and then the square brackets with an index. Looks a bit weird right now, but what you replace is the array name by whatever name you declared the array as, and the index by the element you would like to select, and you give that an integer. So you might think that, OK, well, we're human, so I might want to say element 1, element 2, 3, 4, 5."}
{"text": " Well, turns out, for reasons we will get into in the next lecture, C starts counting at zero, not one, because it turns out, we'll discover later, counting starting from zero is just way more convenient for computers. Basically, every single programming language does this, except for really weird ones. So what we call this is we say arrays are zero indexed. That means they start at zero."}
{"text": " So that means if I made an array called a, well, array or a square bracket zero, that is the first element. And if I have a square bracket one, that's actually the second element, so on and so forth. So it's a bit off by one from how we like talking about them as humans. But as you start getting used to computers, this will become kind of second nature to you. And we should get used to it now."}
{"text": " So let us go back to this example and use an array instead. So here I have a group of related values, so I might say they're called."}
{"text": " int grades and say I have five of them so I can declare an array like this. So this will declare five integers and that group of integers collectively is called grades. So now I can get rid of all of these declarations for the grades and now refer to them by their indexes."}
{"text": " So grade one, well, since it is an array and it's zero indexed, the first element of the array would be at index zero. And then I have index one, index two, index three, index four, and it's called not grade anymore, whoops. It is called grades. So now,"}
{"text": " I don't have to declare five individual ints. I declare them all at once here. And then I go ahead and I set them accordingly after that step. So now I would have to fix this as well. So this would be grades zero, grades one, grades two, grades three. And I didn't say grades."}
{"text": " And then grades four. So now if I compile and run that, I'm in the same situation I'm in before, but I'm setting myself up for being able to get rid of this repetition. So any questions about just declaring the arrays, or declaring an array and then setting all the values? Not too bad. So."}
{"text": " So again, just so you have it, here's that same code using arrays. So now I can look at that calculation and I can look and try and not have to repeat the word grades over and over again. So if we look at that equation, is there a way to do that calculation without having to write grades zero, one, two, three, four, yep."}
{"text": " Not quite. Or not an easy way. So those numbers, do we know how to count up? Like have an int that goes one, two, three, four, five? Yeah. Yeah, it looks like a for loop, right? So, well, instead of,"}
{"text": " going ahead and accessing each grade individually, I will go ahead and do a for loop. So how would I, what bounds would I need if I want to, let's say, declare an int called index. I'll start it at zero. And if I want it to go all the way up to four, what should my condition be? Yeah. Yeah, index."}
{"text": " I could do index less than five for my condition, right? So this will be true for zero, one, two, three, four, and then whenever we get five, then that is false, and then we won't repeat ourselves. So that's right because, well, we don't want to access five for reasons we'll get into later. And then here, I just go plus plus index."}
{"text": " So this should get rid of all the grades. So instead of writing grades and then a number, I can just do grades zero."}
{"text": " And I'm just kind of summing up all the values. So I could just create a variable that keeps track of the current running total or the current sum. So let's create a variable called sum. And well, I want to start it off at zero, just so I don't calculate this wrong. So I'll just initialize it for zero. And then each time through the loop, I will do sum equals sum plus grades index."}
{"text": " Right? So each time through the loop, I'm going to just add whatever the current grade is to the sum, and then just calculate the sum by the end of the for loop. And I could also write this if I want, just on style that I like a little better. I could do sum plus equals grades. It means the same thing."}
{"text": " So here, instead of this average, I can just get rid of this whole thing because I've calculated the sum. And it should look like that. So now if I compile and run that, I get the same answer, but I don't repeat myself as much. So any questions about that? All right. Still a bit unsatisfying because, well,"}
{"text": " If I have to add another grade, what do I have to do? So if I want to add another grade, let's say I want to add grades five. Let's say it's one of the students in this class, so it's definitely 100. So can I just add another grade and it'll just work? No. What are the things I need to change here? Someone new. Yeah."}
{"text": " Change the size of the for loop, yeah, so I have to change this to six, uh-huh. Is that the only change? Yeah. The which one? Yeah, I have to do this average calculation to six. Is there one more? Yeah. The grades index?"}
{"text": " This, this, right? So this is not an index. It's the size of the array. So if we're using it as like accessing the array, not declaring it, it's an index. If we're declaring it, it's the size of the array. But yes, we do have to change that one. So yeah. So now, do I have to change everything or am I good?"}
{"text": " All right, got a thumbs up. But still a little bit unsatisfying, right? I need to add a grade. I still have to add a line. And then I had to remember to change. Actually, I made it a bit worse, because before I had to remember to change two things. Now I have to remember to change three things. So like I said before, it gets worse before it gets better. So let's see."}
{"text": " All we really did so far was just get rid of having to write it out, like adding each new term to the sum each time through the loop. Also, as a little bit of a review, or a test of your knowledge, so I can take the sum of everything, and then here, I'll make that a bit bigger."}
{"text": " I can take the sum of everything and divide by 5. Could I also do that? Instead of taking the sum of everything and divide by 5, I'll just take the current grade and divide it by 5 each time I add it to it. And then that's all I have to do. I'll give you a minute to think about that one."}
{"text": " Yeah. Sure we can. Yeah, we can."}
{"text": " All right, anyone from the middle, is this a good idea?"}
{"text": " Oh, we got some shaking head. Anyone wanna be brave enough to explain why this is a good or bad idea? Yeah."}
{"text": " Yeah, so remember, these are all integers, so I'm doing integer division, which is also called truncated division. So each time I do a division, I might truncate it. So like, say, some extreme case where all the grades were, say, four, and it was not this section, but another section, well,"}
{"text": " 4 divided by 5 in integer division is just 0. And then it would be 0 plus 0 plus 0 plus 0. And the average would be 0 when you would expect 4. So usually, especially with integer division, you want to divide as little as possible. And we can see even for this little example, so our average is 78, which would be OK. And now if we just move the division,"}
{"text": " Well, because of integer division, we're doing five integer divisions instead of just one. Well, we stray further and further away from the actual answer. So we get 76 now. So hopefully, we are smarter than this when we calculate the course averages for this course. Otherwise, probably going to be lower than we expect. All right, good review."}
{"text": " All right, so again, here's the code. So you have it. That's just us looping over each element of the array. So we have."}
{"text": " What I like to refer to those like fives that just randomly come up, I like referring to them as magic numbers. And in general, we want to get rid of magic numbers. Everything has a name and everything should have a name. So we can actually tell by looking and reading the program what things are actually related. So you might know now that all those fives are related to how many grades there are. But if you go ahead and"}
{"text": " You, I don't know, have a life for the weekend and have fun and then come back to it on Monday. You might forget what you were doing. You might not be able to read it. Like in that example, especially if there's three lives to change, you might forget one. Who knows? So."}
{"text": " In this case, yeah, I increase the length of the array to six, set that variable, change the loop bound to six, change the average calculation to divide by six, just a pain. So."}
{"text": " might not be taught in the other sessions, but I think it's worth talking about. We can use a define to use the C processor to do some copy and pasting for us. So don't have to know what that term is. I'll show you how to use it. Basically, it's just copy and pasting for us, which we like doing anyway, so we may as well make the compiler do it for us."}
{"text": " Basically, that define will do a search and replace. So if you write at the top of your code,"}
{"text": " hashtag, I guess, hash, pound, whatever you want to say, define. And then you write just something here. It will search for that term and then replace it by whatever you write after the space. So the search thing you want to replace, usually it's a string and it's all caps. And you separate all of the words with an underscore. And then the replacement is just whatever you want to replace that string by in the code."}
{"text": " So you can write defines also like a function, so you can go ahead and make them more complicated, but you won't have to write any of yourself in this course. If you do use them, you should just use them for getting rid of magic numbers. All right, so if we go back up here, well, we might do something like,"}
{"text": " do a define, we have to give it a name, probably want to be descriptive. So maybe I call it grades length. So like the length of the array, and then"}
{"text": " I will do the replacement equal to five. So now every time we compile our code, it will look for grades length, and if it finds it, it will replace it with five for us. So now we can get rid of our magic number. So we want to have grades length, number of integers, and then here, well, we want to iterate up to grades length."}
{"text": " And then when we calculate the average, well, we want to divide by grades length. So now I was smart, and I saved myself a lot of time. So now if I want to add another grade, so grades 5 equals"}
{"text": " 100, all I have to do is, slightly better now, I just have to remember to change this to six. Goes ahead, changes everything for me. Like I said, programmers are lazy, so this should be seen as like a triumph. So you should be proud of yourself. The less things you have to remember, the lazier you have to be, or the lazier you can be, the better. So I think there was a,"}
{"text": " famous quote at Microsoft where they just look for the laziest people they can find and they hire them as programmers because, well, they'll come up with good ideas like this to save themselves time, it's less error prone, and it's just a better idea. So let us reset it. All right, questions about that? Yep. So,"}
{"text": " Question is, would I recommend this over global constants? Depends. So in old versions of C, so the general answer is, this will always work. Global constants will sometimes work, depending on how old the C compiler is. So I'll just say the safe thing. So this will always work. This will do the find and replace. But we could do a constant if we wanted to."}
{"text": " Comes down to preference sometimes."}
{"text": " All right, so here's that same program. Got rid of our magic value. So now, if we look at it, we can see, OK, well, there's really no magic values here. So the beginning of an array, always going to be 0. That's not really considered a magic value. Sum equal to 0, not really a magic value. And then the only other numbers I input in this program"}
{"text": " are the grades. So that's specific. So if I just look at this program, there's no magic values anymore. Except in this example, just the size. I did return 0 instead of exit success. And that's just because I ran out of space on the slides. So."}
{"text": " We can actually clean this up a little bit more. So remember, when we declare a variable, well, if we had int x, we can just immediately say int x equals something. We don't have to wait and do it on a separate assignment line. So we can also do the same thing."}
{"text": " with arrays, but it's a little bit different because they are multiple values. So we can have the same array declaration, so type, some name, the size of the array, and then we can have equal, and then we need some curly brackets because it's a group of numbers."}
{"text": " And then here, we just have some comma-separated values in order to initialize the array with all of those values. So the type name and array size, same rules as before. The comma-separated values, it's the values you'd like to assign, again, in order. So the first one you write down will be at index 0."}
{"text": " Second will be at index 1. Third will be at index 2, et cetera. And the values must match the type of the array. So if I have an int array, they all have to be integers. If I had a double array, they would have to be doubles. Or so you're going to convert them for us. Or if I had a char array, or bool array, or whatever."}
{"text": " So let us clean up the code a little better now that we know that. So instead of writing all that, which was kind of, I didn't like doing that, I could just do equals and then curly brackets. And then here, I can just go ahead and write the values. So I can write 75, 85, 99, 64, 72. And then I can just delete that."}
{"text": " So now if I can type, compile, build. So now average is still the same, so good to Sandy check that we still have the same example. And now this is starting to look a lot better, isn't it? But still, if I want to add another grade, right, I still, it's like almost there. Here it's kind of nice. I just like add one, and then I have to remember to change this."}
{"text": " So I can do that, that's not too bad. But ideally, I would like just to add a new grade and have it figure it out for me. Like I said, even remembering one thing, eh, we have a chance to screw it up, so at least for me, I do not want to take that chance. So again, here is the example, just so you have it."}
{"text": " So, turns out that that array size, if you set values,"}
{"text": " just assign the values, and then C will go ahead and be a nice programming language and figure out the length for us. So you can just get rid of the array size and write type name, and then just empty square brackets, and then all those comma-separated values. Then C creates an array with the length equal to the number of values for us, which is great. So I can just write grades."}
{"text": " empty square brackets, and then all of the values. So, to first talk about arrays, so arrays, we have to talk a little bit about in memory, so they're gonna be large enough in memory to hold all of the values. So if I have int grades and array, and I set five int values, well, the grades array"}
{"text": " We say it contains five int values, and we know that an int is four bytes, so therefore, the total size of this array is just how many ints they are times the size of the array. So in this case, the total size would be 20 bytes."}
{"text": " So it turns out that if we remember that sizeof operator, so we can check the size of the array in bytes using the sizeof operator. So if we did sizeof grades, well, C would return 20 because it's 20 bytes long."}
{"text": " And also, just as a beware here, so up to this point, I said length for how many elements are in an array, and then I only used size when I talked about the number of bytes."}
{"text": " Turns out, most programmers use the term size and length fairly interchangeably. So usually, we don't actually need to know the size in bytes of an array. So in the previous example, when people are actually talking about it, they might just say the size of the array is 5, and no one really talks about the size of the array in bytes."}
{"text": " So you might hear those terms used interchangeably, so don't worry about it. Even though that size would be different than what you get back from the size of operator, turns out no one really cares in general how many bytes an array takes up. They just care about how many values are in it. So."}
{"text": " Why I'm saying this is because, well, this is a define you do not know how to write yourself. So we can actually use a define to calculate the length of the array for us. And then I don't have to remember to go ahead and change the value for us. So I need to just."}
{"text": " All I need to do is use this macro, or sorry, use this define. So usually if we have a define that takes arguments that kind of look like a function, people generally call them macros, but it's just a simple search and replace. So whatever is in the brackets when you use this, it will just be substituted in for, in this case, ARR here and here. So still do that copy and paste. Again,"}
{"text": " Don't worry about it if you don't understand it. But in the previous example, if I go ahead and use that macro, then if I do array length on grades, it says 5, which is the number of elements that are in that array, which is great. So let us go back here. So what is my file?"}
{"text": " Which length? So let's go back here. All right. So here is that same program with the array length macro. Again, don't have to read it. So all I have to do now is I can just say,"}
{"text": " An array of integers, I'll call it grades, and then I'll go ahead and set them. I don't have to explicitly say the size in between the brackets because"}
{"text": " C's got my back. It'll figure it out for me. And then if I want to know the length of the array, well, I just use this array length macro and then give it the grades. And basically what it's doing is taking the size of the entire array, so in this case, 20 bytes, divided by the size of one element, so the size of an integer, which is 4. So 20 divided by 4 gives us our 5."}
{"text": " Everything else is the same. And I can replace the magic number, that define I had before, by just grades length. So again, I don't want a magic number, so I'll replace it with grades length. So now if I compile and run this, I get the same answer as I always got. And now if I want to add another grade, it's super easy, right? So I just do add another grade. Do I have to remember to change anything else?"}
{"text": " Is this way better? Yeah, this is awesome, right? So if I compile it now and I run it, boom, 82, easy. So if I want to just add another grade, I just add another grade, I'm off to the races. So questions about that? Yeah."}
{"text": " So with your macro, does the compiler basically know everything, all the values at compile time? So when you actually compile it, you're just going to have a number in the file, like in the output. Is it going to figure out what are the provisions? Because sizeof, sizeof array, it's still in the compile time. So it's going to be just before."}
{"text": " Yeah, in this case, the compiler will just do a simple search and replace. So this array length macro, by the time it gets to the compiler, it's going to look something like size of grades divided by size of grades 1, something like that."}
{"text": " The compiler will probably figure that out at compile time, figure out that, hey, the size of this array in bytes is 20 bytes, because I have five integers, and then divided by the size of, essentially, an integer. So 20 divided by 4 is 5. Oops, I'll delete that."}
{"text": " All right, any other questions with this? Yep. So this array initialization that you do in line 7, you can't really do that curly brace. Because you know when you initialize and then you say i equals 2, it's just like a little. And you can't use, say, 2 in other expressions. You can say 2 plus 3. But you cannot say curly brace 75 comma 84 for the closed forward brace, and then use indexing to access."}
{"text": " Basically, like a constant array, so to speak. You can do, like, 75 comma 83 infernal braces, and then do indexing in that. Sorry? What do you want me to do? Just, like, you know, say you want to initialize an integer. And you say int i equals, and then you do, like, open fernally brace, 75 comma 84."}
{"text": " Oh, this? Yeah. Yeah, you can't do that."}
{"text": " Like, so it's not really an array. It's like, basically, you can do this curly brace stuff only during that array implementation. Like, only with declarations. Yeah. So these curly braces here are only for actually declaring and initializing an array. That's it. So it's not really an array. Like, 2 is in it. Like, 2 literal and 2 is in integers. Yeah. Like, this curly brace on the left, that's not. Yeah. This curly brace just sets the values in the array. That's it. Yeah. So it's not really a syntax for an array. Yeah."}
{"text": " All right, any other questions for this? Pretty sweet so far, eh? All right, so. I will take your joy and crush it because things are gonna get weird. So."}
{"text": " We need to ensure all indices in the array are valid. So again, assuming we have our grades array here, which have five elements, we're only allowed to access grades zero all the way up to four. So."}
{"text": " In general, if we have an array with some length, let's say array length, well, we can only access array zero to index array length minus one. If we do something that is not within that, some really weird things are going to happen. So here is that same program. Let me just write it. All right, so let's review."}
{"text": " If I go ahead and make int x equals one, let's say I still do all this stuff, and I print the value of x. When I run this program now, what will I see printed x colon what?"}
{"text": " This isn't the tricky part. One? All right, hopefully it's one by now. Otherwise, you got a lot of work to do during reading week. And that's not good. So let's just run this just in case to make sure we haven't gone insane. So x is equal to one. OK, well, makes sense."}
{"text": " If I go ahead and say, I'll change grades four equal to three, let's say 42. So if I do this and run it again, what will I see when I print x? One again, right? I'm just changing the array. Wow, you people don't trust me at all. Jesus. All right, one, yay."}
{"text": " All right, so if I just do this and run that, x is still one, right? Yeah, x is one. No, it's 42. What the hell? What? What the hell was that?"}
{"text": " Help, what's going on? So, what did I do that was bad? Yeah."}
{"text": " Yeah, so I did grades six, so I tried to access the sixth, or in this case, the seventh element, and my grades array is only five, so that means I should only be accessing elements zero all the way to four, right? So, turns out, if you do not obey C's strict rules, so remember, the rule was you have to access"}
{"text": " valid elements in your array, if you do not do that, C is allowed to essentially do whatever it wants. In this case, one of the things of whatever it wants happens to be that it changes X, which is a bit weird. So."}
{"text": " That's a really odd thing that may happen. So on some computers, at least mine, if I just go ahead and try to change grade, like the seventh element of the grades array, I reassign that variable x I declared at the top. I see in that example, maybe I just assign it to 2. This one I did 42. But that's kind of confusing."}
{"text": " To end off, I guess we have a lot of time because that went quicker than I thought, but always make sure your ray indices are actually in bounds. Otherwise, really, really, really, really, really, really, really, really weird things are going to happen, and you will be very, very confused. So we'll figure out more or less why this happened in the next lecture. So any quick questions? That's just not that."}
{"text": " Yeah. Yeah."}
{"text": " Yeah, so the question is, in this case, if I just pick some invalid one, will it just randomly set a random value? So the answer to that is maybe, which is a very unsatisfying answer, and that's why this is really hard to predict, because, well, it turns out, if I just change this, whoops, if I just change this to grades five instead of six, and I run it, nothing seemingly bad happens."}
{"text": " If I change it to, I don't know, 7, I haven't done this before, so let's see what it does. Nothing really bad happens. If I change it to 8, nothing really bad happens. Let's just do weird things. All right, so let's make sure everything's invalid. So we can start the loop from grades length, so that is invalid, starts at 5, all the way up to, I don't know,"}
{"text": " Let's say 1,000. So we'll change it to 42. So this loop will start changing grades five, then grade six, then grade seven, all the way up to grades 999. So if I run that, I get a really weird error. Print X is 42, but then I get a bus error."}
{"text": " That's cool. Don't know what the hell that is. So, well, I kind of know what it is, and I kind of know what happened, but the moral of the story is always make sure your ray indexes are in bounds because C doesn't tell you an error. Sometimes it might, like if you do it literally, so in that, I didn't even get a compiler warning or anything like that. C was just happy just to compile it"}
{"text": " and just let us do things. When I wrote it like grade six, it actually gave us a little bit of a warning that I ignored. So it was a little bit smart where it said warning array index six is past the end of the array, which is five elements. So it's trying to save us here. I ignored it, and bad things happen. But when I had it in the loop, well, your compiler, when you hit compile, can't figure out what that bounds of the loop are."}
{"text": " So, turns out that it just won't even warn you, it'll just happily let you do something that is broken. So, with that, we can have Q&A, come talk to me or whatever, but just remember, pulling for you, we're all in this together."}
{"text": " In the previous lecture, we have seen an introduction to message passing systems. And in this lecture, we will be seeing the second part of message passing systems. So, in the previous lecture, we saw that if processes P and Q want to communicate, then they must send messages to and receive messages from each other. And in order for them to send and receive messages from each other, they need to have a link between them."}
{"text": " And that we call as the communication link. So, communication link must exist between the processes that wants to communicate through the message passing systems. And then this communication link that we talked about, it can be implemented in a variety of ways. So, there are several methods for logically implementing a link and the send receive operations. And these were the methods that we talked about."}
{"text": " the direct or indirect communication, the synchronous or asynchronous communication, and the automatic or explicit buffering. And also we said that there are several issues related with these features like naming, synchronization, and buffering. So, in this lecture we will be mainly looking at the direct or indirect communication, and we will be looking at the issue of naming which is associated with the direct or indirect communication."}
{"text": " So, let us see what is this issue of naming and what do we actually mean by direct or indirect communication in terms of message passing systems. So, coming to the issue of naming, what do we mean by naming? So, processes that want to communicate"}
{"text": " must have a way to refer to each other. And they can use either direct or indirect communication. So, when two processes want to communicate, they need to have a way to refer to each other. They need to have a way in which they can identify each other."}
{"text": " And for that we are going to use this naming. That is where the feature of naming comes into play. And they can use either direct or indirect communication. So, let us see what is this direct and indirect communication. So, first we will see what is direct communication. So, under direct communication, each process that wants to communicate must explicitly name the recipient or sender of the communication."}
{"text": " So, when we talk about direct communication, in this direct communication, whenever any process wants to communicate, they need to explicitly name the recipient or the sender of the communication. That means, if a process wants to send a message, it has to specify the name of the recipient. That means, to which process is it going to send the message. That has to be specified. And if another process is going to receive a message,"}
{"text": " then that process must specify the sender. That means from which process is it receiving the message. So, the send and receive primitives under this direct communication are specified like this. So, when a process wants to send,"}
{"text": " The send primitive looks like this. Send p message. That means send a message to process p. So, here p is the name of the process to which the message has to be sent. And that has to be specified. That means p is actually the recipient. p is going to receive the message that is going to be sent by this process over here. And then the receive primitive looks like this. Receive q."}
{"text": " Message, that means receive a message from process Q. So, that means here Q is the sender. Q is the name of the process that is sending the message. So, the name of the sender also has to be specified by the receiving process. So, this is what we mean by direct communication."}
{"text": " Now, let us look at the properties of the communication link in this scheme of direct communication. So, if we are having direct communication, the communication link in this scheme has the following properties. So, what are they? A link is established automatically between every pair of processes that wants to communicate. The process needs to know only each other's identity to communicate."}
{"text": " So, that means in this direct communication, whenever two processes want to communicate, there should be a communication link that has to be established between these two pair of processes. And after the link is established, these processes only need to know each other's"}
{"text": " identity or their names in order to communicate. So, we just show here. So, once the link is established, the sending process needs to know the identity of the recipient. And then the receiving process needs to know the identity of the sender. So, that is what we mean by this point. And then the second point says, a link is associated with exactly two processes and then between each pair of processes there exists exactly one link."}
{"text": " So, between these two processes that are going to communicate, there will exactly be one and only one link. So, the link that is created will be associated with only those exact two processes that want to communicate. And between each pair of processes, there will exist only one link, not more than one link."}
{"text": " between the two processes that want to communicate. So, those are the properties of the communication link under this scheme of direct communication. And this scheme exhibits symmetry in addressing. We say that this scheme of direct communication that we just discussed, it exhibits symmetry in addressing. And what do we mean by that? That is, both the sender process and the receiver process must name the other to communicate."}
{"text": " So, we have seen that in this direct communication that we discussed just now, both the sending process as well as the receiving process has to name the recipient and the sender. So, that is what we mean by symmetry in addressing. Both the sending process and the receiving process must name each other to communicate. So, this is another property of the direct communication system of message passing."}
{"text": " Now, let us look at another variant of this direct communication. Now, we will look at another variant of direct communication. So, remember it is still direct communication, it is not indirect, but it is direct communication, but this is another variant of the direct communication. And what happens here? Here only the sender names the recipient, and the recipient is not required to name the sender. So, in this variant of direct communication,"}
{"text": " Only the sending process needs to specify the name of the recipient. But the receiving process need not to name the sender. So, this is how the sending and receiving primitives look like. So, here it says send p message. So, the sending process, what it does? It sends a message to process p. So, p is the recipient, p is the process to which the message will be sent."}
{"text": " So, the sending process specifies the name of the receiver or the recipient process and then the message. But at the receiving end, the receiving process does not have to name the sender. So, here it is written id and message. That means receive a message from any process. And the variable id is set to the name of the process with which the communication has taken place."}
{"text": " So, the receiving process, it can receive the message from any other processes. Because this id is a variable. Now, what do we mean by variable? Variable is something that can vary. It is something that can change. So, in this place of id, it will mean the process from which it is receiving the message. And this can vary. So, if it is receiving from let's say process q, here the name of process q will be there."}
{"text": " Now, let's say that it is receiving from another process R. So, this id will be replaced by R. So, only the sending process needs to exactly specify the name of the recipient. But the recipient need not specify the name. So, it has a variable called id which will be replaced according to the process from which it is receiving the message. And this scheme employs asymmetry in addressing."}
{"text": " So, the previous one which we discussed, the previous variant, that was symmetric. Because both the sender and receiver has to specify each other's names. But in this variant, only the sender needs to specify the name of the recipient. But the receiver does not have to specify the name of the sender. So, that is why we call that it is asymmetric. So, this scheme employs asymmetry in addressing."}
{"text": " So, those were the two variants of direct communication. One is symmetric and the other one is asymmetric. Now, while both these methods of direct communication are good, it also has some disadvantages. So, let us see what are the disadvantages. So, the disadvantage in both of these schemes, which is both symmetric and asymmetric, is the limited modularity of the resulting process definitions."}
{"text": " Changing the identifier of a process may necessitate examining all other process definitions. So, what do we mean by this? The disadvantages of both the symmetric and asymmetric schemes of data communication is that it has a limited modularity. And what is the meaning of that?"}
{"text": " Changing the identifier of the process may cause a problem. Now, what do we mean by this? So, here we see that the processes communicate with each other with the help of the names of the other processes. So, it needs to know the identity of the processes with which it is communicating. Now, if the identity of a process is changed, that means if the way the process is named is changed, then this is going to cause a problem."}
{"text": " So, here let's see. Here we specify the name of the recipient as p because p is the process that will receive the message. Now, let's say that this process p, its name is changed from p to something else or the way it is identified is changed from p to something else. So, then this is going to become wrong."}
{"text": " So, if the identifier of the process is changed, then we will have to check all the process definitions that were made even before which is related to the process whose identifier was changed. So, that is why we said it has a limited modularity and that is the disadvantage of both these systems. Because in both these systems, we are using the name. In symmetric, we had to name both the sender and the receiver. And in asymmetric also,"}
{"text": " Though we don't have to name both, we still have to name the recipient. So, changing the identifier of a process, whether it is the sending process or receiving process, will have to make a lot of changes and we will have to examine all other process definitions associated with that."}
{"text": " So, changing the name will cause a big problem. So, that is a disadvantage of direct communication. So, now let's go to the next method of communication which is indirect communication. So, with indirect communication, the messages are sent to and received from mailboxes or ports. So, in this indirect communication,"}
{"text": " the messages are sent to and received from something known as a mailbox or a port. So, what do we mean by this mailboxes? So, a mailbox can be viewed abstractly as an object into which messages can be placed by the processes and from which messages can be removed."}
{"text": " So, this mailbox can be viewed as an object into which the messages can be placed by processes and other processes can receive or remove messages from that mailbox. So, in this way the sending process can send the messages to the mailbox and the receiving processes can receive or remove the messages from the mailbox."}
{"text": " So, each mailbox has a unique identification. So, all the mailboxes that are there they must have a unique identification. So, that the processors will know to which mailbox it has to send and the receiving processors will know from which mailbox it has to receive or remove the messages. And two processors can communicate only if the processors have a shared mailbox."}
{"text": " So, two processes will be able to communicate using this system only if they have a shared mailbox. So, suppose there are process P and process Q. They must have a shared mailbox which is shared between process P and process Q. So, only then they will be able to send the messages to the mailbox and receive the messages from the mailbox."}
{"text": " So, the send and receive primitives of this indirect communication using mailboxes, it looks something like this. So, the sending process, it says send a message where a is the name of the mailbox. So, it means send a message to mailbox a. And then in the receiving end, the receiving process executes receive a message. So, that means receive a message from the mailbox a."}
{"text": " So, the receiving process will receive a message from the mailbox A, the message which was sent by the sending process. So, here we see that the identity of the mailbox is what is important."}
{"text": " Now, let us look at the properties of the communication link in case of this indirect communication using mailboxes. So, always remember that whether it is a direct communication or indirect communication, there needs to exist a link between the processes or between the processes and the mailbox. Only then the communication can take place. The communication link is very important."}
{"text": " So, let us look what are the properties of the communication link in case of indirect communication. So, the first point says a link is established between a pair of processors only if both members of the pair have a shared mailbox. So, here in indirect communication the processors can only communicate if they have a shared mailbox. We have already said that. And a link may be associated with more than two processors."}
{"text": " So, in this case a link can be associated with more than two processes. So, in the previous one when we discussed about the properties of communication link in direct communication, the link was only allowed to be established or associated with exactly two processes. But in case of indirect communication, the communication link may be associated with more than two"}
{"text": " processes and then between each pair of communicating processes there may be a number of different links with each link corresponding to one mailbox. So, between each pair of communicating processes there could be many different links and with each link corresponding to one single mailbox. So, those are the properties of the communication link in indirect communication."}
{"text": " Now, there could arise a question. Now, the question is, now suppose that process P1, P2 and P3 all share mailbox A. So, let's say that we have three processes P1, P2 and P3. And all these three processes they share the same mailbox A. Like it is shown in this figure."}
{"text": " Now, process P sends a message to A, which is a mailbox, while both P2 and P3 execute a receive from A. So, which process will receive the message sent by P1? So, what it means here is that suppose the process P1 sends a message to the mailbox A."}
{"text": " And then these two processes P2 and P3, they both execute a receive operation. That means they are both trying to receive something from the mailbox. Now, the question is the message sent by P1, will it be received by P2 or will it be received by P3? Since both of them are executing the receive operation, which among them will receive this message that is sent by the process P1? So, that is the question that we have."}
{"text": " Now, let's see how we can answer this. So, the answer depends on which of the following methods we choose. So, there are a number of methods that we can choose in order to answer this question. So, the first method is allow a link to be associated with two processes at most."}
{"text": " So, we said that in indirect communication we are allowed to have more than two processes associated with a single link. But if this kind of a scenario happens which we just talked about, then it is better to associate two processes at most with a single link. So, that is what we can do. Allow a link to be associated with two processes at most."}
{"text": " So, when process p1, p2 and p3 share the same mailbox, instead of making them to share a single link, let there be only a single link between process p1 and p2. So, the messages sent by p1 will be received only by p2 since there is only one link associated with those two processes."}
{"text": " So, in that way we can solve the problem. That is the first method. Now, the second method is allow at most one process at a time to execute a receive operation. So, in the example that we saw, we saw that when process P1 was sending the message, both processes P2 and P3, they executed the receive operation at the same time. So, that is why this problem arose in the first place."}
{"text": " So, in order to avoid that what we can do is, we can allow only one process or at most one process to execute the receive operation at a time. So, we will allow only one process to execute the receive operation at a time. We will not allow more than one process to execute the receive operation at a time. So, in that way only that process which is executing the receive operation at that particular time will receive the message that is sent by the process."}
{"text": " So, in our example, if process P1, P2 and P3 are there sharing the same mailbox, and if P1 sends a message, then instead of letting P2 and P3 to both execute receive, we will allow only one of them to execute receive operation at a time. So, whichever process among them first executes the receive operation, that will receive the message sent by the process P1."}
{"text": " So, that is the second method that we can choose. Now, the third method is allow the system to select arbitrarily which process will receive the message. That is either P2 or P3 but not both will receive the message. And the system may also define an algorithm for selecting which process will receive the message. That is round robin where process takes turn receiving messages. The system may identify the receiver and the sender."}
{"text": " So, the third method says that we will allow the system to select which process will receive the message. So, like I said before, instead of letting both P2 and P3 to receive the message, we will let the system decide whether P2 or P3 should receive the message."}
{"text": " So, how will the system decide? So, the system can define an algorithm for selecting which process will receive the message. So, there are algorithms like round robin. So, when we go to the chapter of scheduling, we may learn this process of round robin scheduling in a detailed way."}
{"text": " But for now just understand that round robin is a way of choosing which process will receive the message in such a way that all the processes that want to receive the message will have their own turn at some point of time. So, there is a third method. The system will decide which process will receive the message."}
{"text": " So, those are the methods that we can follow if this kind of a scenario happens. Now, talking of the mailbox again, a mailbox may be owned either by a process or by the operating system. So, we were talking about the mailbox which is like an object into which the messages can be sent and from which the messages can be received or removed. Now, who is the owner of the mailbox? So, the mailbox can either be owned by the process"}
{"text": " or by the operating system. So, when a mailbox is owned by a process, then there is no confusion of who is the owner of that mailbox. The mailbox belongs to that particular process and there is no confusion of who should receive the message sent to that mailbox. If the mailbox belongs to a particular process, we know that all the messages that come into that mailbox is intended for that particular process."}
{"text": " But the problem is that when this process will terminate, this mailbox will also disappear. Because since the mailbox is owned by the process, when the process finishes its execution and when the process terminates, the mailbox associated with that process will also disappear. So, on the other hand, if the mailbox is owned by the operating system,"}
{"text": " then that mailbox has an existence of its own. And that mailbox can later be shared with the processes that wants to use it for sending or receiving the messages. And the operating system will take care of creating the mailboxes or deleting the mailboxes as and when required. So, that was about the mailbox associated with the indirect communication. So, we have discussed about the direct communication system and the indirect communication system in message passing."}
{"text": " And we also saw the issue of naming associated with these two methods. So, coming back to our first page, we see that this direct or indirect communication is what we have discussed. And the issue related to this which was naming was the other thing that we have discussed."}
{"text": " So, the remaining two methods which are synchronous or asynchronous communication and automatic or explicit buffering and the issues related with them which are synchronization and buffering will be discussed in part three of the message passing system which will be the next lecture. So, I hope this was clear to you. Thank you for watching and see you in the next one."}
{"text": " Okay. This is a lecture where complex numbers come in. It's, complex numbers have slipped into this course because even a real matrix can have complex eigenvalues. So we met complex numbers there as the eigenvalues and complex eigenvectors."}
{"text": " This is probably the last we have a lot of other things to do about eigenvalues and eigenvectors. And that will be mostly real. But at one point somewhere we have to see what do you do when the numbers become complex numbers. What happens when the vectors are complex, when the matrices are complex, when the what's the inner product of two, the dot product of two complex vectors,"}
{"text": " We just have to make the change. Just see, what is the change when numbers become complex? Then, can I tell you about the most important example of complex matrices? It comes in the Fourier matrix. So the Fourier matrix, which I'll describe, is a complex matrix. It's certainly the most important complex matrix. It's the matrix that we need in the Fourier transform."}
{"text": " And the really, the special thing that I want to tell you about is what's called the fast Fourier transform, and everybody refers to it as the FFT, and it's in all computers and it's used, it's being used as we speak in a thousand places, because it has, like, transformed whole industries to be able to do the Fourier transform fast."}
{"text": " which means multiplying, how do I multiply fast by that matrix, by that n by n matrix? Normally, multiplications by an n by n matrix would normally be n squared multiplications. Because I've got n squared entries and none of them is zero. This is a full matrix."}
{"text": " And it's a matrix with orthogonal columns. I mean, it's just, like, the best matrix. And this fast Fourier transform idea reduces this n squared, which was slowing up the calculation of Fourier transforms, down to n log n. n log n, log to the base two, actually. And it's this, when that hit."}
{"text": " When that possibility hit, it made a big difference. Everybody realized gradually what, that this simple idea, you'll see it's just a simple matrix factorization, but it changed everything. Okay. So I want to talk about complex vectors and matrices in general, recap a little bit from last time, and the Fourier matrix in particular. Okay."}
{"text": " So what's the deal? All right. The main point is, what about length? I'm given a vector, I have a vector x. Or let me call it z, as a reminder that it's complex for the moment. But I can, later I'll call the components x, they'll be complex numbers. But it's a vector z1, z2, down to zn."}
{"text": " So the only novelty is it's not in Rn anymore. It's in complex n-dimensional space. Each of those numbers is a complex number. So this z, z1 is in Cn, n-dimensional complex space instead of Rn. Just a different letter there. But now the point about its length is what?"}
{"text": " The point about its length is that Z transpose Z is no good. Z transpose Z, if I just put down Z transpose here, it would be Z1, Z2 to Zn. Doing that multiplication doesn't give me the right thing. Why not?"}
{"text": " the length squared should be positive. And if I multiply, suppose this is like one and I. What's the length of the vector with components one and I? What if I do this? So n is just two. I'm in C2, two-dimensional space, complex space, with the vector whose components are one and I. All right. So if I took one times one and I times I,"}
{"text": " and added z transpose z would be zero. But I don't, that vector is not, doesn't have length zero, the vector with components one and i. This multiplication, what I really want is z1 conjugate z1."}
{"text": " You remember that z1 conjugate z1 is so you see that first step will be z1 conjugate z1, which is the magnitude of z1 squared, which is what I want. That's like three squared or five squared. Now if it's if z1 is i, then i multiplied by minus i gives one."}
{"text": " plus one. So the component of length, the component I, its modulus squared is plus one. That's great. So what I want to do then is do that, I want z1 bar z1, z2 bar z2, zn bar zn. And remember that, you remember this complex conjugate. So there's the point. Now I can erase the no good and put is good."}
{"text": " Because that now gives the answer zero for the zero vector, of course, but it gives a positive length squared for any other vector. So it's a, it's the right definition of length. And essentially the message is that we're always going to be taking, when we transpose, we also take complex conjugate. So let's, let's find the length of one"}
{"text": " So the vector one i, that's z, that's that vector z. Now I take the conjugate of one is one, the conjugate of i is minus i, I take this vector, I get one plus one, I get two. So that's a vector, and that's a vector of length square root of two."}
{"text": " Square root of two is the length, and not the zero that we would have got from one minus i squared. Okay. So the message really is whenever we transpose, we also take conjugates. So here's a symbol, one symbol, to do both. So that symbol H, it stands for a guy named Hermite, who didn't actually pronounce the H, but"}
{"text": " Let's pronounce it. So I would call that Z Hermitian Z. Now, let me write that word Herm- so his name was Hermite and then we make it into an adjective Hermitian. So Z Hermitian Z, Z H Z. OK."}
{"text": " So that's the length squared. Now what's the inner product? Well, it should match. The inner product of two vectors, so inner product is no longer used to be y transpose x. That's for real vectors."}
{"text": " For complex vectors, whenever we transpose, we also take the conjugate. So it's y Hermitian x. Of course, it's not real anymore, usually. That the inner product will usually be complex number. But if y and x are the same, if they're the same z, then"}
{"text": " We have z H z, we have the length squared, and that's what we want. The inner product of a vector with itself should be its length squared. So this is, like, forced on us because this is forced on us. So this z, this, everybody's picking up what this equals. This is z1 squared plus zn squared."}
{"text": " That's the length squared. And that's the inner product that we have to go with. So it could be a complex number now. One more change. Well, two more changes. We've got to change the idea of a symmetric matrix. So I'll just recap on symmetric matrices. Symmetric means A transpose equals A."}
{"text": " But not, no good if A is complex. So what do we, what do we instead, if I, that applies perfectly to real matrices. But now if my matrices are complex, I want to take the transpose and the conjugate to equal A."}
{"text": " So that's the right complex version of symmetry. The symmetry now means when I transpose it, flip across the diagonal and take conjugates. So for example, here would be an example. On the diagonal, it had better be real, because when I flip it, the diagonal's still there."}
{"text": " And it has to -- and then when I take the complex conjugate, it has to be still there, so it better be a real number. Let me say two and five. What about entries off the diagonal? If this entry is, say, three plus i, then this entry had better be"}
{"text": " Because I want whatever this, when I transpose, it'll show up here, and I conjugate. So I need three minus I there. So there's a matrix with that's, that's the cor- that corresponds to symmetry, but it's complex. And those matrices are called Hermitian matrices. Hermitian matrices. A H equals A. Fine."}
{"text": " Okay, that's, and those matrices have real eigenvalues, and they have perpendicular eigenvectors. What does perpendicular mean? Perpendicular means the inner product, so let's go on to perpendicular. Well, when I had perpendicular vectors, for example, they were like q1, q2, up to qn."}
{"text": " That's my Q is my letter that I use for perpendicular. Actually, I also mean unit length. So those are perpendicular unit vectors. But now what is, so it's a orthonormal basis. I'll still use those words, but how do I compute perpendicular? How do I check perpendicular? This means that the inner product of Qi"}
{"text": " with qj, but now I not only transpose, I must conjugate, right? To get zero if i is not j and one if i is j. So it's a unit vector, meaning unit length, orthogonal, all the angles are right angles, but these are angles in complex n-dimensional space."}
{"text": " So it's q1, q1, q i bar transpose. Or, for short, q i h q j. So it will still be true. So let me, again, I'll create a matrix out of those guys. The matrix will have these q's in its columns, q2 to qn."}
{"text": " And I want to turn that into matrix language, just like before. What does that mean? That means I want all these inner products, so I take these columns of Q, multiply by their rows, so it was, it used to be Q, it used to be Q transpose Q equals I, right? This was an orthogonal matrix. But what's changed?"}
{"text": " These are now complex vectors. Their inner products involve conjugating the first factor. So it's the conjugate of Q transpose. It's Q bar transpose Q. Q H. So can I call this, let me call it Q H Q, which is I. So that's our new"}
{"text": " You see, I'm just translating, and the book on one page gives a little, like, dictionary of the right words in the real case, Rn, and the corresponding words in the complex case for the vector space Cn. Of course, Cn is a vector space. The numbers we multiply are now complex numbers. We're just moving into complex."}
{"text": " n-dimensional space. OK. Now, actually, I have to say, we change the word symmetric to Hermitian for those matrices. People also change this word orthogonal into another word that happens to be unitary as a word that applies"}
{"text": " that signals that we might be dealing with a complex matrix here. So what's a unitary matrix? It's just like an orthogonal matrix. It's a square n by n matrix with orthonormal columns, perpendicular columns, unit vectors, unit vectors computed"}
{"text": " by and perpendicularity computed by remembering that there's a conjugate as well as a transpose. Okay. So those are the words. Now I'm ready to get into the substance of the lecture, which is the most famous complex matrix, which happens to be one of these guys. It has orthogonal columns."}
{"text": " and it's named after Fourier because it comes into the Fourier transform, so it's the matrix that's all around us. Okay. Let me tell you what it is, first of all, in the n by n case. Then often I'll let n be four, because four is a good size to work with. But here's the n by n Fourier matrix."}
{"text": " Its first column is the vector of ones. It's n by n, of course. Its second column is the powers, actually, better if I move from the math department to EE for this one half hour, and then please let me move back again. OK. What's the difference between those two departments?"}
{"text": " Math starts counting with one, and electrical engineers start counting at zero. Actually, they're probably right. So anyway, we'll give them humor them. So this is really the zeroth column. And the first column up to the n minus one. That's the one inconvenience spot in electrical engineering. All these expressions start at zero, no problem, but they end at n minus one. Well."}
{"text": " That's the difficulty that course six has to deal with. So what's, they're the powers of a number that I'm going to call w. w squared, w cubed, w to the, now what is the w here? What's the power? This was the zeroth power, first power, second power, this will be n minus first power."}
{"text": " That's the column. What's the next column? It's the powers of w squared, w to the fourth, w to the sixth, w to the two, n minus one. And then more columns and more columns and more columns, and what's the last column? It's the powers"}
{"text": " of, let's see, actually, if we look along rows, this matrix is symmetric. It's symmetric in the old, not quite perfect way. Not perfect because these numbers are complex."}
{"text": " And so it's that first row is all ones. One w w squared up to w to the n minus one. That's the, the last column is the powers of w to the n minus one, so this guy matches that, and finally we get w to something here. I guess we could actually figure out what that something is. What are the entries of this matrix? The i j entry."}
{"text": " of this matrix, are you going to allow me to let i go from zero to n-1? So i and j go from zero to n-1. So the one, the zero, zero entry is a one. It's just this same w guy to the power i times j."}
{"text": " Let's see, I'm jumping into formulas here and I have to tell you what w is and then you know everything about this matrix. So w is the -- well, shall we finish here? What was this? This is the n-1, n-1 entry. This is w to the n-1 squared. Everything's looking like a mess here. Because we have -- not too bad, because all the entries are powers of w."}
{"text": " None of them are zero. This is a full matrix. But w is a very special number. w is the special number whose n-th power is one. In fact, well, actually there are n numbers like that. One of them is one, of course. But the one we, the w we want is the angle is"}
{"text": " 2pi over n. Is that what I mean? n over 2pi. No, 2pi over n. w is e to the i, and the angle is 2pi over n. Right. Where is this w in the complex plane?"}
{"text": " It's on the unit circle, right? It's the cosine of two pi over n plus i times the sine of two pi over n. But actually, forget this. It's never good to work with the real and imaginary parts, the rectangular coordinates, when we're taking powers."}
{"text": " To take that to the tenth power, we can't see what we're doing. To take this form to the tenth power, we see immediately what we're doing. It would be e to the i twenty pi over n. So when our matrix is full of powers, so it's this formula, and where is this on the complex plane? Here are the real numbers, here's the imaginary axis, here's the unit circle of radius one, and this number is on the unit circle,"}
{"text": " at this angle, which is one-nth of the full way around. So if I drew, for example, n equals six, this would be e to the two pi, two pi over six, it would be one-sixth of the way around, it'd be sixty degrees. And where is w squared? So I, I, I, I, my w is e to the two pi i over six."}
{"text": " in this case, for the six by six Fourier transform, it's totally constructed out of this number and its powers. So what are its powers? Well, its powers are on the unit circle, right? Because when I square a number, a complex number, I square its absolute value, which gives me one again."}
{"text": " All the powers have, are on the unit circle. And they, the angle gets doubled to 120, so there's w squared, there's w cubed, there's w to the fourth, there's w to the fifth, and there is w to the sixth, as we hoped, w to the sixth coming back to one. So those are the sixths."}
{"text": " Can I say this on TV? The sixth roots of one, and it's this one, that primitive one, we say, the first one, which is w. Okay. So what, let me change, let me, I said I would probably switch to n equal four. What's w for that? It's the fourth root of one. w to the fourth will be one."}
{"text": " w will be e to the 2pi i over four now. What's that? This is e to the i pi over two. This is a quarter of the way around the unit circle, and that's exactly i, a quarter of the way around."}
{"text": " And sure enough, the powers are i, i squared, which is minus one, i cubed, which is minus i, and finally i to the fourth, which is one, right. So there's w, w squared, w cubed, w to the fourth. I'm really ready to write down this Fourier matrix for the four by four case, just so we see that clearly. Let me do it here. F4."}
{"text": " is. All right, one, one, one, one, one, one, one. W. Ah, it's I. I squared. That's minus one. I cubed is minus I. I could write I squared and I cubed. Why don't I, just so we see the pattern for sure. I squared, I cubed, I squared, I cubed, I fourth, I sixth,"}
{"text": " i4, i6, and i9. You see the exponents fall in this nice, the exponent is the row number times the column number, always starting at zero. Okay."}
{"text": " And now I can put in those numbers if you like. 1 1 1 1, 1 i minus 1 minus i, 1 minus 1 1 minus 1, and 1 minus i minus 1 i. No. Yes. Right."}
{"text": " What's, why do I think that matrix is so remarkable? It's the four by four matrix that comes into the four-point Fourier transform. When we want to find the Fourier transform, the four-point Fourier transform of a vector with four components, we want to multiply by this F4, or we want to multiply by F4 inverse."}
{"text": " One way we're taking the transform, one way we're taking the inverse transform. Actually, they're so close that it's easy to confuse the two. The inverse of this matrix will be a nice matrix also. So and that's, of course, what makes it that that I guess Fourier knew that. He knew the inverse of this matrix."}
{"text": " As you'll see, it just comes from the fact that the columns are orthogonal. From the fact that the columns are orthogonal, we will quickly figure out what is the inverse. What Fourier didn't know, didn't notice, I think Gauss noticed it, but didn't make a point of it, and then it turned out to be really important"}
{"text": " was the fact that this matrix is so special that you can break it up into nice pieces with lots of zeros, factors that have lots of zeros and multiply by it or by its inverse very, very fast. OK. But how did it get into this lecture first? Because the columns are orthogonal. Can I just check that the columns of this matrix are orthogonal?"}
{"text": " So the inner product of that column with that column is zero. The inner product of column one with column three is zero. How about the inner product of two and four? Can I take the inner product of column two"}
{"text": " with column four, or even the inner product of two with three. Let's, let's see, does that, let, let me do two and four. OK. What, oh, I see, yes, hm, hm."}
{"text": " See, I believe that those two columns are orthogonal. So let me take their inner product and hope to get zero. Okay, now if you hadn't listened to the first half of this lecture, when you took the inner product of that with that, you would have multiplied one by one, i by minus i, and that would have given you one."}
{"text": " minus one by minus one would have given you another one, minus i by i would have been minus i squared, that's another one. So do I conclude that the inner product of columns -- I said columns two and four, that's because I forgot those are columns one and three. I'm interested in their inner product and I'm hoping it's zero, but it doesn't look like zero."}
{"text": " Nevertheless, it is zero. Those columns are perpendicular. Why? Because the inner product, we conjugate. You remember that one of the vectors in the inner product has to get conjugated. So when I conjugate it, it changes that i to a minus i, changes this to a plus i, changes those, that second sign and that fourth sign, and I do get zero."}
{"text": " So those columns are orthogonal. So columns are orthogonal. They're not quite orthonormal, but I could fix that easily. They all, those columns, have length two. Length squared is four."}
{"text": " like this, the four I had there, this length squared, one plus one squared, one squared, one squared, one squared is four, square root is two. So if I really wanted them, suppose I really wanted to fix life up perfectly, I could divide by two, and now I have columns that are actually orthonormal. So what?"}
{"text": " So I can invert right away, right? Orthonormal columns means, now I'm keeping this one half in here for the moment, means F4 Hermitian, can I use that? Conjugate transpose, times F4 is I. So I see what the inverse is."}
{"text": " The inverse of F4 is, it's just like an orthogonal matrix. The inverse is the transpose, here the inverse is the conjugate transpose. So, fine. That, that tells me that anything's good that I learn about F4, I'll know the same, I'll know a similar fact about its inverse, because its inverse is just its conjugate transpose. Okay, now, so what's good?"}
{"text": " Well, first, the columns are orthogonal. That's a key fact. That's the thing that makes the inverse easy. But what property is it that leads to the fast Fourier transform? So now I'm going to talk in these last minutes about the fast Fourier transform. Here's the idea. F6, our six by six matrix, will c-"}
{"text": " There's a neat connection to F3, half as big. There's a connection of F8 to F4. There's a connection of F64 to F32. Shall I write down what that connection is? What's the connection of F64 to F32? So F64 is a 64 by 64 matrix."}
{"text": " whose w is the sixty-fourth root of one. So it's one sixty-fourth of the way around in F64. And F32 is a thirty-two by thirty-two matrix. Remember, they're different sizes. And the w in that thirty-two by thirty-two matrix is the thirty-second root of one, which is twice as far. See that key point."}
{"text": " That's the, that's how thirty-two and sixty-four are connected, in the W's. The W for sixty-four is one sixty-fourth of the way, so all I'm saying is that if I square the W, W sixty-four, that's what I'm using for the one over, W sixty, this is Wn,"}
{"text": " is e to the i 2pi over n, so W64 is one-sixty-fourth of the way around it. When I square that, what do I get but W32. Right? If I square this matrix, I double the angle, if I square this number, I double the angle, I get the W32."}
{"text": " So somehow there's a little hope here, to connect F64 with F32. And here's the connection. OK. Let me, let me go back, yeah, let me, I'll do it here. Here's the connection. F64, the 64 by 64 Fourier matrix, is connected to two copies of F32."}
{"text": " Let me leave a little space for the connection. So this is sixty-four by sixty-four. Here's a matrix of that same size, because it's got two copies of F thirty-two and two zero matrices. Those zero matrices are the key."}
{"text": " Because when I multiply by this matrix, just as it is, regular multiplication, I would take need sixty-four, I would have sixty-four squared little multiplications to do. But this matrix is half zero. Well, of course, the two aren't equal. I'm going to put an equal sign, but there has to be some fix-up factors, one there and one there, to make it true."}
{"text": " The beauty is that these fix-up factors will be really almost all zeros. So that as soon as we get this formula right, we've got a great idea for how to get from the six- from the sixty-four squared calculations. So this originals- originally we have sixty-four squared calculations from there, but this one,"}
{"text": " will give us, this is, this will, we don't need that many. We only need two times thirty-two squared, because we've got that twice, and plus the fix-up. So I have to tell you what's in this fix-up matrix. The one on the right is actually a permutation matrix, a very simple odds and evens permutation matrix. The, the, the ones show up."}
{"text": " I haven't put enough ones, I really need thirty-two of these guys, a double space, and then you see it's a permutation matrix. What it does, shall I call it P for permutation matrix? So what that P does, when it multiplies a vector,"}
{"text": " It takes the odd, the even-numbered components first and then the odds. You see this, this one skipping every time is going to pick out x0, x2, x4, x6, and then below that will come, it will pick out x1, x3, x5. And of course, that can be hardwired in the computer to be instantaneous."}
{"text": " says, so far, what have we said? We're saying that the sixty-four by sixty-four Fourier matrix is really separate your vector into the odd, into the even components and the odd components, then do a thirty-two size Fourier transform on those separately."}
{"text": " and then put the pieces together again. So the pieces, putting them together, turns out to be I and a diagonal matrix and I and a minus, that same diagonal matrix. So the fix-up cost is really the cost of multiplying by D, this diagonal matrix."}
{"text": " because there's essentially no cost in the I part or in the permutation part, so really it's the fix-up cost is essentially, because D is diagonal, is thirty-two multiplications. That's the, there you're seeing, of course we didn't check the formula or we didn't even say what D is yet, but I will."}
{"text": " This diagonal matrix D is powers of w. One, w, w squared, down to w to the thirty-first. So you see that when I, to do a multiplication by D, I need to do thirty-two multiplications. There they are."}
{"text": " Then, but the other, the more serious work is to do the F thirty-two twice on the, separately on the even-numbered and odd-numbered components, so twice thirty-two squared. So sixty-four squared is gone now. And that's the new count. Okay, great. But what next? So that's, we now have the key idea"}
{"text": " We would have to check the algebra, but it's just, checking a lot of sums that come out correctly. This is right, the right way to see the fast Fourier transform, or one right way to see it. Then you've got to see what's the next idea. The next idea is to break the thirty-twos down."}
{"text": " Break those thirty-twos down. So we have this factor and now we have the F thirty-two, but that breaks into some guy here, F thirty- F six- F sixteen, F sixteen. Each F thirty-two is breaking into two copies of F sixteen. And then we have a permutation and then the"}
{"text": " So this is a, like, this was a 64-size permutation, this is a 32-size permutation. Ah, I guess I've got it twice, because I'm, I'm just using the same idea recursively. Recursion is the key word. That on each of those F32, so here's zero, zero, it's just, to get F32, this is the odd-even permutations,"}
{"text": " So you see we're, the combination of those permutations, what's it doing? This guy separates into odds and, into evens and odds, and then this guy separates the evens into the ones, the numbers that mul- the even evens, which means zero, four, eight, sixteen. And even odds, which means two, six,"}
{"text": " ten, fourteen, and then odd-evens and odd-odds. You see, together these permutations then break it, break our vector down into x, even-even, and three other pieces. Those are the four pieces that separately get multiplied by f sixteen, separately fixed up by these i's and d's and i's and minus d's,"}
{"text": " So this count is now reduced. This count is now, what's it reduced to? So that's going to be gone. Because thirty-two squared, that's the change I'm making, right? The thirty-two squared, so it's this that's now reduced. So I still have two times it, but now what's thirty-two squared? It's gone in favor of two sixteen squareds,"}
{"text": " plus sixteen. That's ins- that- that was- and- and then the original, thirty-two to fix. Maybe you see what's happening even easier than this formula is. What's- when I do the recursion more and more times, I get simpler and simpler factors in the middle. Eventually I'll be down to two point or one point Fourier transforms."}
{"text": " But I get more and more factors piling up on the right and left. On the right, I'm just getting permutation matrices. On the left, I'm getting these guys, these I's and D's, so that there was a thirty-two there and a thir- each one of these is costing thirty-two. Each one of those is costing thirty-two. And how many will there be? See the thirty-two for this original fix-up, because D had thirty-two numbers."}
{"text": " 32 for this next fixup, because d is 16 and 16 more. I keep going, so the count in the middle goes down to zip, but these fixup counts are all that I'm left with. And how many factors, how many fixups have I got? Log n."}
{"text": " from sixty-four, one step to thirty-two, one step to sixteen, one step to eight, four, two and one. Six steps, so I have six fixed up factors. Finally, I get to six times the thirty-two. That's my final count. Instead of sixty-four squared, this is log"}
{"text": " to the base two of sixty-four times sixty-four, actually half of sixty-four. So actually the final count is n log to the base two of n, that's the thirty-two, ah, a half. So can I put a box around that wonderful, extremely important and satisfying conclusion?"}
{"text": " that the fast Fourier transform multiplies by an n by n matrix, but it does it not in n squared steps, but in one half n log n steps. And if we just complete by doing a count, let's suppose a typical case would be two to the tenth. Now, n squared."}
{"text": " is bigger than a million. So it's 1,024 times 1,024. But what is n, what is one half, what is the new count done the right way? It's n, the 1,024, times one half, and what's the logarithm? It's ten."}
{"text": " So times ten over two. So it's five times, it's five times 1,024, where this one was 1,024 times 1,024. We've reduced the calculation by a factor of 200 just by factoring the matrix properly. This was 1,000 times n, we're now down to five times n."}
{"text": " So we can do 200 Fourier transforms, where before we could do one, and in real scientific calculations where Fourier transforms are happening all the time, we're saving a factor of 200 in one of the major steps of modern scientific computing. So that's the idea of the fast Fourier transform, and you see the whole thing hinged on being a special,"}
{"text": " matrix with orthonormal columns. OK. That's actually it for complex numbers. I'm back next time really to real numbers, eigenvalues and eigenvectors, and the key idea of positive definite matrices is going to show up."}
{"text": " What's a positive definite matrix? And it's terrific that this course is going to reach positive definiteness, because those are the matrices that you see the most in applications. Okay. See you next time. Thanks."}
{"text": " Okay, that was interesting. So don't use HDMI 2 in this room, it just randomly dies. Cool."}
{"text": " All right, so we're back. So our SATP pointer, that pointed us to the highest level page table. In this case, it was where L2 is. And then that's all the information we need to actually translate a virtual address. So we just keep following them, following them, following them, until we eventually get to L0. And then that's just exactly how we treat"}
{"text": " single large page table that has the translation in it. And we just substitute in the physical page number for the virtual page number, keep our offsets the same, and we're all good. So streamed down, so hopefully it works. Yeah, so any questions about what we did yesterday? Yep? So like, the multi-level page implementation,"}
{"text": " Yeah, so its main advantage is the size efficiency."}
{"text": " Before, when we had a single big page table, it was like 1 gigabyte. Here, to translate a single address, we need just only three of these smaller level page tables. So instead of 1 gigabyte, well, each of these fit exactly on a page. So we have three pages, which are 4,096 bytes each. So this would be, what, 12 kilobytes to translate as address, as opposed to just 1 gigabyte."}
{"text": " Apparently that is not back up, so I'll have to upload the lecture later. OK, sorry. All right, room's cursed. Sweet."}
{"text": " So last time the internet dropped, I've only ever had problems in this room. So it's just cursed. All right. So quick aside. So who here has heard the term alignment before?"}
{"text": " Have we heard? So one person I know that took the advanced version of this course. So just so you know, if they haven't taught you this before, alignment is something we care really, really a lot about, especially when you're implementing hardware and using low-level code. So alignment just means that everything of the same size eventually lines up with byte 0. Yep? AUDIENCE 2. On this slide, that object, uploader? Yeah."}
{"text": " Oh, they're not uploaded? OK, I'll fix the slides after the lecture. I had to upload them like 10,000 times on the train because my internet kept cutting out. So I guess it just decided to do something weird. So I'll fix it after the lecture. So yeah, sorry about that. So today's so far been a disaster, so great. So let's hope it doesn't continue."}
{"text": " So in this case, what alignment means that if I have pages and I say that they are 4,096 byte aligned in memory, it means they always start with all the lower 12 bits being zero. And we like that in computing because we could start the pages wherever we wanted, but it would actually make our lives a lot more complicated. For instance, I could start a page at just address like 7C00, and then"}
{"text": " If you go to the last byte on the page, which would be 4,095 bytes later, the last byte would be at address 8BFF, which is a bit weird because ideally we would like, if we know we're on page 7, it'd just be nicer if it just started at"}
{"text": " with all the 12 bits being 0. So it would start at 7, 0, 0, 0. And that way, it would end at 7, F, F, F, instead of being like a weird thing where it's 7, C, 0, 0, and ends at 8, B, F, F. It just makes our lives a lot easier. You can glance at it. You can know it's on the same page. And that's what we mean by alignment. The offset 0 of that page corresponds with all the 12 bits being 0, 0."}
{"text": " So the question is that, well, if I wanted to do something like, hey, I want everything to be 8-byte aligned, which for some systems, you actually want your memory to be like 8-byte aligned or instructions or whatever. So you should be able to say, hey, is address something like EC 8-byte aligned, yes or no? So who thinks that is 8-byte aligned? Who thinks it is not?"}
{"text": " Who thinks, what the hell are you talking about? All right. What the hell are you talking about?"}
{"text": " 8-byte aligned, you can think of that if you start at index 0 at byte 0, that no matter how far you go up, you are always at boundaries of 8 bytes. So if everything is aligned, it would either start at byte 0, byte 8, 16, 24, 32, so on and so forth. So it basically just means it's divisible. Yep."}
{"text": " 10 dot 7, and then it's followed by 4F. Is this a typo? It's supposed to be 7 followed by 3F? Yeah, sorry. That should be 7 followed by 3F. So I'll fix that when I upload the slides. Yeah, I got a bit too friendly with my F key. All right, so in that case, if things are 8-byte aligned, well, that means, again, it should start at either"}
{"text": " 0, 8, 16, so on and so forth. So if this is 8 by the line, then it would be nicely divisible by 8. The remainder would be 0. In this case, it's not if you can actually read like hex or just throw that into a calculator on the internet."}
{"text": " One quick way you can see if it's 8-bit aligned is, well, so, or 8-byte aligned is, go back, so we'll do that later, so if we're 8-byte aligned,"}
{"text": " Another way of expressing that on a computer, well, just means that all of the lower bits we need to represent, this are all 0 all the time. So 8 is 2 to the power of 3. So we would need our three lower bits to all be 0. So 0, 0, 0."}
{"text": " And if they are all 0, that would be on one of those boundaries. So you can double check this by, you know, it's the same thing as it being exactly divisible by. So in this case, valid addresses would be something like, if we fill up the rest with 0's, well, a valid address that would be 8 by the line would be 0."}
{"text": " Next one would just be incrementing anything except the lower three bits. So the next one would be something like this, which would be 0, 8, which makes sense. That's 8. And then the next one would be something like this."}
{"text": " And that would be address 1, 0, or in plain decimal, that's 16. So those would all be valid addresses that are 8-byte aligned. So 0, 8, da, da, da, da, da. And if you write this out, you can even notice a pattern here."}
{"text": " So either the last hex digit will either be a 0 or an 8 if it is 8-byte aligned. So does that make sense to everybody? So if that's the case, it doesn't even matter what the rest of them are. So we can look at this and see if we have the address EC, we can look and immediately know, hey, it's not a 0 or a 8. So it is not 8-byte aligned. So does that make sense to everyone?"}
{"text": " So same thing with pages. We want pages to be aligned at that page boundary so we don't have to monkey with anything. Everything is nice, aligned at zero. Everything lines up nicely. So with that in mind, let's simulate an MMU and actually create our own page tables and monkey around with it and break it. Everyone likes breaking stuff. So in this case,"}
{"text": " That whole translation of going through all the page tables isn't really that difficult. All there is."}
{"text": " is you just have a for loop, and you monkey with bits. You don't have to really care about this that much. But basically, all it does is shift the bits around to remember our formatting for the page table entry, like the lower 10 bits were all had to do with the flags, da, da, da. So that's all this is doing."}
{"text": " and pulling out the physical page number, which is 44 bits, and then monkeying with it. So we don't have to read that. And the few other functions it does is we can allocate pages, and they will be page aligned. So all their lower 12 bits will all be 0. So you can request a page from the kernel, and it guarantees that they're aligned. So with that,"}
{"text": " To set up a page table, all we have to do to go ahead and translate an address is we create a L2 page table. So we're going to assume three levels of page tables. Yep. Yep. Did no one see anything I did yesterday?"}
{"text": " Yeah, so yeah, sorry. So this code is in the lecture 14 one, because it was related to yesterday, and I ran out of time yesterday. So I was going to do it, but we're doing it now. Yeah, so sorry. This is the lecture 14 directory, and this is 15."}
{"text": " OK, so to do this, we allocate a page. And we're going to use that page we got for an L2 page table, which is our big one. And the only thing our MMU needs to resolve an address is we have to set a root page table. And here, I have a global variable that tells me what page the root page table is on. So that's all that does."}
{"text": " So in order to resolve an address, I need at least an L1 page table, an L2, and an L0. So I would allocate a L1 page table, which would return me a new page. And then I use it for whatever I want. In this case, I need to have an entry in my L2 page table. And I want to resolve an address. So I'll just put it at index 0 for now."}
{"text": " because the address I want to translate is ABCEDF. So if this is my address I need to translate, well, we can figure out what indexes this would use. It wouldn't have to translate the last three hex characters, because that's the offset onto the page, because we're assuming our normal page size of 4,096, so we don't need to touch that."}
{"text": " So the upper part of address for the whole virtual page number is ABC. And if we go ahead and let's go ahead and write that out in binary, because everyone loves doing that. And if I do that."}
{"text": " A, B, C in binary at the top, C is 1, 1, 0, 0. Then B is 1, 0, 1, 1. And A is the one you should know off the top of your head. It's 1, 0, 1, 0. Like 10, 10, lots of fun. So if you do that, you can write out those 12 bits. And then you can start grouping the indices. And they are in groups of nine."}
{"text": " So we start at the back. And our first group of 9 is here. That would be what we use for our L0 index. And then the next group of 9 would be here. And I just won't write the leading 0's. But if you write something like that, you assume leading 0's for the rest of it. So that's what we would use for L1 index. And then our L2 index would, of course, just be a bunch of 0's."}
{"text": " So if we are trying to resolve the address A, B, C as the virtual page number, well, we would first look at index 0 in our L2 page table. Then whatever that entry points us to, we use it as our L1 page table. In the L1 page table, what index would we look at? Or in other words, what is 010 in decimal?"}
{"text": " You can show me on one hand. I see one, five, right? Oh, do we not remember all our binary? So easy way to do it is if you, it's like, remember back in like grade three when they taught you like the tens columns, the hundreds columns and all that? It's the exact same thing. Yeah. One zero is one."}
{"text": " Whatever I've written up there. Oh, I just said the wrong thing? Yeah, I wrote the right thing. Sorry. OK. So OK. Woo. OK. I thought we were going back to grade three. So 1, 0, 1, sorry, is just 5. So our L1 index is 5. All right. Let's see. I'll say this correctly. What is 0, 1, 0, 1, 1, 1, 1, 0, 0 in decimal? Who's that fast?"}
{"text": " 188. Yeah, so the astute among you would have realized that I already wrote it out here. So I want this to resolve, so I already wrote it out here. So all that is hopefully."}
{"text": " 188. So first, it would look at the L2 page table at index 0, then use that as the L1 page table, look at index 5 there, and then that would find the L0. And then from the L0, it would look at index 188, and then that's where it would pull the physical page number from and just replace it, and then our translation's done."}
{"text": " If we go back to here, at this point right here, we have an L2 page table, but it's just full of zeros, which doesn't help us. That essentially means everything is invalid, so there's no entries in it."}
{"text": " And then we create an L1 page table, and we need to create it before we can point to it, right? So we create an L1 page table, and then we create an entry in our L2 page table at index 0, because when we resolve this address, that's the page table we're going to look at. And all this PTE from page table does is set the valid bit for the page table entry, and"}
{"text": " take this page table, which would be nicely aligned at the page boundaries, and just chop off the offset, because we don't need it, because we use that. We know we use that as basically a big array. And it would stuff the physical page number of that page table into there, so we can use it."}
{"text": " So then we have to go one level deeper. So we create an L0 page table. Again, it would be allocated, be nothing. And then in our L1, we create an entry for index 5, which points to that L0 page table we just made. And then in the L0 page table, we create an entry for 188."}
{"text": " And we just get the page table entry from the physical page number. And we want to translate physical page number C-A-F-E. So if we do that, hopefully when we translate this virtual address A-B-C-D-E-F, what should we get? Yep. What is the actual address?"}
{"text": " Can anyone tell me the actual address we would get at the end of all this? Cafe? It would start with cafe, yep. Yeah, cafe, then D-E-F, right? So to translate it."}
{"text": " We don't have to translate DEF, because that's our part of the offset. So we don't translate that. And as soon as we follow through all the steps, basically, we replace ABC with whatever physical page number this is. So we should get CAFE and then DEF. So any questions about how I got that?"}
{"text": " OK, so let's simulate, make sure it works. So I'll also make up another address, which is 1, A, B, C, E, D, F. And by default, all the page tables should have are just full of zeros. So they would all have invalid entries. So if I try and resolve this address, it should page fault, which means I can't translate the address because it's not valid. So if I go ahead and do that, build MMU sim,"}
{"text": " I can see that translated address a, b, c, d, e, f to c, a, f, e, d, e, f. And then when I translated one a, b, c, d, e, f, I got a page fault, which means it didn't translate properly because I didn't have any valid entries. So does that kind of make sense to anyone? Yep. So as part of the page table entry,"}
{"text": " One of the flag bits is a valid bit. So by default, when you get a page, it's all zeros. So all the entries would appear as invalid. So if I try and resolve it, it would be like, OK, that's not valid. So I wouldn't follow that memory. It doesn't lead me anywhere. Yep."}
{"text": " So the question is, why didn't I get a page fault for the first address? And I didn't get a page fault for the first address, the A, B, C, D, E, F, because when I would translate that, I have to follow it like this, right? 0, like, given an L2 page table, I look at index 0. I find the L1 from that. Then I look at index 5. And then I would look at index 188."}
{"text": " And then if that is valid, then I can actually translate the address. Right? Oh, OK. Yeah. So the question is for this, it looks like I didn't set valid from address. But this PTE from page table, it sets that. It basically makes a page table entry that's valid."}
{"text": " Yeah, so as part of this, this entry would contain a valid page table entry."}
{"text": " And either you could trust me, or we can look at the code. So here, the PTE from PPN, like the little helper function, all it does is takes the physical page number, shifts it over 10 bits, and then sets valid. And PTE valid is just 1. So this sets the lowest bit as 1, which means valid."}
{"text": " Yeah, so what happens with, yeah, so let's go over why there's a page fault at one A, B, C, D. So can anyone off the top of their head tell me why there would be a page fault there? Like, where did I screw up? Or where does it fail? Yep. I think the one would also get interpreted as part of the L1 index. Yep. So it wouldn't be, I think it's five anymore, and so now it's not"}
{"text": " Yeah. Yeah. Yep. So here, let's go over that quick. Oops. Hi, Doug. So if we change the virtual address to instead be one A, B, C, D, E, F, well, the rest of it, thankfully, stays the same. But the lowest bit is now, whoops."}
{"text": " But now we have a 1. So 1. And it would go right here. And it still fits within that L1 index. So now we change our L1 index. So yeah. Whoops. I wrote my line bad. There. So if I have a 1 in front of it, well, that just means that 1 is set if I just add it."}
{"text": " So now my L1 index is no longer 5. What is it? 13. Everyone got 13? Yeah. So now my L1 index for this address is 13. So if we tried to translate it, well, if we try and translate it now, its L2 index is still 0. So it would still follow it to this L1 page table."}
{"text": " But in the L1 page table, the entry for 13 is just invalid, because we never set it to be anything. So it would just stop there. So it's invalid. It would stop, then generate a page fault, which basically just means that, hey, I can't translate this anymore. So, yep. Yeah."}
{"text": " like when you power off your machine, do you have to set all the valve bits to zero or ramp when it powers up?"}
{"text": " Oh, OK, so yeah, the question is, when you shut off your machine, do you have to save everything? So RAM's volatile, so everything gets wiped. So as part of the initialization process, when you boot up your computer, well, the kernel's going to have to set up page tables like this, and it's going to have to zero everything. So it would have to zero it as part of everything being invalid. So if you're going to use a page for a page table, well, you"}
{"text": " By default, you just want a page of all zeros, which is all invalid, and then you can fill it in as you go. So what would I do if I want, let's make one ABCDEF translate to something more fun. So how would I make it translate to, I don't know, let's say like feed DEF. So how would I go about doing that?"}
{"text": " Yep. So if I go back here for this address, 1abcdf, it's L0 index is actually still the same, right? It's 188. So I must have to do something else. So where is the first index that's different?"}
{"text": " Yeah, so it's the L1 index is where it changes first, because it would start at L2, translate to L1. And then here in the L1, our index is different. So we're going to have to start by making that valid. Yep."}
{"text": " Yeah, so in this case, we would need to create a new L0 table because we need to point to something. So we would have to go ahead and create a new L0 table. I will be super creative and call it"}
{"text": " L0 page table 2, because I'm just that creative. And then in here, we essentially would just make entry 13 point to that new page table we just have. So now it points to a different L0 page table. And this is where it would follow if it's translating 1, A, B, C, D, E, F. Any questions about that? So now as the final step to the puzzle,"}
{"text": " All I would have to do is in the new L2 page table, it would be located at the same index. But I just need to change it to whatever I want. What did I say? I want it to be feed or face. Let's go with face. Face is fun. So if I change it to face now, should I get a valid address out of one A, B, C, D, E, F? Hopefully. What will it be? Face, E, D, F."}
{"text": " Everyone got that? So let's make sure we didn't screw up. So if we do that, then look, hey, yay. So we translated the address. So we could also do weird things if we really wanted to. So instead of here,"}
{"text": " They point to different L0 page tables, but there's no reason why I couldn't, if you wanted to, just point them to the same L1 page table. So if I do that, what's going to be the result if I translate both the addresses? Yeah, for both of them, they're going to be CAFE EDF, because they're essentially pointing at the same thing, right?"}
{"text": " So then two virtual addresses actually translate to the same physical address, in which case you might have two different variables. And if you change one, it changes the other that you thought was independent. And you could also do really weird things, like you could map this."}
{"text": " differently in different processes. So one process points to the same piece of memory that another process points to, and they both point to the same physical piece of memory from two different virtual addresses. So that's something you could do. Generally, you probably don't want that to happen by default and just point to random memory. But if you want to share memory, well, that's the mechanism that the kernel would do to share memory, is they would just make you point to the same physical page as someone else."}
{"text": " So, I guess bonus question. So, let's change this back. And let's change this address to be, I don't know, let's just 007. So, will this resolve to an address 1ABCD007?"}
{"text": " I see some shaking. So what address would that translate to now? Yeah. Yeah, face007. So let's verify that that works. So in this case, it would work because it's on the same virtual page."}
{"text": " No matter what you change the offset to, it's still on the same page. So all those addresses are going to be valid. So as soon as you have one entry, it's valid for every address on the page. We're all good. So any questions about that? Hopefully that is clear. Sweet. All right. Now to go on to fun stuff."}
{"text": " So here's some more questions you could get, like typical questions on exams, like how many page tables do we need? And this is also good for programs like this. So if we want to resolve one address, even if it's on multiple pages, well, we need at least three page tables if we have three levels of page tables. So that's the minimum I need to resolve any single address."}
{"text": " Well, you could say that assume our program uses 512 pages. Well, questions you could ask is, what's the minimum number of page tables we need, and what's the maximum number of page tables we need? All right. Any guesses? Yep."}
{"text": " So just one L0, right? So for one address, we'd need at least three. So I guess minimum for 512 entries would be three then, right? OK. What about maximum? OK, I see a confused face. So let's go over why you would, at minimum, need three page tables to translate 512 pages."}
{"text": " So let's go through here. So one way we could have it is, well, to translate, let's start with one address. So to translate one address or one page, we would have our L2 page table. It would have exactly one entry."}
{"text": " that points to another. Then inside here, it would have exactly one entry that points to another. And then that would actually have the entry that we use. So this is what we had. And we could translate everything on that page. So if we got really lucky, how many entries can this label them? How many entries does this L0 page table have?"}
{"text": " Yeah. Yeah, so this has 500 and, whoops, that is not 512. So this is 512 entries. So what we could do with only three page tables is we could just fill this bad boy up with 512 entries. Yep."}
{"text": " So you have to start at an L2. If you have three levels of page tables, you have to start at an L2. You have to start somewhere. But if we just need to map to 512 page tables, then can't we just do a direct map of our virtual page numbers?"}
{"text": " No, because the hardware, if you're using three page tables, like three levels of page tables, it needs to step through three levels. So what you could do, which would be super screwed up, is, well, if you have a single L2 page table, I guess you could point to yourself. But you probably don't want to do that. And if you point to yourself, you're using an entry for yourself, and really bad things can happen. Yeah?"}
{"text": " So if we need, so it's just a system design question. So how many levels we need just depends on how big of a virtual address we want to support."}
{"text": " And that's it. So in this case, it's like 39-bit virtual addresses. So it has to be three levels of page tables. And that's it. Yeah. Yeah. So we're stuck with three levels. We can't get rid of three levels. A minimum have to have three levels."}
{"text": " So if we get really lucky, well, in our L2 page table, it could point to a single L1. And then that L1 points to an L0. And that L0 is just full of entries. It has 512 entries. So it can actually map 512 different pages, right? So what would happen if I can't fill up that table? So my best case is I can fill up my L1 table with 512 entries. What's my worst case?"}
{"text": " Yeah, my, yep. Three times 512. Everyone agree with three times 512? Yep."}
{"text": " Like, can't you just add more and more and more, like empty ones? Not counting empty ones. Yeah, so our worst case would probably be each L0 page table has exactly one entry. That would probably be the most wasteful thing we could do, aside from just allocating empty ones and just being like, yeah, screw you guys. So if our worst case is we have an L"}
{"text": " 0 with exactly one entry on it. Whoops, that's not how you spell that. Well, how many of those would I actually need to support 512 different mappings? So yeah. Yeah, so I would need 512 L1 page tables. Each one has exactly one entry. So if I wanted to make this bad, well,"}
{"text": " In my L0 table, I could, because there's 512, if I was really good or really lucky, I could fill this up with 512 entries and support pointing to all those L0 page tables. Or since we're talking about the worst case, well, this could also only have one entry per. So if I go back and I just do one entry per in my L1,"}
{"text": " Well, I have to point to at least 512 L0 page tables. So I also need 512 of these. I need 512 L1 page tables. In the worst case, they'd all have one entry each. So everyone, you have to make this joke. Everyone on the same page with that one? OK, terrible. All right. How many L0 page table or L2 page tables do I need?"}
{"text": " 512, I see a one. All right, one, one's in the chat. Two people, all right, 512. Like three people, great. All right, so."}
{"text": " For the L2 page table, remember that's our starting point. So we have to be given an L2 page table. And since it's your starting point, you only have one of them. So it needs to start somewhere. So our L2 page table would just start off just somewhere. And because it has to point to 512 entries, well, it would just have to be full in this case. In this case, this one would have"}
{"text": " 512 entries in it, because we've spread them out as much as we can. So any questions about that? Yep. My question is, can you design your, like, could you design the first case, or is it just a matter of one?"}
{"text": " So yeah, so the question is, could I design the first case, or is it just a matter of luck? So if you just boot up your computer, and you can do whatever you want with memory, you could easily do that. You could make sure that your program just uses sequential addresses, because sequential addresses will be just one index off. So typically, you'll do that. Everyone's heap is like that, right? Everything looks sequential. So that's the reason why you want contiguous addresses, so your page tables actually don't get really messed up."}
{"text": " So you would do that, but the page tables might map to physical addresses that aren't contiguous. Ideally, you would like that to be contiguous as well. But you typically just try to make it as best you can. And that's your job as a kernel. But as things run and things allocate, deallocate, you have new processes, things typically get messy. So it's a best case basis."}
{"text": " OK, any other questions? So our best case here was three page tables. And our worst case is 512 plus 512 plus 1. So 1,025 page tables is the worst if we have to map 512 individual pages. So best case is we fit them all on a single L0. Worst case is we have one entry per in L0, one entry per in L1."}
{"text": " OK, so yep. Yeah."}
{"text": " Yeah, so the question is, well, if I only have one L2 page table, what about if I have more than 512 entries? Well, you can't, right? Because our L2 indexes here are 9 bits. So we can't use more, so we only have one. So if you wanted to support more virtual addresses, you just have to add another level. So I could add a fourth level that has 512 entries, and then I have to do this with another step."}
{"text": " OK, any more questions about that? So sweet. So here's another type of question. How many levels do you need, which we kind of did quickly yesterday. So all these questions will say what you're, you'll get all the information except for one piece of information that you will have to figure out. So in this case, we have a 32-bit virtual address, and it tells you your page size. And it's the one we all know and love."}
{"text": " And we have a bit different. We have a page table entry size of 4 bytes. So if we do our design insight of dividing it into smaller page tables and fitting each one exactly on a page,"}
{"text": " Well, if we want to find the number of page table entries we could have in a page, that's 2 to the 12 divided by 2 to the 2, which is that 4 bytes. So unlike before, we can have another factor of 2 more entries. So we can have 2 to the 10 entries in these page tables. Now, if our page table entry size gets halved, we can fit double the number of entries. Makes sense."}
{"text": " So it's always log 2 number of page table entries per page is the number of bits you need to index. So in this case, what's log 2 of 2 to the power of 10?"}
{"text": " 10, right? They cancel each other out. Exponent math. So for each level, we have 10 index bits. So you can figure out the number of levels you need. It's just a simple, all that is is a floor. So it just means we round up because it's fine if we can't fill one level, but we have to have as many levels as we need. We can't just end early."}
{"text": " So in this question, our number of virtual bits is 32. And our offset bits, which you derive from the page table size. So remember, everything is nicely page aligned. So you never have to monkey with however many bits represent that actual or on that page. So in this case, the offset bits are 12 because"}
{"text": " 496 is 2 to the 12, and you'll see this number over and over and over again. So virtual bits minus offset bits, that's 32 minus 12. And our index bits, well, we have 10. So 32 minus 12 is 20. Divide by 10. We don't need to do any rounding or anything like that. The number of levels we get is just 2."}
{"text": " What would happen if I say we have a 33-bit virtual address now? I just need a little bit more memory. So how many levels would I need in that case?"}
{"text": " 3, right? So I don't fit exactly within 2, so it would be like 33 minus 12, so 21 divided by 10. So I would need one additional level. And in that level, it would only have two entries that I use. So then all my L2 page table, I'd only have two entries I actually use to tell me which L1 page table I need to point at."}
{"text": " OK, so this is actually really, really, really, really slow. So for that, like that MMU simulator, that's what your hardware would actually have to do. So to decode a single address, well, it needs to do a lot more than that original memory access. So instead of what everyone thought before, where, hey, I'm accessing memory, so it's just however long it takes to access memory, well, now with page tables,"}
{"text": " we have to access memory multiple times. So each time, we're going to have to access the L2, which would be a memory read, then L1, which is a memory read, then L2, which is a memory read, and then our original memory read. So instead of just one memory access, we're turning that into four, which"}
{"text": " Intuitively, seems to make you think that your machine would be like four times slower. But we have some tricks we can do. So likely, we're going to access the same page multiple times. So remember, we even use the same translation. So when I change the offset to just be within the same virtual page,"}
{"text": " My translation didn't really change. It would have followed the same steps. And all the addresses are valid. And whenever you use your process wall, at any given time, you might only need a few mappings available at a time. You only use a few pages in your program at any given time."}
{"text": " Our solution to that would be just the computer science classic. We just implement a cache. Basically, that translation at the end of the day was virtual page number to physical page number. So we had to go through multiple levels to decode it. But after we decode it, well, we could cache that result. All, at the end of the day, we care about is, for this virtual page number, what's the physical page number?"}
{"text": " So that's exactly what something called a TLB is, or a Translation Lookaside Buffer. Why the name? They need to be fancy. But all it is is a cache for virtual page numbers to physical page numbers. So how it works is, well, in this case, you'll see the virtual address and logical address. They mean the same thing."}
{"text": " So on your CPU, it would use the virtual address, and then it would take the virtual page number, look it up in a lookup table, basically, and check if it's in that table. If it's in the table, it would be something called a TLB hit. So it's in the cache. So I can just use that for the translation directly, and I don't have to go through all those three levels again and again and again."}
{"text": " And then if there is a miss, well, then I have to go through those three layers of steps. And sorry, this image kind of sucks. But does that kind of make sense to everyone? It's basically just a cache, so I don't have to go translate it using those three levels again and again. Yeah? Yeah. So the original problem was that we can't fit the whole page table, like the mapping from virtual to digital. Yeah."}
{"text": " Yeah, so this cache would be a limited size."}
{"text": " But each entry in the cache essentially covers a whole page, right? So if this had even 128 entries, well, each page is 4 kilobytes, so that actually covers a bunch of translations at a given time. So it actually covers a lot of space. Well, it covers a decent amount of space now. Maybe a lot of space if you had 4 kilobytes of RAM, but it's a decent amount now. Yeah?"}
{"text": " Yeah, so the question is, why don't I just go back to my one big page table, because that would just be faster. So if I went back to my one big page table, well,"}
{"text": " I still have to translate. I still need two memory accesses, right? I need to find where it is in that page table. And then from that, I have to then get the original address it was referring to. So it's still two memory accesses for that big table. And also, that table, we threw out the window before because it was just way too big. But even if you had a single big page table, this would still be helpful because it would just cache that translation in the big page table, and you don't have to access it."}
{"text": " So but the main reason we don't use the single-page table is just because it would waste way too much space. OK, so that's four. And I guess we'll finish up this lecture next week. So and yeah, you should, after this, you should start doing Lab 2, because if you haven't started it yet, you are screwed. So just remember, pulling for you, we're all in this together."}
{"text": " for the those videos you can check out the side button right now how to delete data delete from beginning delete from end and delete from any specific position right first of all we will see how to delete data from beginning see this this node i want to delete right this is what a doubly circular linked list as you can see right"}
{"text": " Because each node is having two links one node is pointing to the next node and sorry one pointer is pointing to the next node second pointer is pointing to the previous node plus the last node the next pointer of last node is containing address of the first node as well as the previous pointer of first node is containing address of the last node. So, you can see this link is bidirectional."}
{"text": " right we are maintaining both head and tail pointer now we will see how to delete this data from the list right so i i hope everybody can write down that thing struct node how to represent this node that thing we have discussed many times so i'm not going to write that thing struct node and bracket int data struct node a strict next struct node a strict previous and after that you can declare two pointers head and tail i'll directly define the function delete from beginning right how you will write down write down that function see"}
{"text": " how to delete this thing after deleting this node the head will point directly to this node right and plus two more thing you need to update now this will be the first node so the previous pointer of this node would contain address of the last node that is here we will write 250 plus the last node contain address of the first node that is 100 so here you will update 100"}
{"text": " these three things you need to update after that we are going to free this memory because we cannot leave this node like this it is this node is still having some memory the memory is still allocated to this node already we have detached this node from the list but you have to free this and how you can do this using that free function in C language free and pointer to this node so you have to maintain another pointer you can say temp pointer right so after changing this head is equal to here what you can write free of"}
{"text": " In bracket we can write temp. So here you need to declare another point that you can say struct node temp."}
{"text": " and temp is also pointing to the first node so in temp we are going to store what whatever the value of head that is 200 so now temp is pointing to this node so first node two nodes are two pointers are pointing to this node head and temp head we are going to update after that temp we will use to free the memory fine so now first of all we will check if head is equal to zero in that case"}
{"text": " list is empty so here you will print list is empty in printf simply right. Now, else if head is not 0 there is no some node in the list, but second condition may be if in the list we have only one node right."}
{"text": " second condition what you will check else if now suppose there is only one node in the list so here situation is something like this we have only one node in the list both head and tail is pointing to this node and this node next pointer is containing address of itself previous pointer is also containing address of itself because this is the first node this is the last node this is the only node in the list so you need to check this thing also so how you can check else if what condition you can write"}
{"text": " see and as well as temp is equal to head so temp is also pointing to this node now right so here what you can write else if head of next equal to equal to head"}
{"text": " head of next means this is equal to head that is see this and this as same only in that case you can say this is the only node in the list or see you can write tail of next equal to tail tail of previous is equal to tail head of previous is equal to head either condition you can write so here what you will write if there is only one node then what you will write you can say both head and tail is equal to zero"}
{"text": " you will here put 0 and 0 and after that you will free this memory so after that you will write free temp because temp is also pointing to this node right so this is done else now on the list we are having more than one node in that case how you will delete suppose this is the situation and now I want to delete this node so in else part what you will write"}
{"text": " so here you need to update three things this pointer because after deleting this this will contain address of the last node that is 250 so how you can access this part so is there any pointer which is pointing directly to this node no we don't have any pointer so first of all we will set a pointer to this node or before setting a pointer you can access this thing how the address of this node is 100 here i have 100 so i can reach here using either temp or head"}
{"text": " you can say head of next that is here and after that again arrow and previous this how you can access or you can first of all set this head to this node after that you can update this thing."}
{"text": " Here I am writing head is equal to head of next. It means head of next is 100. So now head is containing 100. It means head is pointing to this node now. Right? So you can say here I have head and this is pointing to this node. Right? Now you can set this length. How you can access this part? Head of previous."}
{"text": " so head of prev now this should contain address of the last node that is 250 from where I can get 250 in tail I have 250 so here I can write tail right so head of previous is equal to tail means here I have 250"}
{"text": " so this is not pointing to this node now this is pointing to the last node plus update this thing also how you will access this thing tail of next so here i can write tail of next and here we will store address of the first node that is this node that is 100 in head i have 100 so here i can write"}
{"text": " So, here now I have in tail of next 100. So, now, this is not pointing to this node we have set this bidirectional link right this, this and this to this. Now, you can free this memory. So, here you can write free temp."}
{"text": " So, this is how you are going to delete the node from the beginning of a doubly circular linked list right. Now, we will see how to delete the node from the end. So, now, here I am considering now after updating this node this is the list we have I want to delete this node."}
{"text": " right so here delete from end so now in this case what you need to update to delete this node you have to update this tail pointer tail would point to this node right as well as this would be the last node now so this next pointer of last node should contain address of the first node that is 100 plus here the first node is containing address of the last node that is here you will update 300 these three things you need to update"}
{"text": " right and after that you will free this memory so obviously you need a second pointer that is temp so that we can use here free temp right so here also we will take a temp pointer temp is equal to now temp should point to here because this node I want to delete this memory I want to free so here you will write temp is equal to tail right so now you can say temp is pointing to this node in tail we have 250 so temp is pointing to this node now right."}
{"text": " now see if head is equal to 0 or you can say here tail is equal to 0 it means list is empty you will print the same thing else same condition if there is only one node in the list right in that case suppose this is the only node in the list so same condition you will write if head next is equal to is equal to head or you can say tail of next is equal to is equal to tail tail previous is equal to is equal to tail either condition you can write because we are having two pointers and these two pointers will contain address of itself"}
{"text": " if there is only one node so you can say head and tail is equal to zero and after that you can free the stem fine in else part what you will write now here you need to update what so here you need to store address of the first node that is 100 how you can access this part is there any direct pointer to this node no we don't have if we don't have then also we can access but you can set a pointer to this node because we have to update this tail so first of all you can update this tail tail is equal to pointing tail should point to this node so tail should contain 300 means"}
{"text": " tail equal to 300 from where I can get 300 here so tail of previous tail of previous right in tail of previous we have 300 so now tail is containing address 300 right so now tail is pointing to this node that is tail is containing 300 so tail is pointing to this node this is not tail now right now you can access this part tail of next"}
{"text": " So in tail of next what you will store address of the first node and always you can get address of the first node in head pointer. So where you will write."}
{"text": " head so here now i have 100 right so this is not pointing to the next node now this is pointing to the first node now update this link also head of previous this link should contain address of the last node that is this one in tail i have this address so tail in tail 300 so here also you will store 300 so now we have set this link"}
{"text": " this bidirectional link right. This node is pointing to this node and this node is pointing to this node. Now, what you will do now you can free this memory. So, here you can write free temp because we have we have already set a pointer pointing to this node. So, we can we can write here temp the name of that pointer right. So, now, we have deleted this node."}
{"text": " So this is how you can delete a node from the end of the list. Now we will see how to delete a node from any specific position. So now this is the list and we will delete a data from a position, suppose three, right? One, two and three, this node I want to delete. So after deleting this node, what you will update, this node would contain address of the next node directly, here you will store 300. And this node would contain, the previous pointer would contain address of the previous node, that is here you will store 200, right? That's it."}
{"text": " But some another corner cases are also there in this case. Suppose position is 1. In that case, it is same as delete from beginning. Else, if position is this one, end, then it is same as delete from end."}
{"text": " right plus one more condition if position is invalid suppose i view position is equal to 10 but here only valid position are 1 2 3 and 4 so it should print a proper message that is you have entered invalid position right so that thing also we will implement now suppose i want to delete this node position is 3 so obviously we will ask from the user from which position he wants to delete the data right"}
{"text": " and for that I am taking a variable and so now you have to traverse this list also till this position right because for deleting this node obviously we will set a pointer to this node you can say temp pointer so that after setting these links we can free this memory using that pointer right as well as you need to access this and this."}
{"text": " So, if you want you can you can maintain another pointer that is previous pointer. So, that you can access this node sorry this pointer of this node this part of this node for updating this or using a single pointer only we can access this and this because here this point this node is containing address to the previous node also and the next node also. So, no need to maintain another pointer we will update using a one pointer single pointer only. So, here I am taking single pointer that is temp."}
{"text": " So if position is 3, we need to traverse till this position. After that we can delete, right? We have to set a pointer here at this position. So now obviously we have to start the traversing. So at starting temp is equal to head. Temp would point to this node. So you can see here I have temp and temp is equal to head means head is containing 100. So temp is pointing to this node. Now from the user we will ask for the position using printf and scanf."}
{"text": " And suppose user has entered in position variable I have 3, 3 here I will from here where I want to delete right. Now we will see if position is valid or invalid. So, for that thing you need to know the length of the list right and to calculate the length of the list suppose I am calling a function that is get length and I am taking a variable l here I will store that length right."}
{"text": " So, how to calculate this length you need to properly code this function in this program after that you can call this right that is very easy that we have discussed when we were implementing the singly linked list. So, you can check out that video in the psi button. Now, in l in l I have what 1 2 and 3 4 because get length would return 4 and i I have a variable i here I have 1 at starting I have initialized with"}
{"text": " one right now we will check if position is less than one or position is greater than this length in that case here you will print a message that is invalid position right in printf else if position is equal to is equal to one in that case what you will do means this data you want to delete so you you will simply call delete from"}
{"text": " beginning this function you will simply call now if position is three right in that case what you will do now we will traverse this list till this position so here for traversing you will write down a while loop while i less than position till position we are going to traverse till then we are going to move this temp temp is equal to temp next right and i plus plus"}
{"text": " Now you can see the working of this while loop. i is equal to 1, position is 3. 1 is less than 3, yes. Temp is equal to temp next. In temp of next, we have 200. So in temp, we will store 200. So now temp would point to this node. i plus plus i becomes 2. Is 2 less than 3? Yes. Again, temp is equal to temp next. In temp next, we have 500. In temp, I have now 500. So now temp would point to this node."}
{"text": " i++, i is equal to 3. Is 3 less than 3? No. So we will not enter into while loop, we will exit from this while loop and here the control is now, right. So now as you can see we have reached till position 3. Now we can delete this thing, right. This you need to update, this pointer you need to update. So how you can access this pointer using this temp because we don't have any direct pointer to this node, right."}
{"text": " See address of this node is 200. So here I have 200 right. Can we access this part? Yes, we can access because we have a pointer to this node that is temp. So what I can write temp of previous. This part is name of this part is previous. So temp of previous means we have reached till this address. So now you can access this this or this part only by writing again arrow and name of that part. So now this part I want to access the name of this part is next."}
{"text": " right so here now i will store address of this pointer after deleting this that is 300 from where i can get 300 here i have 300 so temp of temp of next so here you will store temp of next so now here i have 300 so now this is not pointing to this now this this would point to directly to this node"}
{"text": " Now, you have to set this pointer also. Can we have can we directly access this node? No, we do not have any pointer directly to this node. Do not use this tail because suppose in the list we have 15 nodes and the tail would point in that case to the 15th node. So, tail is not point tail would not point to this node. Here the list is short that is why tail is pointing to this node. So, we cannot consider this tail."}
{"text": " How you can access this part? The address of this node is 300. Can we reach till this address? Yes, because here I have 300. Can we access this part? Yes, because this node is having a direct pointer that is temp. So here I can write temp of next."}
{"text": " Temp of next means 300 means we can we have reached to this address. Now I can access any of these three field by writing simple arrow and this name is previous. The name of this part is previous is equal to I want to store here address of this node that is 200 from where I can get 200. Here I have 200 how you can access this part temp of previous. So here you will write temp of prev."}
{"text": " It means here now I have 200. So this is not pointing to this node. Now this is pointing to this node. We have set these two links. Now you can free this memory. So here what you can write now free temp. So as you can see using one pointer only we have access this also and this also right."}
{"text": " one case may be suppose if position is three and this node is the last node right we don't have this low node and this third node is the last node so tail is pointing to this node and after deleting this obviously you need to update that tail also right that can be a corner keys right so now here what you need to check after these lines"}
{"text": " before freeing this memory you will check if this is the last node means suppose this is the last node in that case here it should contain address of this node that is 100 here we have we should have 100 right so now if you can check temp of next temp of next equal to equal to head"}
{"text": " It means that the node you want to delete is the last node that position is last node position. So now here you will write what tail is equal to you need to update this tail because in that case tail would point to this node. So tail after deleting this tail would point to this node."}
{"text": " right so now here address is 200 in that case obviously this node the previous pointer of this node should contain address of the previous node so here you can write tail is equal to temp of previous temp of previous that is 200 right so we have updated this tail now you can free this so here what you can write free temp else you can simply write free temp"}
{"text": " No need to update this tail. In else part simply write free temp. Directly you can do free of temp. In this case you can see."}
{"text": " So, like this also you can check this condition it is not like that this is the only way this is the only coding you can check using that you can check this case maybe some use after applying some another logic you can apply this thing you can check all the corner cases right. Rather than calling this delete from beginning here also you can write the code in while part only you can check if this is the first node."}
{"text": " Then you can do head is equal to tail is equal to 0 and then free temp else if this is the last node you can do this thing else you can apply you can apply this logic rather than calling this function right. So, there can be many ways to implement this deletion from a specific position right this is one of them fine. Now, that is it now you can close this else also and now you can close what this."}
{"text": " function also right. See in this case if you don't write these two lines outside of if and else then after this while loop only you can check if temp next is equal to is equal to head means suppose this position we have reached till this position and this is the last node in that case here only you need to update now first of all tail you will update this pointer you will update this pointer you will update and after that you can do free of temp."}
{"text": " In else part what you can write these lines again and after that free temp. So rather than writing these lines again and again in both if and else, it's better to write these lines before if else and after that you can update this tail in this case and after that you can free temp."}
{"text": " It's up to you how you will write down this logic. But this thing you need to take care, before freeing this temp you need to update these lines, you need to update these pointers, right. So you cannot write down these lines after if else, after freeing this."}
{"text": " before freeing this memory you need to write down these lines that is why before if and else I am writing these lines. So, this is how you can delete a node from a doubly circular linked list right. In next video we will see how to reverse a doubly circular linked list fine. So, I will see you in the next video till then bye bye take care."}
{"text": " OK, when the camera says, we'll start. You want to give me a signal? OK, this is lecture eight in linear algebra, and this is the lecture where we completely solve linear equations. So Ax equal b. That's our goal. If it has a solution."}
{"text": " It certainly can happen that there is no solution. We have to identify that possibility by elimination. And then if there is a solution, we want to find out is there only one solution or is there a whole family of solutions and then find them all. Okay. Can I use as an example the same matrix that I had"}
{"text": " last time when we were looking for the null space. So the matrix has rows one, two, two, two, two, four, six, eight, and the third row, you remember the main point was, the third row, three, six, eight, ten, is the sum of row one plus row two. In other words, if I add those left-hand sides, I get the third left-hand side."}
{"text": " So you can tell me right away what elimination is going to discover about the right-hand sides. There is a condition on b1, b2, and b3 for the system to have a solution. Most cases, if I took these numbers to be one, five, and seventeen, there would not be a solution. In fact, if I took those first numbers to be one and five,"}
{"text": " What is the only b3 that would be okay? Six. If these left-hand sides add up to that, then I need b1 plus b2 to equal b3. Let's just see how elimination discovers that. But we can see it coming, right? That if, let me say it in other words,"}
{"text": " If some combination on the left-hand side gives all zeros, then the same combination on the right-hand side must give zero. Okay. So let's, let me take that example and write down, instead of copying out all the plus signs, let me write down the matrix, one, two, two, two, two, four, six, eight, and that"}
{"text": " six, three, eight, ten, where the third row is the sum of the first two rows. Now how do we deal with the right-hand side? We want to do the same thing to the right-hand side that we're doing to these rows on the left side, so we just tack on the right-hand side as another vector, another column. So this is the augmented matrix."}
{"text": " It's the matrix A with the vector b tacked on. In MATLAB, that's all you would need to type. OK. So we do elimination on that. Can we just do elimination quickly? The first pivot is fine. I subtract two of this away from this, three of this away from this, so I have one, two, two, two, b1. Two of those away will give me zero, zero,"}
{"text": " two and four, and that was b2-2b1. I have to do the same thing to that third, that last column. And then three of these away from this gave me zero, zero, two, four, b3-3b1s. So that's elimination with the first column completed. We move on. There's the first pivot still."}
{"text": " Here's the second pivot. We're always remembering. Now these are then going to be the pivot columns. And let me get the final result. Well, let me, can I, can I, do it by eraser? We're capable of subtracting."}
{"text": " This row from this row just by that'll knock this out completely and give me the row of zeros, and on the right-hand side, when I subtract this away from this, what do I have? I think I have b3 minus a b2, and I had minus three b1s, this is going to be a minus a b1. Oh, yeah. That's exactly what I expect."}
{"text": " So now what's the last equation? The last equation, this represented by this zero row, that last equation is, says zero equals b3-b2-b1. So that's the condition for solvability."}
{"text": " That's the condition on the right-hand side that we expected. It says that b1 plus b2 has to match b3. And if our numbers happen to have been one, five, and six, so let me take, suppose b is one, five, six. That's an okay b. And when I do this elimination, what will I have? The b1 will still be a one, b2 would be five minus two, this would be a three."}
{"text": " Five, six minus five minus one, this will be, this is the main point, this will be a zero, thanks. OK. So the last equation is OK now. And I can proceed to solve the two equations that are really there with four unknowns. OK, I want to do that. So this B is OK. It allows a solution."}
{"text": " We're going to be naturally interested to keep track, what are the conditions on B that make the equation solvable? So let me put it, let me write down what we already see before I continue to solve it. Let me first, solvability. Solvability."}
{"text": " So which so this is the condition on the right-hand sides. And what is that condition? This is solvability always of Ax equal b. So Ax equal b is solvable. Well, actually, we had an answer in the language of the column space."}
{"text": " Can you remind me what that answer is? That was like our answer from earlier lecture. B had to be in the column space. Solvable if, when, exactly when, B is in the column space of A. Right? That just says that B has to be a combination of the columns, and of course, that's exactly what the equation is looking for."}
{"text": " So that, now I want to answer it the same answer but in different language. Another way to answer this. If some, if a combination of the rows of A gives the zero row,"}
{"text": " If, and this was an example where it happened, some combination of the rows of A produced the zero row, then what's the requirement on B? Since we're going to do the same thing to both sides of all equations, the same combination of the components of B has to give zero, right? So if there's a combination of the rows that gives the zero row, then"}
{"text": " The same combination of the entries of B must give zero. And this isn't the zero row, that's the zero number. OK. This is another way of saying, and it's not immediate, right, that these two statements are"}
{"text": " equivalent, but somehow they must be, because they're both equivalent to the solvability of the system. OK. So we've got this, this sort of like question zero is, does the system have a solution? OK. I'll come back to discuss that further. Let's go forward when it does, when there is a solution."}
{"text": " And so what's our job now? Abstractly, we sit back and we say, okay, there's a solution, finished. It exists. But we want to construct it. So what's the algorithm, the sequence of steps, to find the solution? That's what I -- and of course,"}
{"text": " the quiz and the final, I'm going to give you a system Ax equal b, and I'm going to ask you for the solution, if there is one. And so it's this algorithm that you want to follow. Okay? Let's see. So now to find the complete solution."}
{"text": " to Ax equal b. OK. Let me start by finding one solution, one particular solution. I'm expecting that I can, because my system of equations now, that last equation is zero equals zero, so that's all fine. I really have two equations."}
{"text": " Actually, I've got four unknowns, so I'm expecting to find not only a solution, but a whole bunch of them. But let's just find one. So step one, a particular solution, x particular. How do I find one particular solution? Well."}
{"text": " Let me tell you how I find it. So this is, since there are lots of solutions, you could have your own way to find a particular one. But this is a pretty natural way. Set all free variables to zero. Since those free variables are the guys that can be anything,"}
{"text": " the most convenient choice is zero. And then solve Ax equal b for the pivot variables. So what does that mean in this example? Which are the free variables? Which are the variables that we can assign freely, and then there's one and only one way to find the pivot variables?"}
{"text": " Their x2 and so x2 is zero, because that's in a column without a pivot, the second column has no pivot. And the, what's the other one? The fourth, x4 is zero. Because that's, those are the free ones. Those are in the columns with no pivots. So you see what my, so when I not, when x2 and x4 are zero,"}
{"text": " I'm left with the, what am I left with here? I'm just left with, see, now I'm not using the two free columns, I'm only using the pivot columns, so I'm really left with x1, the first equation is just x1, and two x3s should be the right-hand side, which we picked to be a one. And the second equation is two x3s,"}
{"text": " as it happened, turned out to be, three. I just write it again here, with the x2 and the x4 knocked out, since we set them to zero, and you see that we're back in the normal case of having back substitution will do it. So x3 is three halves."}
{"text": " And then we go back up, and x1 is one minus two x3, that's probably minus two. Good. So now we have the solution. x particular is the vector minus two, zero, three halves, zero. Okay. Good."}
{"text": " That's one particular solution, and we should and could plug it into the original system. Really, on the quiz, please, it's a good thing to do. So we did all these row operations, but this is supposed to solve the original system, and I think it does. Okay. So that's x particular, which we've got."}
{"text": " So that's like what's new today. The particular solution comes, first you check that you have zero equals zero, so you're okay on the last equations, and then you set the free variables to zero, solve for the pivot variables, and you've got a particular solution. The particular solution that has zero free variables. Okay."}
{"text": " Now, but that's only one solution, and now I'm looking for all. So how do I find the rest? The point is I can add on two, add on x, anything out of the null space. We know how to find the vectors in the null space, because we did it last time, but I'll remind you what we got."}
{"text": " I'll add. So the final result will be that the complete solution, this is now the complete guy, the complete solution is this one particular solution plus any vector, all different vectors out of the null space."}
{"text": " xn. Okay. Why this pattern? Because this pattern shows up through all of mathematics, because it shows up everywhere we have linear equations. Let me just put here the reasoning. A xp, so that's x particular. So what does A x particular give? That gives the correct right-hand side b."}
{"text": " And what does A times an x in the null space give? Zero. So I add, and I put in parentheses, so xp plus xn is b plus zero, which is b. So, oh, what am I saying? Let me just say it in words. If I have one solution."}
{"text": " one solution, I can add on anything in the null space. Because anything in the null space has a zero right-hand side and I still have the correct right-hand side b. So that's my system. That's my complete solution. Now let me write out what that will be for this example. So this example, in this example, x general, x complete, the complete solution"}
{"text": " is x particular, which is minus two, zero, three halves, zero, with those zeros in the free variable, plus, you remember there were the special solutions in the null space that had a one in the free variables, or one and zero in the free variables, and then we filled in to find the others? I've forgotten what they were, but maybe it was that."}
{"text": " That was a special solution, and then there was another special solution that had that free variable zero and this free variable equal one, and I have to fill those in. Let's see. Can I remember how those fill in? Maybe this was a minus two and this was a two, possibly. I think probably that's right. I'm not -- yeah. Two minus-"}
{"text": " Hm. Does that look right to you? I would have to remember what are my equations. Can I, rather than go way back to that board, let me remember the first equation was 2x3 plus 2x4 equaling zero now, because I'm looking for the guys in the null space. So I said x4 to be one."}
{"text": " And the second equation that I didn't copy again gave me minus two for this, and then, yeah, so I think that's right. Two minus four and two gives zero, check. Okay, those were the special solutions. What do we do to get the complete solution? How do I get the complete solution now? I multiply this by anything."}
{"text": " c1, say, and I multiply this by anything, I take any combination. Remember that's how we described the null space? The null space consists of all combinations of, so this is xn, all combinations of the special solutions. There were two special solutions because there were two free variables."}
{"text": " And we want to make that count carefully now. Just while I'm up here. So that's the kind of answer I'm looking for. Is there a constant multiplying this guy? Is there a free constant that multiplies x particular? No way. Right? x particular solves A xp equal b. I'm not allowed to multiply that by three."}
{"text": " But Axn, I'm allowed to multiply xn by three, or add to another xn, because I keep getting zero on the right. Okay. So, so again, xp is one particular guy, xn is a whole subspace, right? It's one guy plus, plus anything from a subspace. Let me draw it. Let me, let me try to, oh, I want to draw"}
{"text": " I want to graph all this graph, I want to plot all solutions. Now x. So what dimension am I in? This is an unfortunate point. How many components does x have? Four. There are four unknowns. So I have to draw a four-dimensional"}
{"text": " picture on this MIT cheap blackboard. OK. So, here we go. x1, Einstein could do it, but those are four perpendicular axes in representing four-dimensional space. OK. Where are my solutions? Do my solutions form a subspace?"}
{"text": " Does the set of solutions to Ax equal b form a subspace? No way. What does it actually look like, though? A subspace is in this picture. This part is a subspace, right? That part is some, like, two-dimensional, because I've got two parameters, so it's, I'm thinking of this null space as a two-dimensional subspace inside R4."}
{"text": " Now I have to tell you and we'll tell you next time, what does it mean to say a subspace, what's the dimension of a subspace? But you see what it's going to be. It's the number of?"}
{"text": " free independent constants that we can choose. So somehow there'd be a two-dimensional subspace, not a line, and not a three-dimensional plane, but only a two-dimensional guy. But it doesn't go through the origin, because it goes through this point. So there's x particular. x particular is somewhere here."}
{"text": " x particular. So it's somehow a subspace, can I try to draw it that way? It's a two-dimensional subspace that goes through x particular and then onwards by so there's x particular and I added on xn and there's x. There's x equal xp plus xn."}
{"text": " But the xn was anywhere in the subspace, so that filled out a plane. It's a subspace. It's not a subspace. What am I saying? It's like a flat thing. It's like a subspace, but it's been shifted away from the origin. It doesn't contain zero. Okay. Thanks. That's the picture and that's the algorithm."}
{"text": " So the algorithm is just go through elimination and, find the particular solution and then find those special solutions. You can do that. Let me take our time here in the lecture to think, about the bigger picture. So let me think about,"}
{"text": " So this is my pattern. Now I want to think, I want to ask you about a question, I want to ask you some questions. So when I mean think bigger, I mean I'll think about an M by N matrix A of rank r."}
{"text": " OK. What's our definition of rank? Our current definition of rank is number of pivots. OK. First of all, how are these numbers related? Can you tell me a relation between R and M? If I have M rows in the matrix and R pivots, then I certainly know, I know always,"}
{"text": " What relation do I know between R and M? R is less or equal, right? Because I've got M rows, I can't have more than M pivots, I might have M and I might have fewer. Also, I've got N columns. So what's the relation between R and N? It's the same, less or equal, because"}
{"text": " A column can't have more than one pivot, so I can't have more than n pivots altogether. Okay. Okay. So I have an m by n matrix of rank r. And I always know r less than or equal m, r less than or equal n. Now I'm specially interested in the case of full rank, when the rank r is as big as it can be."}
{"text": " I guess I've got two separate possibilities here, depending on what these numbers m and n are. So let me talk about the case of full column rank. And by that I mean, means r equal n. And I want to ask you, what's"}
{"text": " What does that imply about our solutions? What does that tell us about the null space? What does that tell us about the complete solution? OK, so what does that mean? So I want to ask you, well, OK, if the rank is n, what does that mean? That means there's a pivot in every column."}
{"text": " So how many pivot variables are there? n. All the columns have pivots in this case. So how many free variables are there? None at all. So no free variables. r equal n. No free variables."}
{"text": " So what does that tell us about what's going to happen then in our little algorithms? What will be in the null space? The null space of A has got what in it? Only the zero vector. There are no free variables to give other values to. So the null space is only the zero vector."}
{"text": " And what about our solution to Ax equal b? Solution to Ax equal b. What's the story on that one? So now that's coming from today's lecture. The solution x is, what's the complete solution?"}
{"text": " It's just x particular, right? If there is an x, if there is a solution. It's x equal x particular, there's nothing, you know, there's just one solution, if there's one at all. So it's unique solution, unique means only one, unique solution if it exists, if it exists."}
{"text": " In other words, I would say, let me put it a different way, they're either zero or one solutions. This is all, in this case, r equal n. So I'm, because many, many applications in reality, the columns will be what I'll later call independent."}
{"text": " and we'll have nothing to look for in the null space, and we'll only have particular solutions. Okay. Everybody see that possibility? But I need an example, right? So let me create an example. What sort of a matrix, what's the shape of a matrix that has full column rank? So can I squeeze in an example here?"}
{"text": " If it exists, let me put in an example, and it's just the right space to put in an example, because the example will be, like, tall and thin. It will have, well, I mean, here's an example, one, two, six, five, three, one, one, one. Brilliant example. Okay. So there's a matrix A."}
{"text": " And what's its rank? What's the rank of that matrix? How many pivots will I find if I do elimination? Two, right? Two. I see a pivot there. Those two columns are headed off in different directions."}
{"text": " When I do elimination, I'll certainly get another pivot here, fine, and I can use those to clean out below and above. So the actually, tell me what its row reduced row echelon form would be. Can you carry that elimination process to the bitter end? So what does that mean?"}
{"text": " I subtract a multiple of this row from these rows, so I clean up all zeros there. Then I've got some pivot here. What do I do with that? I go subtract it below and above, and then I divide through, and what's R for that example? Maybe I can, you'll allow me to put that just here in the next board. What's the row-reduced echelon form, just out of practice, for that matrix?"}
{"text": " It's got ones in the pivots, it's got the identity matrix, a little two by two identity matrix, and below it all zeros. That's a matrix that really has two independent rows, and they're the first two, actually. The first two rows are independent, they're not in the same direction, but the other rows are combinations of the first two, so"}
{"text": " So is there always a solution to Ax equal b? Tell me what's the picture here. For this matrix A, this is a case of full column rank. The two columns are, give two pivots. There's nothing in the null space. There's no combination of those columns that gives the zero column, except the zero zero combination."}
{"text": " So there's nothing in the null space, but is there always a solution to Ax equal b? What's up with Ax equal b? I've got four equations here and only two x's. So the answer is certainly no, there's not always a solution. So I may have zero solutions, and if I make a random choice, I'll have zero solutions."}
{"text": " Or if I make a great particular choice of the right-hand side, which just happens to be a combination of those two guys, like tell me one right-hand side that would have a solution. Tell me a right-hand side that would have a solution. Well, 0, 0, 0, 0. Okay. No prize for that one. Tell me another one. Another right-hand side that has a solution would be 4, 3, 7, 6. I could add the two columns."}
{"text": " Right? What would be the total complete solution if the right-hand side was four, three, seven, six? There would be the particular solution one, one, one of that column plus one of that, and that would be the only solution. So there would be x particular would be one, one in the case when the right side is the sum of those two columns, and that's it. So that would be a case with one solution."}
{"text": " Okay. That, this is the typical setup with full column rank. Now I go to full row rank. You see the sort of natural symmetry of this discussion. Full row rank means r equal m."}
{"text": " So this is what I'm interested in now, r equal m. Okay, what's up with that? How many pivots? m. So what happens when we do elimination in that case? I'm going to get m pivots."}
{"text": " So every row has a pivot, right? Every row has a pivot. Then what about solvability? What about this business of for which right-hand sides can I solve it? So that's my question. I can solve Ax equal b for which"}
{"text": " right-hand sides for do you see what's coming? I do elimination. I don't get any zero rows. So there aren't any requirements on b. I can solve Ax equal b for every b. I can solve Ax equal b for every right-hand side. So this is the existence."}
{"text": " exists a solution. Now tell me, so every row has a pivot in it, so how many free variables are there? How many free variables in this case? If I had n variables to start with, how many are used up by pivot variables? r, which is m, so I'm left with,"}
{"text": " left with n-r free variables. OK. So this case of full row rank I can always solve, and then this tells me how many variables are free. And this is, of course, n-m. This is n-m."}
{"text": " free variables. Can I do an example? You know, the best way for me to do an example is just to transpose that example. So let me take that matrix that had column one, two, six, five and make it a row. And let me take three, one, one, one as the second row. And let me ask you, this is my matrix A."}
{"text": " What's its rank? What's the rank of that matrix? Sorry to ask, but not sorry, really, because we're just getting the idea of rank. What's the rank of that matrix? Two, exactly, two. There will be two pivots. What will the row reduce echelon form be? Anybody know that one? Actually, tell me not only, you have to tell me not only there'll be two pivots, but which will be the pivot columns?"}
{"text": " Which columns of this matrix will be pivot columns? So the first column is fine, and then I go on to the next column, and what do I get? Do I get a second pivot out of -? Will I get a second pivot in this position? Yes. So the pivots, when I get all the way to R, will be there. And here will be?"}
{"text": " some numbers. This is the part that I previously called F. This is the part that so the pivot columns in R will be the identity matrix. There are no zero rows, no zero rows because the rank is two, but there'd be stuff over here and that will,"}
{"text": " enter the special solutions and the null space. Okay. So this is a typical matrix with r equal m smaller than n. Now, finally, I've got a space here for r equal m equal n. I'm off in the corner here with the most important case of all."}
{"text": " So what's up with this matrix? So let me give an example. Okay, brilliant example one, two, three, one. Tell me what, how do I describe a matrix that has rank R equal M equal N? So the matrix is square, right?"}
{"text": " It's a square matrix, and if I know its rank, it's full rank now. I don't have to say full column rank or full row rank, I just say full rank, because the column count and the row count are the same, and the rank is as big as it can be. And what kind of a matrix have I got? It's invertible. So that's exactly the invertible matrices."}
{"text": " r equal m equal n means the -- and what's the row echelon form, the reduced row echelon form for an invertible matrix, for a square, nice square invertible matrix? It's I. Right. So you see that the good matrices"}
{"text": " are the ones that kind of come out trivially in R. You reduce them all the way to the identity matrix. What's the null space for this matrix? Can I just hammer away with questions? What's the null space for this matrix? The null space of that matrix is the zero vector only. The zero vector only."}
{"text": " What are the conditions to solve Ax equal b? Which right-hand sides b are okay? If I want to solve Ax equal b for this example, so I a is this, b is b1 b2, what are the conditions on b1 b2? None at all. Right. So this is the case, this is the case where I can solve"}
{"text": " So I'm coming back here, I can, since the rank equals m, I can solve for every b. And since the rank is also n, there's a unique solution. Let me summarize the whole picture here. Here's the whole picture. I could have R equal m equal n. This is the case where this is the identity matrix."}
{"text": " And this is the case where there is one solution. That's the square invertible chapter two case. Now we're into chapter three. We could have r equal m smaller than n. Now that's what we had over there, and the row echelon form looked like the identity with some zero rows."}
{"text": " And that was the case where there are zero or one solution. When I say solution, I mean to Ax equal b. So this case there's always one, this case there's zero or one, and now let me take the case of full column rank, but some,"}
{"text": " extra rows. So now R has, well, the identity I'm almost tempted to write the identity matrix and then F, but that isn't necessarily right. I have, is that right? Sorry, am I getting this correct here?"}
{"text": " Oh, I'm not, my god. This is the case r equals n, the columns are okay. That's the case that was on that board, r equal n, full column rank. Now I want the case where m is smaller than n and I've got extra columns. Okay. There we go."}
{"text": " So this is now the case of full row rank, and it looks like I F except that I can't be sure that the pivot columns are the first columns. So the I and the F, the F could be partly mixed into the I. Can I write that with just like that?"}
{"text": " So the F could be sort of partly into the I if the first columns weren't the pivot columns. Now, how many solutions in this case? There's always a solution. This is the existence case. There's always a solution. We're not getting any zero rows. There are no zero rows here. So there's always either one or infinitely many solutions."}
{"text": " OK. Actually, I guess there's always an infinite number, because we always have some null space to deal with. Then the final case is where r is smaller than m and smaller than n. OK. Now that's the case where r is the identity with some free stuff, but with some zero rows, too."}
{"text": " And that's the case where there's either no solution, because we didn't get a zero equals zero for some b's, or infinitely many solutions. OK. This board really summarizes the lecture. And this sentence summarizes the lecture"}
{"text": " The rank tells you everything about the number of solutions. That number, the rank r, tells you all the information except the exact entries in the solutions. For that, you go to the matrix. Okay, good. Have a great weekend and I'll see you on Monday."}
{"text": " So the next question is construct a binary tree from the given post order and in order traversal fine, okay Post-order traversal is what? left right and then root and in order is left root and"}
{"text": " The first step is to find out the root of our binary tree. How to find out the root? From inorder traversal you can't find out root because root is in between left or right. We can't say what is the root in this inorder traversal."}
{"text": " Fine. But from post order we can say which one is root. How? Because root is always in the last position. So, in preorder we have scanned the preorder traversal from left to right. But in post order traversal, we will scan this traversal from right to left. Starting element is 8. Now 8 would be"}
{"text": " root of our binary tree. Now find out the element to the left of this 8 and the element which are to the right of this 8. Left subtree, element of left subtree and element of right subtree. Fine. How to find out this left and right subtree? We will go to the inorder traversal. Now locate this 8. Here we have this 8. This one is our"}
{"text": " Root, root, root ke left mein we have left and root ke right mein kya hoga apna? Right element. So you can say the right part. Fine. So all the elements to the left of this root, these are the elements of left subtree and these are elements of right subtree. Fine. The element of left subtree are 9, 5, 1, 7, 2 and 12."}
{"text": " And the element of right subtree are 4, 3 and 11. Now construct this left subtree. Now see out of these elements which would be the root? How to find out? We can find out the root element from post order only. And second condition is you are supposed to scan this post order from right to left."}
{"text": " left now the condition to find out this root is out of these elements see out of these elements the elements which is coming first when you scan this traversal from right to left that would be the first element would be the root out of 9 5 1 7 2 and 12 which element is coming first when you scan this find out"}
{"text": " 4 no 4 is that right part 11 is also right part 3 is also in the right part 5 when you scan from right to left the first element found is 5 out of these elements only we are not considering these elements fine 5 would be the first then 5 would be"}
{"text": " root of this left subtree. Now find out left and right part of this 5. How to find out? You would go to inorder. Locate this 5 in this inorder. Here we have 5. Now out of these element 9 is to the left of 5. So we will write this 9 to the left of 5 and 1, 7, 2 and 12. 1, 7, 2 and"}
{"text": " 12 would form the right subtree of this 5. Fine. Now find out. Out of these elements which would be the root? The same step you would go to the post order. Scan this post order from right to left. Which element is coming first? We have 7. Out of these elements. Fine. 7 is coming first when you scan this from right to left. Now 7 would be the root of this."}
{"text": " right subtree of this 5 now find out the left element of the 7 and what is the right child or you can say the right subtree of this 7 locate this 7 into this in order here we have 7 and out of these elements find out 1 is to the left of 7 so you will write 1 here fine and 2 and 12 are to the right of the 7 fine so you will write 2"}
{"text": " and 12 here now we have two elements again find out the root out of this 2 and 12 find out the root again scan this post order traversal from right to left and out of this 2 and 12 which one is coming first this 12 is coming first 2 is after 12 when you will go from right to left 12 is coming first so 12 would be the"}
{"text": " root. Now, find out left or right. Left or right to only one element. So, either it would be the left part either or to the right part fine. So, to find out this we have to locate this 12 in this inorder traversal. Now, find out 2 is to the left of this 12 fine to the left of root part. So, 2 would be"}
{"text": " to the left of this 12. Now we are done with the left subtree. Now go to this right subtree. Now out of these elements which would be the root out of 4, 3 and 11. Root find out connectively the same step. We would go to the posterior traversal. We will scan this from right to left and find out which element is coming first out of 4, 3 and 11. 4 is coming first. Fine. Then 4 would be the root. Now find out the left end."}
{"text": " right part of this 4 to find out left and right we would go to the inorder traversal locate this 4 in inorder traversal here we have this 4 fine and out of these element remaining element 3 and 11 both 3 and 11 are right of this root see root ke kya hai right mein to left mein aapke root ke there would be nothing and 4 and 13 both are to the right of this 4 now here we have"}
{"text": " sorry, 3 and 11. 3 and 11 would be to the right of this 4. And out of 3 and 11, find out which would be the root. Again, scan this post order traversal."}
{"text": " And 11 is coming first. So 11 would be the root. Now 3 would be left or right? How to find out? Go to this inorder traversal, locate this 11. Here we have this 11. And 3 is, 11 is a root, fine. And 3 is to the left of this 11, fine. So 3 would be to the left of this 11, fine."}
{"text": " So now we are done with our binary tree. This is our binary tree from this post-order and in-order traversal. If you want to verify it, then you can find out post-order and in-order traversal of this tree without checking these ones. And if the post-order and in-order traversal of this tree is same as given in this question, then you can say it's a right binary tree. So I'll see you in the next video. Till then, bye-bye. Take care."}
{"text": " Thanks."}
{"text": " Hi guys, welcome back. Today I am going to discuss with you how to represent a graph in computer. I am going to discuss with you the most popular two methods for representing a graph in computer. The two methods are first one is adjacency matrix and second one is adjacency list. First one is this matrix and second one is"}
{"text": " adjacency list. These are the most popular two methods. Although we have more method that is I guess multi list is also there. But I am going to discuss with you these two methods adjacency matrix and adjacency list. Now how to represent a graph in computer?"}
{"text": " See, this is the pictorial view, you can easily draw a graph on this whiteboard like this. But when you are going to represent a graph in computer, then you have to use something. You have to use some methods to represent this graph in computer. So, these are two methods, the one is matrix and one is list. First one is I am going to discuss with you this method, adjacency matrix."}
{"text": " So, matrix is simply in mathematics you know matrix is what m cross n where m is number of rows and n is number of columns something like this number of rows and number of columns. So, in this case"}
{"text": " Let us take this example this one is our graph and you are supposed to represent this graph using this adjacency matrix. Then how you will represent it? This adjacency matrix would be n cross n matrix and where n is what number of vertices in the graph. Now how you will represent it? This one is our matrix"}
{"text": " this should be n cross n matrix where n is what number of vertices how many number of vertices 1, 2, 3, 4, 5 then 1, 2, 3, 4, 5 number of rows would be there and 5 number of columns would be there this one should be 5 cross 5 matrix now we are supposed to fill out these entries."}
{"text": " See one to one, is there any loop? Is there any loop in this graph? Loop means the edge would start from the same node and would end on the same node like this. This would be a loop. If you have, see check out, you have any loop in this graph? No, you do not have any loop. That is why the diagonal elements would be 0."}
{"text": " 3 to 3, 4 to 4 there is no edge and 5 to 5 no edge ok. Now, check out 1 to 2, 1 to 2"}
{"text": " obviously it is undirected graph ok. So, this edge would be considered as 1 to 2 also and 2 to 1 also ok. 1 to 2 yes we have edge between 1 to 2 then you can write down 1, 1 to 3 no we do not have any edge direct edge between 1 to 3 that is why it is 0, 1 to 4 yes we have 1 to 4 we have an edge, 1 to 5 no we do not have."}
{"text": " Now 2 to 1, 2 to 1 yes we have because this edge is what undirected edge so this is also considered from 1 to 2 and 2 to 1."}
{"text": " 2 to 3. 2 to 3. Yes, we have. 2 to 4. Yes, we have. 2 to 5. No, we don't have any direct or any edge between 2 to 5. 3 to 1. You have. 3 to 1. No, we don't have. 3 to 2. Yes, we have. 3 to 2. See this one. 3 to 3. No. 3 to 4. Yes, we have. 3 to 5. Yes. Now, 4 to 1. Yes."}
{"text": " 4 to 2, yes this one. 4 to 3, yes. 4 to 5, yes. 5 to 1, no. 5 to 2, no. 5 to 3, yes we have. And 5 to 4, yes we have."}
{"text": " So, you can simply write down like this. Now, you can simply write down the definition of this adjacency matrix is what? It is a matrix, you can say A n cross n, we are representing the matrix with A, n n, where n is the number of vertices, n would be the number of rows and n would be the number of columns. And how you will fill these entries?"}
{"text": " a of i j this one is j is equal to 1 if i and j are adjacent okay. See suppose this one is i and this one is j let us take this one is i we are taking and this one is j."}
{"text": " So, you will write down a of i j 1 if i and j are adjacent, 1 and 2 are adjacent to each other that is why we are taking 1 to 2 is 1, a of i j that is a of i 1 and j is suppose 2, this one is 1 and i 2 and j is equal to 1, this one is also 1, otherwise we would write here 0."}
{"text": " Now, next we will discuss what is adjacency list see. Now, this would be as the name suggest we will have we are going to have link list."}
{"text": " fine and how many linked list would be there for each vertex one linked list would be maintained like this. In this case we are having how many vertices 5 I guess 1 2 3 4 5 1 2 3 4 5."}
{"text": " number of vertices are there fine for each vertex one linked list would be there and that linked list will have will contain the adjacent node to this node fine like this."}
{"text": " now suppose we have first one is what is number of node is one how many adjacent node are there to one one is two and one is four then one linked list would be maintained containing two and four now come to the second node this one second how many adjacent node are there one three and four this would be one"}
{"text": " 3 and 4. Now, for 3 also one length list would be there and it would contain how many number of adjacent node are there to 3. 1 is 2, 1 is 4 and 1 is 5. 1 is 2, 1 is 4 and 1 is 5. For 4 also we have 1, now we have what 2, we have what 3,"}
{"text": " and 5 see 1 2 3 and 5 and for 5 we have what 3 and 4 only 3 and this one is 4 how many linked list would be maintained 1 2 3 and 4 and 5 how many number of vertices 1 2 3 and 4 4 and 5 the number of vertices total number of vertices in the graph utni hi aapko maintain karni hai number of linked list for each node."}
{"text": " fine. Now, this is the adjacency list using this list you can represent this graph and this is how you can represent this graph using adjacency matrix. Now, when you are supposed to calculate the time complexity. Now, when you represent a graph using this method adjacency matrix then what would be the time complexity or you sorry you can say the space complexity. Space complexity would be theta"}
{"text": " n square in this case fine because this is matrix n number of rows and n number of columns. So, space complexity is what n square here it is the see 5 into 5 matrix 5 square 5 is what number of vertices that is n where n is what number of vertices and for representing a graph using this adjacency list the space complexity would be theta n plus 2 e."}
{"text": " See n 1 2 3 4 5 these are number of what vertices why we have written this plus 2e because the one see this one is one edge from 1 to 2 fine but you have written this edge two times in this list two times when"}
{"text": " from 1 to 2, 1 edge you have written and from 2 to 1 also, from 2 to 1 also. So, 2 times we have written this edge in this list. Same you can say with you can say take 1 to 4, this one is 1 edge, but you have written this 2 times."}
{"text": " 1 to 4 fine because 4 is adjacent to 1. So, we have written in this linked list also plus 4 to 1 also 4 to 1 like this. So, every edge has been written 2 times that is why we have written here n plus 2 v the space complexity is this one for adjacency list and this one is theta n square for when you represent this graph any graph using adjacency matrix. So,"}
{"text": " See it would be better to use this adjacency matrix to represent a graph when the graph is dense graph. Sometimes they can ask you this type of question. In case of dense graph it's better to use adjacency matrix to represent that graph and when the graph is"}
{"text": " sparse graph then it would be better to use this what adjacency list. Because see when a dense graph means almost or you can say each node is connected with each other node. You can say you can take example of a complete graph like this. Suppose we have"}
{"text": " 4 nodes and every node is connected with every node and 5 nodes and every node is connected with every other node like this. Then in that case it is better to use this matrix and when something like this one very few number of edges are there between these vertices then better to use this adjacency list and this is the space complexity."}
{"text": " for representing these graph. So, that is all about you know some you can say the basics of how to represent a graph in computer. These are the most popular methods. I am not saying that these are the only two methods to represent the graph, but I am just I have just discussed the most popular methods to represent this graph. So, I will see you in the next video till then bye bye take care."}
{"text": " So, now see you can reverse a linked list using two methods. First one is iterative approach using loops and second one is using recursion. So, in this video we will use what iterative approach to reverse a linked list."}
{"text": " right. So, now, see suppose this is a linked list in this linked list we are having 4 nodes this is known as a node this is data part and this is what address part this is going to contain address of the next node fine addresses of this node is 100 200 150 and 300 see it is not like that the address should be always in increasing order or decreasing order any random address can be assigned in the memory fine."}
{"text": " now after reversing of this linked list the output should be something like this see here reversing doesn't mean that we are going to swap this five five would go there and seven would come here six would go there one would come here no here what i'm going to follow is the method in which you are going to reverse these links see this node is going to contain address of next node"}
{"text": " After reversing we are going to reverse this link means now this node is going to contain address of the previous node not the next node like this fine and head is pointing here head is going to contain 300 now see this node is going to contain address of previous node that is 150."}
{"text": " This node is going to contain address of previous node that is 200. In this case, this node is containing address of next node that is 300. So we are going to reverse these links."}
{"text": " So, this is the original linked list and this should be the output when you will display the linked list after reversing then the output should be 7 1 6 and 5. Now, how you will implement this thing in C program let us see that thing. So, now, first of all we will discuss the method we will apply the method here and after that we will write down the code. See how you can reverse this obviously, you have to traverse this linked list."}
{"text": " fine and with the traversing while you are traversing at that time only we are going to reverse this link fine we are going to traversing the link list as well as with traversing we are going to reverse this link these links so how we usually traverse the link list we have already discussed in the previous videos using a temp pointer so suppose i am going to take here a temp"}
{"text": " pointer pointer to node so its starting temp is going to contain 100 so temp is containing address 100 fine both head and temp. Now see for reversing this this node should contain address of previous node but here no previous node is there it means previous node is what null so here you will store what null rather than this we are going to update this with 0."}
{"text": " you can access this part by this temp temp next is equal to 0 or you can say temp next is equal to previous node because after reversing each node is going to contain address of its previous node. So, we have to maintain the address of previous node also fine in this case right now previous node is having 0 right. So, now, this link has been broken now."}
{"text": " So, now we cannot move here because this link has been broken. So, now, suppose with the help of some logic we have moved here. Now, temp is pointing"}
{"text": " here right temp is not pointing here now temp is pointing here that is temp is going to contain 200 fine I will tell you that logic when you are writing that code so now temp is pointing here now what you will do temp next here what you will store the address of previous node"}
{"text": " Obviously you are going to reverse this link. So you are going to store address of this one. Fine. But we have already moved the stem here. Now how you can access this address? Address of this previous node. So you have to maintain a pointer that is previous node pointer. Suppose I am taking a pointer."}
{"text": " prev node and here now I am storing this 100 first of all in prev node 0 was there after that we have moved this prev node and now this is pointing to here see I am not moving this head in this case you can move this head also so now here what you will store this 100 so from where you will get 100 from this previous node so here you can store 100 so now this link has been established now this link has been broken"}
{"text": " So now how we can move here because this there is no link between this and this fine. So what you can do before updating this thing before updating this thing this next part of this one what we can do we can take another pointer variable and we can point that variable here. That pointer variable suppose that pointer variable name is next known."}
{"text": " So, before updating this, here we have 150 only. So, what you can do?"}
{"text": " this next node is a another pointer we are taking 3 pointers now. So, next node equal to in next node we will store 150 because address of this is what 150. So, here we should store 150 from where you will get 150 from here how you can access this node because one pointer is there pointing to this node. So, we can easily access both the parts. So, in next node what you can say next node is equal to temp next."}
{"text": " now we have one pointer to this thing now you can update this thing now here we can store hundred and now this link has been broken so we have no problem because here also we have one pointer pointing so for reversing a link list you are going to maintain one two and three pointers so in this case one previous node one next node pointer and suppose i'm not taking this temp the name i'm taking that is current node"}
{"text": " You can take temp also, these are just names, you can take the name according to your convenience, fine. So, now how you will write this logic? See, so now we will see how to write down a C program for this thing, fine. See, in this case also we are going to create three functions, one is create link list, second one is reverse and third one is display the link list."}
{"text": " create and display that we have already discussed the coding of those function we have already discussed in the previous videos you can check out that video in this i button fine here i'll write down the coding for this reverse function only and you can call these function into main function this thing i hope everybody knows you have discussed many times how to represent how to just define your own data type how to represent this node"}
{"text": " struct node data type name is struct node two parts are there int data for this part and this is what struct node string next because this is what a pointer to next node this is going to store address that is why I am taking here the type pointer."}
{"text": " and one link sorry one pointer we have to maintain that is head pointer this head this pointer is to the pointer to next node so we in program we just have this pointer address of this pointer or you can say this this value only fine so this is how this you can declare globally."}
{"text": " So, that in each function you can use this data type in create link list also in reverse also and in display also. Now, other than head we are going to use three pointers three more pointers. So, we are going to declare here these pointers the type these pointers are going to contain address of these nodes. So, this is how we are going to declare these three pointers fine these pointers are going to contain address of another node."}
{"text": " node fine that is why I am writing here struct node and a strict why because these are pointers at starting previous node will contain what 0 fine because this node is having no previous node so this node is going to contain this next is going to contain what 0 only na the address of previous node and previous node is having 0 only so that is why at starting will initialize this previous node is equal to 0 after that we will update this value."}
{"text": " So, at starting in this we have 0 fine and both these current and next node will be initialized with head. So, both will point to the first node because we are going to traverse the list fine. Obviously, from starting node only we are going to traverse. So, here what you will write both the current node and next node."}
{"text": " will contain whatever the value in head. In head we have 100 so here 100 and here also 100. So now this is also pointing here and this is also pointing to the first node. Now we are going to start the traversing. Till where? Till here. What condition you will write? Obviously this means the end of the list means that this next would be 0. So in while loop what you will write?"}
{"text": " next node not equal to 0. We are going to move next node then current node and previous node also this is how we are going to move these. So, next node not equal to 0 till then we are going to move. So, now, we are going to write down the main logic please concentrate on this thing see now both next node and current node are pointing to this node. Now, before updating this 200 before updating this 200 to 0 first of all what you will do you will"}
{"text": " move one pointer you can set this next node to here because once you update this to zero you are going to lose this link. So there is no way to reach here. So first of all we are going to set a link to here then we are going to update this thing. So now first of all we are going to move this current node here to the next node. So you will update this value means current node now is going to store 200 so from where you can get this 200 from here."}
{"text": " before updating right. So, how you will write in next node what you will store next node is equal to this 200 value how you will get this 200 you can use what next node you can access this using this pointer or this pointer fine. So, we are using this one next node and the name of this field is what next."}
{"text": " Next."}
{"text": " So, now after executing this line now the value is of this is what 200. So, now, it is pointing here. So, now, you can update this link you can break this link now fine then there would be no problem. So, now, here what you will store 0 means whatever the value in the previous node. So, how you will access this thing using current node because we can access this structure variable using a pointer. So, current node is pointing to this node. So, what you will write here."}
{"text": " current node and this part we are going to access this part that is next is equal to whatever the value in previous node. Right? Now this is going to store zero. Now you have broken this link. Right? So now this is pointing to null you can say. Right? There is no link between this and this now."}
{"text": " So now this node is going to store address of previous node. So obviously we have to update the previous node value. So now this previous node should contain 100. So we are going to update this previous node. We are going to move here. So from where you can get this 100. See the value of current node is 100. So here you can write what this previous node is equal to."}
{"text": " current node right now after executing this line this becomes 100 so now this is also going to point this node right and obviously we are going to move this current node also here fine so now what you will do in current node we are going to store 200 so from where you can get 200 from next node so after this you will write what"}
{"text": " current node is equal to next node and now we are going to close this while loop. Now after executing this line current node is equal to next node in next node we have 200 in current node also we are going to store 200 now current node is also pointing to this one the second one."}
{"text": " right now again this is close of while loop now again while loop will be executed while next node not equal to null now next node is 200 200 is not null again control will go within this loop next node is equal to next node next so next node is 200 next node using this next node pointer you can access this node so next node next is 150."}
{"text": " So here we are going to store 150 now. Before updating this we have to maintain a pointer to the next node. So now the next node is going to point where here."}
{"text": " Now you can break this link. Now you can update this thing. Second step. So current node next is equal to previous node. So now current node next is 150. So here you will store previous node. Previous node is going to contain 100. So here you will update 100. It means 100 is the address of previous node. So it is going to point"}
{"text": " like this so now you have reversed the link this link has been broken now after this we are going to move previous node and current node also now previous node is equal to current node so 200 would be stored here now here we will write 200 fine so now this previous node is going to point here and in current node we are going to store next node that is 150 so here we write 150 so now both current node"}
{"text": " see this current node."}
{"text": " and next node is also pointing to 150 right and there is no link between these nodes now what you will do again while next node not equal to null next node is 150 that condition is true so again control will go within this loop now first of all before we are going to update this thing here you are going to store 200 but before updating the next node we will move next node to here so next node is equal to next node next so in next node next we have 300 so here you will store what"}
{"text": " Now you can update this thing. How you will update? How you will access this thing using this node because this node is pointing to this node. Now current node next is equal to previous node that is 200. So in previous node we have 200. Previous node means it is going to maintain address of the previous node. Fine. So now it is pointing here."}
{"text": " Now you can update previous node and current node also. Previous node is current node that is previous node is now going to contain 150. Fine. So it is not pointing here. Now previous node is pointing here. And now we will move this current node also. Current node is equal to next node. Next node we have 300. So here we have 300. So now this is also pointing to here."}
{"text": " So now again next node not equal to null. Next node is containing 300. So next node is not null. Again control will go within this loop. Again we are moving this next node is equal to next node next. Now next node next is containing 0. So here you will write 0. So now it is going to point null. Nowhere. Fine."}
{"text": " Now what you will store here, here you are going to update this link and 150 would be stored here. So current node next is equal to previous node. In previous node we have 150. So the value 150 would be stored here in the current node next."}
{"text": " it is pointing to here because 150 is the address of previous node. Now previous node is equal to current node. Previous node is equal to current node. In current node we have 300 so here we will update this that is 300. Now previous node is pointing here. Again move current node is equal to next node. Next node is 0 so current node is also 0."}
{"text": " Both current and next node is going to contain 0. Only we have previous node value that is 300. Now previous node is pointing here. So now you have reversed all the links but one thing you have to take care. Head is still pointing here. Head should point here. Now head should contain address of this node that is 300. So from where you can get 300? No problem. We have previous node link and this is containing 300. That is why we are maintaining this previous node."}
{"text": " So now after this while loop you can write what head is equal to previous node prev node and after that you can close the bracket of this function now head is equal to previous node. So now head is containing what here I can write this head previous node value is 300 so now head is pointing here."}
{"text": " So, as you can see this is the output we have reversed the linked list after that you can call the display function fine and the output would be 7 1 6 and 5 and this code will work even if you have only one node if only one node is there that is 5 is there then output is also 5. So, I hope you can write the coding for the create function and display function and I have written the coding for reverse function and you can call these function into main function."}
{"text": " So, from next video we will discuss some more operation on linked list and as well as we will see doubly linked list. So, I will see you in the next video till then bye bye take care."}
{"text": " Okay."}
{"text": " All right, good afternoon. The teaching station is broken yet again. So I can't read Discord. So you'll have to yell at me if anyone comments on it. So yeah, that's great. All right. So again, this is not new content. This is just fun stuff that's kind of related to the course."}
{"text": " So I will not test you on Rust or anything like that, but we're going to see a conversion with our bank account. I'm not that good at Rust, so I can't do the conversion on the fly. But we can screw around with it. It's really easy to screw around with. And who here has used Rust before or even heard of it? We got a few people. OK."}
{"text": " So we'll quickly go into what is. This lecture might be a complete crap show, because I'm not great at it. So if you want to feel better about yourself for not knowing something, then you can watch me flounder here. But we'll make tons of errors and see what can happen. But basically, Rust is supposed to be billed as a new systems programming language. So it's actually kind of integrated into the Linux kernel now. So new drivers, you can write them in Rust."}
{"text": " And it's meant to just be a saner C that has some kind of more C++-like features, but isn't as quite insane as C++ with all its stupid templating and all that kind of stuff. So it also has a few nice goals over C++, where it aims to statically verify some properties of your program."}
{"text": " so that if you know it compiles, and sometimes you will fight with it to get it to compile, but if you know it compiles and you don't try and get around its rules, then you're guaranteed some nice properties, like you won't have a use after free, so you can't use memory after you free it, which would have saved some of you on lab six that have fixed your own errors."}
{"text": " Probably would have saved you on all the other labs while you're developing stuff. You can't double free something, so I can't call free on the same pointer twice. And statically, it verifies that you do not have any data races, which is probably more applicable for you guys, because concurrent programming is kind of hard."}
{"text": " And there's an unsafe keyword, so it won't let you do a lot of things, especially it doesn't really like you casting pointers and doing all that fun stuff you do in C because it's kind of unsafe. So if you want to tell the compiler, don't worry, I know what I'm doing, there's a keyword called unsafe. You can use it for a function or block a code that says, yeah, don't bother me, I know what I'm doing."}
{"text": " And the idea behind that is when you inevitably crash your program or something bad happens, well, because the rest of it's verified to be safe, you can just debug looking at your unsafe code. But, oh, I don't know why there's an at sign there, I accidentally screwed that up, but..."}
{"text": " It only verifies that data races don't happen, but it does not do anything to prevent deadlocks. And trying to get this example not to deadlock was a complete pain in the butt. So we will see that today. So it doesn't completely eliminate some of your problems, but it eliminates a large section of them."}
{"text": " So the way it eliminates data races is one of the things it kind of does is keep track of the lifetime of all your variables and how long they last for and however many times you take references to them. So it also has a keyword called mutable, which you have to declare a variable as mutable if you want to change it, which in other words for us means you want to write to it."}
{"text": " So one of the properties it will do is if you have references to something, you are allowed to have as many read-only references as you want, because that could not be a data race. But if you have a mutable reference to something, you can only have one. So if you can only have one, we know that even if you have concurrency, that's fine, because that is not a data race. We need two concurrent accesses."}
{"text": " So let's do this and see how this works. So it should be related to what we did. So the syntax is somewhat nicer and kind of weird."}
{"text": " So the main doesn't take any arguments, and it doesn't return an integer. It returns a result. And this is a kind of unbelievably nicer way of doing what the standard C functions. They return negative 1 and then set error no, and then you have to check it."}
{"text": " Well, a result can be one of two types. So it's a result and then two types. So if it's successful, this is the type it is. And if there's an error or something, it tells you what the type is of the error. And then you can go ahead and handle it and check it without checking if it's negative 1 or anything."}
{"text": " So it's kind of a nice way about this. Box is like a safe way for a pointer. Don't have to worry about that. It's basically just to check an argument. So this will go ahead, take all the, this is like the same thing where you use the NV pointer, but it's a bit different in Rust. And we change everything into arguments and just check. Remember, we just take one command line argument that says however many accounts you want to have for our bank simulation, if we remember our bank simulation."}
{"text": " And then it has some nice things, like you can parse a number straight with that. And you'll see in a bunch of Rust code, there's a bunch of question marks. So pretty much every function we know that can fail, like if you're parsing an integer from a string, there's tons of ways for that to fail, right? So in C, if it fails, what happens in C if you use like, what was it, A2I or something like that? What happens if you give it not a number?"}
{"text": " Anyone have used that before, hopefully?"}
{"text": " So if you just give it the string like hello and you say convert that to a number, what will it do? I don't know, probably give you like zero or set error, no, or do something. But likely, in all likelihood, you probably never checked the error before. So Rust forces you to check an error. So this parse method, I don't have a good IDE setup for this, but basically returns that same result thing where if it successfully transforms it, it gives you the number that it converted to. Otherwise, it gives you an error."}
{"text": " And this question mark thing is kind of a shortcut to say, OK, if it successfully returned, just give me the proper return value. And if it's an error, it'll just abort your program and give you a stack trace and say, hey, it's screwed up at this point. So it kind of does what I've tried to enforce on you guys, like check your errors and just fail out so you actually know what's going on and you don't kind of propagate that error and make it harder to debug."}
{"text": " And then we'll just check the number of accounts. So, oh God, so it gets really ugly. So let's skip this for now. Oh, whoops, sorry. Let me go to the version that does not use threads."}
{"text": " So everyone kind of remembers our bank example, right, where we have a bunch of accounts. And with a bunch of accounts, we just pick a random to one, we pick a random from one, and then we transfer money between them. So anyone want me to revisit that, or does everyone kind of remember the transfer function and what it does? Because we kind of had a question like that before, or yesterday. Monday, Monday. OK, so."}
{"text": " It took a while to even get this so that the compiler would not complain at me. So this is just getting two accounts from an array, and you want mutable reference to them because you want to change the balance because you're trying to transfer from one account to another account. But even getting that to work was a gigantic pain in the butt, and I'll kind of illustrate that here. Let me comment this out first."}
{"text": " So where is this? So if you want to define a vector or just like a, you can think of a vector as like a dynamic array. This is what you would do. So you would say let is how you declare a variable. So if you want to change the variable after the equal sign, you have to say it's mutable, which is that mute keyword. So it's like let mute."}
{"text": " test vector, and then you can say vector with capacity. So it's kind of like C++ namespaces. So this is just declaring a vector of size 10. And then the for loops also look a bit different. They don't let you just do i minus minus and screw up the condition or whatever."}
{"text": " So they'll have a little shortcut that says 1 dot dot whatever the other number is. So this for loop will iterate from 1, 2, 3, 4, 5, 6, all the way to 10 and put that value into i. So I just push 10 things onto my vector. So now my vector has 10 things in it, 1, 2, 3, 4, 5, 6, 7, 8, 9. Then if we were in C and wanted to pass a pointer to another function,"}
{"text": " so that it could change the value of it, which we've seen a few times. You would have to do the address of in C to get the address of. Well, it's the same thing in Rust, except if I want to change whatever it's pointing to, I have to say ampersand mute to say, hey, it's mutable. I'm going to change it. So if I do this, I'll say I'll have a reference or essentially a pointer."}
{"text": " to the zeroth element of the list and a pointer to the first element of the list. And then I'm going to modify the zeroth element of the list to two. So in C, that would compile, right? Everything would be good and it doesn't have any problems with it. But in Rust, if I go ahead and try and build it so it has its own build system, so it will loudly, loudly complain at me."}
{"text": " and loudly complaining at me. So one, it's complaining that I don't use the variable element one. OK, true, but don't worry about it. And then it says, oh, if this was intentional, it gives you a way to silence the warning by putting a prefix in front of it or silencing it. So it has a lot of ways to communicate with the compiler, which is"}
{"text": " There's ways to do this in C, but people generally don't do it. It's also warning me that this variable does not need to be mutable because it's actually a mutable. So this is a pointer to something I can mutate. So I'm not actually changing what I'm pointing to. So this mute keyword, I didn't need to actually use it."}
{"text": " It tries to limit the amount of mutables you use so that you have the least amount of chance of writing anything and breaking anything. So we could go ahead and fix that, where essentially it's just a pointer."}
{"text": " And the nice thing about this, too, is those are all variables, but you might notice, too, that we don't declare the types for them at all. So another nice thing about Rust is it will infer the types for anything. So if you go on to take a compiler course or a grad-level type system course, you will figure out how it does things like that. It is fairly complicated, but for us, we just get to have the nice benefit of using it."}
{"text": " So let's go to our next error. Variable does not need to be mutable. And then this is our error. So it says, cannot borrow test vector as mutable more than once at a time. So does anyone have an idea what in the blue heck it's talking about? Yeah. Sorry?"}
{"text": " Yeah, is that what you're going to say, too? So I have two references to the array. But technically, this is actually OK, right? Because I have two references to two different spots in the array that do not overlap. So the pointers do not overlap, but they are references within that array. So this is where the thing."}
{"text": " So if I did something like this, it would be right where they're both pointers to the same index. That would definitely be an error where I have two mutable references, or you can think of pointers to the same element."}
{"text": " But in this case, this should be okay. And if you're used to C, this wouldn't pose any problems, no issues whatsoever, but the annoying thing is this just won't compile, because it errs on the side of being conservative. So if you just have one reference to the array, in general, it would need to prove that both the elements are disjoint, and in general, it can't do that. Oh, yeah, was there a question?"}
{"text": " So with what I have now? Yeah. No. Yeah."}
{"text": " So pointer arithmetic's unsafe, so it won't let you do that. So you have to force it to do unsafe, and then if you use unsafe, all bets are off. So pointer arithmetic and stuff, it doesn't let you do it. Strictly discourages you doing that. So this is technically safe, but the compiler is, if you get to compiler courses, it's called, it's trying to be really conservative, because in general, it would have to prove that those two array elements are disjoint,"}
{"text": " And in general, that's a very, very hard thing to do, even though the example given right now, you just have to prove that 0 is not equal to 1. That's pretty simple. But then they'd have to special case a bunch of stuff, then it would work sometime, and it would probably just make your life more of a pain. Because the general case is that these could just be two unknown variables, and they come from who knows, and then you have to prove that they don't equal each other, which"}
{"text": " So yeah, in general, it's not going to happen. So this is kind of one of the first pain points of this is, at least for you guys, since you know C, hopefully, you guys are technically smarter than the compiler for some things. And the compiler will get in your way. But I'm told, eventually, you kind of get used to it. And it becomes all good."}
{"text": " That was like the first issue because when we're even doing the serial version of this in Rust, our transfer takes, here, let's go to our transfer."}
{"text": " And this is the fixed one. So our transfer takes two accounts. But in Rust, I couldn't just take two if I had defined transfers from taking a mutable reference to an account, and then two has"}
{"text": " a mutable reference to an account. Well, the compiler stopped me right there because that's technically the same array, and then it would say, hey, you can't have two mutable references to the same array, so it won't let you do that. So you might notice some other crap on here. One thing you recognize, so everyone should recognize mutex, and the other thing is an arc. Anyone have any idea what the hell an arc is?"}
{"text": " So how many of you have actually used C++ for things? One? OK. So basically, arcs are pointers, and it keeps track of the number of pointers to a thing."}
{"text": " but it keeps track of how many pointers there are to it. So it's kind of like our inodes, how it keeps track of how many things point to it. An arc does essentially the same thing, but for pointers. And a pointer, if you want to be nice in Java, generally if a pointer actually points to something valid, you call it a reference and not a pointer. So..."}
{"text": " An arc is basically just a reference, a pointer that keeps track of how many things point to it, and the A stands for atomic, so it's an atomic pointer, so when it adjusts the number of things that point to something, it does it atomically, so it's nice and thread-safe and everything, so that way we can have multiple pointers to our array and keep track of it that way, and you have to wrap types in Rust."}
{"text": " It's kind of annoying, but once you figure it out, it's not too bad. So let's go here. So yeah, this is kind of what our, oops."}
{"text": " So this is what our transfer function looks like. So it fixes a bunch of issues that we had before where we had RAND that was really, really slow because it shared state. But here, if you have a random number generator or RNG, well, you have to declare it as kind of a variable, which is kind of like an object. And then it has its own state, so it's nice and thread safe. And then this is where we go through the number of transfers."}
{"text": " So we come up with a random index for the from account, random index from the to account, and then this is how we create multiple pointers to it. So instead, this is what you would normally do."}
{"text": " to access an element of an array. But because we're not allowed to take multiple references to an array, these are actually pointers. And .clone on the pointer just makes another copy of the pointer. So it's your own pointer. And it increments that number, that count that's actually referring to it. So you can actually keep track of the number of references to something. And that's, again, how to make things safe and that you don't have to call free on it."}
{"text": " So this keeps track of how many things point to something. It's the same thing as inodes. So as soon as you have no references to that memory, whenever it goes to 0, then it would free the memory for you. You don't have to worry about it. There's no extra onus on you to know when to free. It just frees whenever there's no references. So this will take two pointers, count them, give them to transfer. Oops."}
{"text": " And in transfer, this is our thread safe one. But it basically just does the same thing where we just take 10% from the from account, take it from the to account, and that's it. So any questions about that? So yeah, sorry, it's a bit of a mess because I had to put in the solution because, yeah, I can't remember how to do this again. Like, look at the type on this thing. It's gross."}
{"text": " Some of it might be because I have no idea what the hell I'm doing, but hey, it works. Okay, so let's see the thread-safe version. Oops, not that one. So for the thread-safe version,"}
{"text": " or the one with threads? Well, you can create an array of threads in a vector, which is just like a dynamically sized array. And then we would take a pointer to the whole array. So this is what this represents. So you give."}
{"text": " each thread a pointer to the array, and then this is, instead of pthread run, it's called thread spawn, and there's this move keyword, so any arguments you give, you can't use them after you give them away. So if I tried to use accounts clone here, this would give you an error."}
{"text": " Because it would say, hey, you. So one of the other things it does, it has a concept called ownership. So it will keep track of who owns what variable so that you're make and ensures that you only have one owner for each variable. So like if it was some dynamically allocated memory, you're the only owner of it. So if you make it to the end, you can call free on it and no one else uses it. So you're fine. You're free to free it. There'll be no free after use or anything like that."}
{"text": " All right, any questions about that? So we basically have to give a pointer to the whole accounts array for each individual thread that's all counted. And the reason for that is because Rust or you, in the general case, don't know how long a thread lasts."}
{"text": " and don't know how long the main function lasts and don't know if the main lasts longer than the threads or the threads last longer than main in general. So it makes sure that you transfer it there so that you can always use that vector array because it won't actually free the memory associated with that array until there's no more references to it. So you're always safe to use it. You'll never have a use after free because you never even call free. It only calls free itself whenever there's no references to it."}
{"text": " But it's also a bit silly in this case, because we know we have a bunch of threads, and we join them. So this is the way to join them. And unwrap is just to check for errors again and just get the value of it. Otherwise, it just kind of dies. So we know that our array actually lives longer than all the threads. But unfortunately, REST is not quite as smart as us. But we'll live with it."}
{"text": " All right, any questions for this? Okay, so let's go in here. So this was more of a pain to get right, so."}
{"text": " For all the locks, so by default, you are not allowed to try and modify anything or even read multiple accounts at the same time because it can't argue that that's a safe thing to do. So you're only allowed to actually change values if they're protected by a mutex. And the way in Rust to use a mutex is"}
{"text": " It's kind of like a type qualifier around an account. So if I want to modify the account or get at any data associated with the account, I have to go through the mutex first. So the only way it will make sure that the only way I can even try and modify the account is if I already have a lock and acquire lock."}
{"text": " So, in Rust, the from is actually a lock, the arc is just a pointer, it'll get rid of the pointer for you, so you can think of the from account as just being a mutex around an account. So, instead of doing pthread, mutex, lock, or whatever, you do a lock on the mutex, and then unwrap would check for errors, so check, you know,"}
{"text": " check error node, do all that stuff, and then just crash the program if something bad happens. And then after that, our lock is acquired, and we can actually modify the from account. So if we do something, let's do my initial solution."}
{"text": " All right, so if we do this and we, whoops, wrong build system. All right, so if we do this and we run it, do we have any data races? So let's, I'll move up some code. So it acquires both the locks and then here it modifies the accounts."}
{"text": " So do I have any data races here?"}
{"text": " Hopefully not, because I have a lock, like right after this, I've acquired the lock from, I've acquired the lock to two, and a nice thing about two is Rust will automatically unlock them when the function's done, so you don't have to worry about calling unlock. So at this point, I have both the locks, and they'll both be unlocked whenever it reaches the end of the function. So I don't have any data races. What problem do I have, though?"}
{"text": " Deadlocks. So Rust doesn't prevent deadlocks. So let's go ahead and see if I try and do run. So if I try and run it, this might be the first thing you promised a lot about Rust. But if I try and run it, well, I'm screwed because I have a deadlock. And there's nothing I can do about it. So does anyone remember the two easy ways to avoid doing a deadlock?"}
{"text": " Yeah. Yeah, okay, yeah. First one is, hey, if I always maintain the same order, I won't have a deadlock. Doing that in Rust is, as far as I can tell, impossible. So, because here, it depends what order, too. So the account does have an ID that's unique."}
{"text": " But there's kind of a catch-22 here. If I even want to read the ID, because it's declared like this, even if I want to access anything about the account, even to read it, I have to acquire the mutex. And I've already deadlocked myself at that point. I can't do anything about it, or I can't change the lines or do anything."}
{"text": " actually check the pointers and do it based off the pointers. But you can only acquire the locks in the right order, and then you forget which accounts associated with what lock. And the only way I could think to actually fix that is actually writing two transfer functions, depending on the order of them. But that seemed super lame and kind of a buzzkill. So anyone remember the second solution? Yeah."}
{"text": " while having both locks. Yeah, let's assume I want both locks, though, at the same time. So I could do the same thing as in the exam where I just kind of. So unlike the exam, this gets a bit different because it takes a percentage into account. So if you have a partial transfer, it gets kind of weird that you probably don't expect that. So what if I want to maintain two locks?"}
{"text": " So one was always acquire them in the same order. What was the other deadlock or another deadlock condition? Yeah."}
{"text": " Yeah, try lock, because one of the conditions is hold and wait, right? One thread has a lock while it's trying to get another one. So if I can break that condition, then I don't have the possibility of a deadlock. So that's what, essentially, I came up with to do. And it works the same in Rust, but kind of looks a bit different."}
{"text": " It has weird things where the thing at the equal sign can be an expression. So you can say a variable is equal to a loop as long as it eventually gets to a variable. Rust is OK with that. And the scope is only within the scope of that, which is kind of cool."}
{"text": " So in the loop, I do a try lock to the 2. So at this point, I would have already acquired from. So I do a try lock, and then it's that result type. So you can use a let expression. It does pattern matching."}
{"text": " A proper result is called OK. So if it's OK, that means I acquired the lock. And then I just have a break that says, return that variable, assign to account to to account. So it actually represents the lock mutex."}
{"text": " Otherwise, there's drop from account, which if we wrote this in C, this would be mutex unlock, but drop is the rust keyword for kind of any variable that as soon as it goes out of scope, drops automatically called on it. So if this was like a malloc thing, drop would call free. In the case of mutexes, drop calls unlock. So it's just kind of a more generic term that represents a whole bunch of stuff."}
{"text": " So this drop from account is the same as unlock from account. And then I have a yield. And then I would try and acquire the from lock again, which is what we had before. And then we go ahead and we just try it over and over again. So if I have this, hey, it should hopefully prevent a deadlock."}
{"text": " And yay, it works. So that's Rust. It's kind of nice. I thought you guys should see it, even though it might not have made that much sense. But it's probably a good thing to know if you start writing concurrent code. It will, in some cases, make your life a lot easier. All right. So any questions about that? If not, let's talk about the exam. Yay."}
{"text": " Okay, so we can start doing more review. I'll take up more questions and then the plan for Thursday is to finish whatever we didn't do today or please ask other questions so I have something to do. Otherwise, it defaults to open office hours and I'll just stand there and wait for questions."}
{"text": " Whoops, dog. OK. So this question says, hey, given four threads that are properly created, set up to run, you want to ensure some ordering between them. So ordering should immediately trigger you to think of centiphores. So that's a nice way to ensure order. You could also use condition variables."}
{"text": " Generally, if you can, xenophores are the easier thing to do. And I guess there is a question. I mean, I gave you the front page to the exam, and there's a question called xenophores. So probably shouldn't be a question what you actually have to use. So this says,"}
{"text": " This was a closed book exam, so I had to tell them what POST and WAIT did. But for you guys, you have an open book or at least a cheat sheet, so I won't tell you. So you should know how CenterFors work, but pretty easy. They have an increment, decrement. Decrement will make sure it won't go negative. If it's zero, just waits until it gets incremented by something else, and then it would eventually decrement it."}
{"text": " So we have four threads, they each call their own thread function, and there's some comments between all the functions, and you want to ensure the order between them. So thread one runs F1, then F2, and then in thread two, it only runs F3, and we want to ensure an order that, hey, F1 only runs after, or F3 only runs after F1 completes,"}
{"text": " F4 only runs after F1 completes. And then in thread 4, we have F5 that should only run after F2 completes. And then F6 that should only run after F3 and F4 complete. So let's work on this. So first constraint is probably this one we want to work on."}
{"text": " So anyone have any ideas how I would make this work? How I would make sure that F3 only runs after F1 is done? Oh, yep. So thread two, you want."}
{"text": " So we want to wait. So we'll start off with a wait. We'll just use sema 1 or something. That's the first semaphore. So we'll set it off to wait first. So everyone agree with that? Everyone like that? OK. So next thing you need to think of a semaphore probably is, what should the initial value of it be? So what should the initial value of that semaphore 1 be?"}
{"text": " 7. Everyone like 7? Yeah, thumbs up. All right. So what will 7 do? Yeah. 0, no? Yeah. People like 0 better? OK, we like 0 better. So whoa, jeez."}
{"text": " No one saw that. All right, let's just use that zero then. Yeah. So we can probably use zero. So zero makes it so that, hey, because we don't know the order between any of the threads executing, it'll make sure that if thread two executed before thread one, for whatever reason, that it would hit the wait. If the initial value was anything other than zero, it would just pass it immediately. So if it was seven, it would just go from seven to six."}
{"text": " And then it would call F3, and it just called F3 before F1 happened. So that would be bad. So this looks good so far, but we have still another issue. So in this case, will it ever call F3? No, right? So nothing posts. So we should probably work on the other part of it. So where should we place the post?"}
{"text": " Yeah. After f1. OK, so we can post. All right, everyone agree with that? So that looks like that handles that constraint. So now, if thread 2 runs first, it would hit the wait. The value of the semaphore is 0, can't do anything. So it would have to wait until eventually the only way to post it."}
{"text": " is for thread 1 to start executing, finish f1, and then it would post it. It would go from 0 to 1, then thread 2 at its leisure. It could go from 1 to 0, then call f3. So it can only happen after f1 gets called. So everyone good with that? All right. What about f4? So let's tackle this one. So that's that constraint fixed. What about this constraint?"}
{"text": " So it's the same thing. So yeah. Yeah, so we just do the same thing again. So we'll wait. So now if thread 3 gets called first while the initial value is 0."}
{"text": " can't do anything, has to wait for a post. So if we leave it as is, well, thread 1 will execute sometime, execute f1, and then increment that from a 1 to a 0. And then either thread 1 or thread 2 would pass those, wait, and go from 1 to 0. And then the other one would be stuck there forever. So we still need that sem post."}
{"text": " Somewhat. So now a whole bunch of different orderings that can happen, but that constraint still works. So if thread 2 tries to execute, couldn't do anything. Thread 3 tries to execute, can't do anything. And it would wait for thread 1 to go."}
{"text": " Finish f1, maybe it only posts once, and then another one of thread 2 or 3 executes, and then it passes by. Then eventually, it will make it back to thread 1, and it would go from 0 to 1 again, and then the other one could pass by. Or it could just do the two posts in a row, go from 0 all the way to 2. Either way works. Doesn't matter. Our constraint's still good."}
{"text": " All right, so we like that. So hey, we can give it. So check, check. What about F5? So this only runs after F2 completes, which is this guy here. So how am I going to do that? Yeah."}
{"text": " OK, so use a different center for. All right, new center for. All right, everyone like the direction that's heading in? What did we forget to do?"}
{"text": " Yeah, we forgot to initialize it. What should its value probably be? 0. If it's anything other than 0, then thread 4 could go ahead, execute thread 5, and then we're screwed. So this looks good, and we used another SANFOR. So would it work if I reused SANFOR 1 for that?"}
{"text": " No, because it actually needs to be a different one, because you're not actually sure. Although, technically, you could. So there is a sillier solution, because you guys are being really, really good and making sure that"}
{"text": " The other threads can start as soon as possible, but I could actually reduce the number of center 4s I use. And the alternate solution is I could make this center 4, 1, and it could still work. Anyone guess what else I would have to change for that to still work while technically still being true? Yeah."}
{"text": " Post after thread two? Post after F3, like here? So that wouldn't quite work."}
{"text": " Whoa, OK, whatever, we leave that. So what you could do is you could move the post. OK, so I want to erase things so it doesn't screw up. But you could move these posts to be after F2 as well."}
{"text": " so that all the other threads can't run until thread one's done. And technically, all the conditions are still true. But this solution's actually better because it allows the threads to run as soon as possible. And there's a sub-question that asks, what can run in parallel at the same time? So if you gave that solution, you essentially make sure nothing can run at the same time as thread one, which is pretty lame. So you guys are doing the smarter thing."}
{"text": " But that was just an aside. OK, so this is sim2. All right, so we're done with that condition. We just got the last one left. So f6 only runs after f3 and f4 complete. Any ideas how I would do that? Yep."}
{"text": " Nope. Yeah, set of fours, you're not allowed to initialize to negative. They have to be unsigned. So it's 0 up. Yep."}
{"text": " Yeah, OK, so we could go ahead, post a new center for SEM3, we could call it. Only after, once after F4, and again after F3. Oh, it's already there. So we could post SEM3, and then here we need two weights."}
{"text": " I'll move the ampersand and wait. So that way, it has to wait for both of them to be done before actually executing F6. So if only one's done, it would make it pass one weight, not the other. So it needs actually both of them. So any questions about that one?"}
{"text": " Cool. So last part was just for each function state, what functions could run in parallel with it not including itself, right? None if it can only run by itself. So it's just kind of looking at it, looking at the dependencies and seeing what could run in parallel at the same time if you had enough CPU cores. So I can leave that one and we can gloss over the rest of them just"}
{"text": " to let me know on Discord what you actually want me to cover more in depth tomorrow, or any other topics you want me to cover, since you have the front page. So for the last five minutes, let's just go through it quick, quick, quick. So memory allocation was BuddyAllocator."}
{"text": " Should know what that is that only allocates in size powers of two and here I'd set it So it needs to be able to handle eight allocations of 10 bytes each So this is just knowing that hey if they're 10 bytes if I have a buddy allocator would be 16 bytes So how big does my memory block need to be? Well, it would need to be 8 times 16 Which is 128 that the data and then just asked about fragmentation"}
{"text": " Disks, so this was just, remember all those rate configurations that essentially just asks, oh, I have a bunch of hard drives, what's my usable space? How many drives can fail?"}
{"text": " Just pretty much that lecture in a nutshell. File system. So this is making sure that even though you didn't write a CP, you know what LN means. So this is like using your knowledge to explain the difference between hard links and copying."}
{"text": " In terms of inodes and blocks, assume you have a file that's called myfile that contains 2,000 whatever bytes. Block size is four kilobytes, so it fits on a single block. As a hint, I said I ran the command for you and you find the output below. And the hint here was that, hey,"}
{"text": " If I do a hard link to my file, the inodes are the same, because they're hard links. So it refers to the same thing. But if I do a CP, like a copy, and create a file, there's a new inode. So if there's a new inode, that inode also has its own data blocks. So they're completely independent. And the copying would be, it would create"}
{"text": " As part of the copy, it would create a new inode for the copy file, then go in and copy the contents of all the blocks, and make an exact copy of it, and make sure that the new inode it just created points to those. So that's how files normally work if you copy a file. If I copy a file, and then I modify the original one, it doesn't affect the copy of the file I made. Nothing changes. While if I had a hard link, they both actually refer to the same data. So if I change a hard link,"}
{"text": " through my file and then look at ln file after, the changes are in both of those. They're not actually copies of each other. They're actually pointing to the same thing. Then, yeah, last one was just virtual machines."}
{"text": " And just general questions about virtual machines. Are they a good idea? What's their benefit? So this is kind of more like these sub-questions are more like your short answer questions. So your short answer question would be like either 8a or 8b. So this is kind of what your short answer questions look like. So there's no big virtual machines question. But you can probably guess."}
{"text": " Wow, I talk too much. But yeah, I probably made a question about it. And it probably looks like one of these. But obviously, I won't ask you the same thing, because that's kind of lame. All right, so any other questions, concerns, or whatever for the last and final lecture? Yeah? Just as an aside, for the previous question, when you run the cd command, couldn't you have some sort of copy"}
{"text": " Yeah, so. Yeah, so you could have copy on write on this, but it would behave like you have copy on write on memory, right? If you have copy on write on memory, as far as you're concerned, it's an actual copy, like it behaves like an actual copy. You were just way more clever about it, but."}
{"text": " Even if this could use copy-on-write, you just wouldn't know about it. Just like virtual memory uses copy-on-write, and you have no idea. It still looks like a copy. But if it needs to make, it just delays doing the copying to the latest possible period. All right. Yeah. Any other questions, concerns, or whatever? Probably should have written down what I did, because that was probably a dead giveaway."}
{"text": " God, I really need to just shut up. All right, well, on that note, pulling for you, we're all in this together."}
{"text": " Okay? This is linear algebra, lecture eleven, and at the end of lecture ten, I was talking about some vector spaces, but the things in those vector spaces were not what we usually call vectors. Nevertheless, you could add them and you could multiply by numbers. So we can call them vectors."}
{"text": " I think the example I was working with, they were matrices. So the mat- so we had, like, a matrix space, the space of all three by three matrices. And I'd like to just pick up on that."}
{"text": " Because, we've been so specific about n-dimensional space here, and you really want to see that the same ideas work as long as you can add and multiply by scalars. So these new vector spaces, the example I took was the space M of all"}
{"text": " three by three matrices. OK? I can add them, I can multiply by scalars. I can multiply two of them together, but I don't do that. That's not part of the vector space picture. The vector space part is just adding the matrices and multiplying by numbers, and"}
{"text": " That's fine, we stay within this space of three by three matrices. And I had some subspaces that were interesting, like the symmetric, the subspace of symmetric matrices, symmetric three by threes. Or the subspace of upper triangular three by threes."}
{"text": " I use the word subspace because it follows the rule. If I add two symmetric matrices, I'm still symmetric. If I multiply two symmetric matrices, is the product automatically symmetric? No. But I'm not multiplying matrices. I'm just adding, so I'm fine, this is a subspace. Similarly, if I add two upper triangular matrices, I'm still upper triangular."}
{"text": " And, that's a subspace. Now, I just want to take these as examples and ask, well, what's the basis for that subspace? What's the dimension of that subspace? And what's the dimension of the whole space? So, there's a natural basis for all three by three matrices. And why don't we just write it down. So, so M, a basis."}
{"text": " Again, all three by threes. OK. And then I'll just count how many members are in that basis, and I'll know the dimension. And, OK, it's going to take me a little time. In fact, what is the dimension? Any idea of what I'm coming up with next?"}
{"text": " numbers does it take to specify that three by three matrix? Nine. Nine is the dimension I'm going to find, and the most obvious basis would be the matrix that's that matrix, and then this matrix with a one there, and that's two of them. Shall I put in the third one?"}
{"text": " and then onwards and the last one maybe would end with the one. OK. That's like the standard basis. In fact, our space is practically the same as nine-dimensional space. It's just the nine numbers are written"}
{"text": " in a square instead of in a column. But somehow it's different and ought to be thought of as natural for itself. Because now what about the symmetric three by threes? So that's a subspace. Let's just think, what's the dimension of that subspace and what's a basis for that subspace?"}
{"text": " OK? And I guess this question occurs to me. If I look at this subspace of symmetric three by threes, well, how many of these original basis members belong to the subspace? I think only three of them do. This one is symmetric."}
{"text": " This last one is symmetric, and the one in the middle with a one in that position, in the two two position, would be symmetric, but the so I've got three of these original nine are symmetric, but so this is an example where, but that's not all, right? What's the dimension? Let's put the dimensions down. Dimension of M."}
{"text": " was not. What's the dimension of, shall we call this S? Is what? What's the dimension of this? I'm sort of taking simple examples where we can spot the answer to these questions. So how many, if I have a symmetric, think of all symmetric matrices as a subspace,"}
{"text": " How many parameters do I choose in three by three symmetric matrices? Six, right. If I choose the diagonal, that's three, and the three entries above the diagonal, then I know what the three entries below. So the dimension is six."}
{"text": " I guess what's the dimension of this here? Let's call this space U for upper triangular. So what's the dimension of that space of all upper triangular three by threes? Again six. Again six. And,"}
{"text": " But we haven't got a, we haven't seen a ba- well, actually, maybe we have got a basis here for, the upper triangulars. I guess six of these guys, one, two, three, four, and a couple more, would be upper triangular. So there's an accidental case where the big basis contains in it a basis for the subspace. But with the symmetric guy, it didn't happen."}
{"text": " The symmetric guy, the basis so you see what a basis is the basis for the big space. We generally need to think it all over again to get a basis for the subspace. And then how do I get other subspaces? Well, we spoke before about the subspace, the symmetric matrices and the upper triangle. This is symmetric."}
{"text": " and upper triangular. OK. What's the, what's the dimension of that space? What's in that space? So if a matrix is symmetric and also upper triangular, that makes it diagonal. So this is the same as the diagonal matrices,"}
{"text": " diagonal three by threes, and the dimension of this, of S intersect U, right? You're OK with that symbol? That's the vectors that are in both S and U, and that's D, so S intersect U is the diagonals, and the dimension of the diagonal matrices is three."}
{"text": " And we've got a basis, no problem. OK, as I write that, I think, OK, what about putting together so this is like this intersection is taking all the vectors that are in both, that are symmetric and also upper triangular. Now, we looked at the union."}
{"text": " Suppose I take the matrices that are symmetric or upper triangular. What, why was that no good? So why is, why is it no, why is, why am I not interested in the union putting together those two subspaces?"}
{"text": " So these are matrices that are in S or in U, or possibly both, so the diagonal's included. But what's bad about this? It's not a subspace. It's like taking, you know, a couple of lines in the plane and stopping there."}
{"text": " A line, this is so there's a three-dimensional subspace of a nine-dimensional space, there's oh, sorry, six. There's a six-dimensional subspace of a nine-dimensional space, there's another one, but they're headed in different directions, so we can't just put them together, we have to fill in. So that's what we do. To get this bigger space that I'll write with a plus sign, this is combinations."}
{"text": " of things in S and things in U. OK. So that's the final space I'm going to introduce. I have a couple of subspaces, I can take their intersection, and now I'm interested in not their union but their sum. So this would be the, this is the intersection and this will be their sum. So what's, what do I need for a subspace here?"}
{"text": " I take anything in S plus anything in U. I don't just take things that are in S and pop in also separately things that are in U. This is the sum of any element of S, that is, any symmetric matrix, plus any in U, any element of U."}
{"text": " Okay. Now, as long as we've got an example here, tell me what we get. If I take every symmetric matrix, take all symmetric matrices and add them to all upper triangular matrices, then I've got a whole lot of matrices and it is a subspace. And what's the or it's a vector space and what vector space would I then have?"}
{"text": " Any idea what matrices can I get out of a symmetric plus an upper triangular? I can get anything. I get all matrices. I get all three by threes. It's worth thinking about that. It's just, like, stretch your mind a little, just a little, to think of these subspaces"}
{"text": " and what their intersection is and what their sum is. And now can I give you a little, oh, well, let's figure out the dimension. So what's the dimension of S plus U in this example is? Nine, because we got all three by threes."}
{"text": " The original spaces had the original symmetric space had dimension six and the original upper triangular space had dimension six. And actually I'm seeing here a nice formula. That the dimension of S plus the dimension of U"}
{"text": " If I have two subspaces, the dimension of one plus the dimension of the other equals the dimension of their intersection plus the dimension of their sum. Six plus six is three plus nine."}
{"text": " It's kind of satisfying that these natural operations, and this is it, actually. This is the set of natural things to do with subspaces, that the dimensions come out in a good way. OK. Maybe I'll take just one more example of a vector space that doesn't have vectors in it."}
{"text": " It's say take come from differential equations. So this is a one more new vector space that we'll give just a few minutes to. Suppose I have a differential equation like d second y dx squared plus y equals zero. Okay. I look at the solutions to that equation."}
{"text": " So what are the solutions to that equation? y equals cos x is a solution. y equals sine x is a solution. y equals, well, e to the ix is a solution, if you allow me to put that in. Oh, but why should I put that in? It's already there."}
{"text": " You see, I'm really looking at a null space here. I'm looking at the null space of a differential equation. That's the solution space. And describe the solution space, all solutions, to this differential equation. So the equation is y double prime plus y equals zero. Cosine's a solution, sine is a solution. Now tell me all the solutions."}
{"text": " They're so I don't need e to the ix, forget that. What are all the complete solutions? Is what? A combination of these. The complete solution is y equals some multiple of the cosine plus some multiple of the sine."}
{"text": " That's a vector space. That's a vector space. What's the dimension of that space? What's a basis for that space? OK, let me ask you a basis first. If I take the set of solutions to that second-order differential equation, there it is, those are the solutions. What's a basis for that space?"}
{"text": " Now remember, what question am I asking? Because if you know the question I'm asking, you'll see the answer. A basis means all the guys in the space are combinations of these basis vectors. Well, this is a basis. Sine x, cos x, there is a basis. Those two."}
{"text": " They're like the special solutions, right? We had special solutions to Ax equal b. Now we've got special solutions to differential equations. Sorry. We had special solutions to Ax equals zero. I misspoke. The special solutions were for the null space, just as here we're talking about the null space. Do you see that here is a those two and what's the dimension?"}
{"text": " of the solution space is how many vectors in this basis? Two. The sine and cosine. Are those the only basis for the space? By no means. e to the ix and e to the minus ix would be another basis. Lots of bases."}
{"text": " But do you see that really what a course in differential, in linear differential equations is about is finding a basis for the solution space. The dimension of the solution space will always be, will be two, because we have a second order equation."}
{"text": " So that's, like, there's 18.03 in five minutes of 18.06 is enough to take care of 18.03. OK. So there's a, that's one more example, and of course the point of the example is these things don't look like vectors. They look like functions. But we can call them vectors, because we can add them,"}
{"text": " And we can multiply by constants, so we can take linear combinations. That's all we have to be allowed to do. So that's really why this idea of linear algebra and basis and dimension and so on plays a wider role than our constant discussions of m by m matrices. OK. That's what I wanted to say about that topic."}
{"text": " Of course the key number associated with matrices, to go back to that number, is the rank. And the rank, what do we know about the rank?"}
{"text": " Well, we know it's not bigger than M and it's not bigger than N. So but I'd like to have a little discussion on the rank. Maybe I'll put that here. So I'm picking up this topic of rank one matrices. And the reason I'm interested in rank one matrices is that they ought to be simple."}
{"text": " If the rank is only one, the matrix can't get away from us. So for example, let me create a rank one matrix. OK, suppose it's two by three. And let me give you the first row. What can the second row be?"}
{"text": " Tell me a possible second row here, for this matrix to have rank one. A possible second row is? Two a ten. The second row is a multiple of the first row. It's not independent. So tell me a basis for the oh yeah, sorry to"}
{"text": " Keep bringing up these same questions. After the quiz I'll stop, but for now, tell me a basis for the row space. A basis for the row space of that matrix is? The first row, right? The first row one four five. A basis for the column space of this matrix is? What's the dimension of the column space?"}
{"text": " The dimension of the column space is also one, right? Because it's also the rank. The dimension, you remember, the dimension of the column space equals the rank equals the dimension of the column space of the transpose, which is the row space of A. OK, and in this case, it's one, R and one."}
{"text": " And sure enough, all the columns are, all the other columns are multiples of that column. Now, there's, there ought to be a nice way to see that, and here it is. I can write that matrix as its pivot column, one two, times its, times one four five."}
{"text": " A column times a row, one column times one row gives me a matrix, right? If I multiply a column by a row, that's two by one matrix times a one by three matrix, and the result of the multiplication is two by three, and it comes out right. So what I want to, my point is that rank one"}
{"text": " matrices, that every rank one matrix has the form sum column times sum row. So U is a column vector, V is a column vector, but I make it into a row by putting in V transpose. So that's the, that's the, that's the complete picture of rank one matrices."}
{"text": " We'll be interested in rank one matrices. Later we'll find, oh, their determinant, that'll be easy, their eigenvalues, that'll be interesting. Rank one matrices are like the building blocks for all matrices. And actually, maybe you can guess. And if I took any matrix,"}
{"text": " A five by seventeen matrix of rank four. Then it seems pretty likely, and it's true, that I could break that five by seventeen matrix down as a combination of rank one matrices. And probably how many of those would I need? If I have a five by seventeen matrix of rank four, I'll need four of them."}
{"text": " four rank one matrices. So the rank one matrices are the building blocks. And I can produce every rank four matrix out of four rank one matrices. OK. That brings me to a question, of course. Would the rank four matrices form a subspace?"}
{"text": " Let me take all five by seventeen matrices and think about rank four matrix, the subset of rank four matrices. Let me, I'll write this down. You see I'm reviewing for the quiz, actually. Because I'm asking the kind of questions that are short enough but that bring out do you know what these words mean."}
{"text": " So I take my matrix space N now is all five five seventeen matrices. And now the question I ask is the subset of rank four matrices."}
{"text": " If I add a matrix of, so if I multiply a matrix of rank four by, of rank four or less, let's say. Because I have to let the zero matrix in. If it's going to be a subspace. But that doesn't, just because the zero matrix got in there doesn't mean I have a subspace. So if I, so the question really comes down to if I add two rank four matrices,"}
{"text": " Is the sum rank four? What do you think? No. Not usually. Not usually. If I add two rank four matrices, the sum is probably what could I say about the sum? Well, actually."}
{"text": " Well, the rank could be five. It's a general fact, actually, that the rank of A plus B can't be more than rank of A plus the rank of B."}
{"text": " So this would say if I added two of those, the rank couldn't be larger than eight, but I know actually the rank couldn't be as large as eight anyway. What, how big could the rank be for the rank of a matrix in M? Could be as large as five. Right. Right. So they're all sort of natural ideas. So rank four matrices or rank one matrices, let me change that to rank one,"}
{"text": " Let me take the subset of rank one matrices. Is that a vector space? If I add a rank one matrix to a rank one matrix? No. It's most likely going to have rank two. So this is, so I'll just make that point. Not a subspace. OK. OK. Those are topics that I wanted to,"}
{"text": " fill out the previous lectures. I'll ask one more subspace question, a more likely example. Suppose I'm in, let me put this example on a new board. Suppose I'm in R four."}
{"text": " So my typical vector in R4 has four components, v1, v2, v3, and v4. Suppose I take the subspace of vectors whose components add to zero. So I let s."}
{"text": " vectors v in four-dimensional space with v1 plus v2 plus v3 plus v4 equals zero. So I just want to consider that bunch of vectors. Is it a subspace, first of all? It is a subspace. It is a subspace. What's the, how do we see that?"}
{"text": " It is a subspace. I formally I should check if I have one vector that with whose components add to zero and I multiply that vector by six, the components still add to zero, just six times zero. If I have a couple, a v and a w, and I add them, the components still add to zero. OK, it's a subspace."}
{"text": " What's the dimension of that space and what's the basis for that space? So you see how I can just describe a space and we can ask for the dimension, ask for the basis first and the dimension, of course the dimension's the one that's easy to tell me in a single word, what's the dimension of our subspace S here?"}
{"text": " and a basis. Tell me some vectors in it. Well, I'm going to make you, ask you again to guess the dimension. Again, I think I heard it. Three. The dimension is three. Now how does this connect to our,"}
{"text": " Ax equals zero, is this the null space of something? Is that the null space of a matrix? And then we can look at the matrix and we know everything about those subspaces. This is the null space of what matrix?"}
{"text": " What's the matrix where the null space is then A B equals zero. So I want this equation to be A B equals zero. V is now the vector. And what's the matrix that we're seeing there? It's the matrix of four ones. Do you see that that's?"}
{"text": " that if I look at A B equals zero, for this matrix A I multiply by B and I get this requirement, that the components add to zero. So I'm really, when I speak about S, I'm speaking about the null space of that matrix. Okay. Let's just say we've got a matrix now, we want its null space. Well, tell me its rank first."}
{"text": " The rank of that matrix is one, thanks. So R is one. What's the general formula for the dimension of the null space? The dimension of the null space of a matrix is, in general, an m by m matrix of rank R. How many independent guys in the null space?"}
{"text": " n-r, right? n-r. In this case, n is four, four columns, the rank is one, so the null space is three-dimensional. So, of course, you could see it in this case, but you could also see it here in our systematic way of dealing with the four fundamental subspaces of a matrix."}
{"text": " So what actually what are all four subspaces, then? The row space is clear. The row space is in R4. Yeah, can we take the four fundamental subspaces of this matrix? Let's just kill this example. The row space is one-dimensional. It's all multiples of that row."}
{"text": " The null space is three-dimensional. Oh, you better give me a basis for the null space. So what's the basis for the null space? The special solutions. To find the special solutions, I look for the free variables. The free variables here are, there's the pivot. The free variables are two, three and four. So the basis, basis for S,"}
{"text": " for S will be, I'm expecting three vectors, three special solutions. I give the value one to that free variable, and what's the pivot variable if this is going to be a vector in S?"}
{"text": " Minus one. Now the entries add to zero. The second special solution has a one in the second free variable, and again a minus one makes it right. The third one has a one in the third free variable, and again a minus one makes it right. That's my answer. That's the answer I would be looking for."}
{"text": " The basis for the subspace S, you would just list three vectors and those would be the natural three to list. Not the only possible three, but the, the, those are the special three. OK. Tell me about the column space. What's the column space of this matrix A?"}
{"text": " So the column space is a subspace of R one, because n is only one, the columns only have one component. So the column space of S, the column space of A is somewhere in the space R one, because we only have these columns are short. And what is the column space actually?"}
{"text": " I just, it's just talking with these words is what I'm doing. The column space for that matrix is R1. The column space for that matrix is all multiples of that column, there's a, and all multiples give you all of R1."}
{"text": " And what's the remaining fourth space, the null space of A transpose? Is what? So we transpose A, we look for combinations of the columns now that give zero for A transpose, and there aren't any."}
{"text": " The only thing, the only combination of these rows to give the zero row is the zero combination. OK. So let's just check dimensions. The null space has dimension three, the row space has dimension what? Three plus one is four. The column space has dimension one, and what's the dimension of this?"}
{"text": " like smallest possible space. What's the dimension of the zero space? It's a, it's a subspace. Zero. What else could it be? I mean, let's, we have to take a reasonable answer and the only reasonable answer is zero, so one plus zero gives this was n, the number of columns, and this is m, the number of rows."}
{"text": " And let me just say again, then, the subspace that has only that one point, that point is zero-dimensional, of course. And the basis is empty, because if the dimension is zero, there shouldn't be anybody in the basis. So the basis of that smallest subspace is the empty set,"}
{"text": " And the number of members in the empty set is zero, so that's the dimension. OK. Good. Now I have just five minutes to tell you about, well, actually about some, this is now this last topic of small world graphs and leads into a lecture about graphs."}
{"text": " and linear algebra. But let me tell you the, in these last minutes, the graph that I'm interested in. It's the graph where, so what is a graph? Better tell you that first. Okay. What's a graph? Okay. This is a calculus. We're not, I'm not thinking of, like, some sine curve."}
{"text": " The word graph is used in a completely different way. It's a set of a bunch of nodes and edges. Edges connecting the nodes. So I have nodes like five nodes, and edges, I'll put in some edges, I could include them all,"}
{"text": " There's, well, let me put in a couple more. There's a graph with five nodes and one, two, three, four, five, six edges. And some five by six matrix is going to tell us everything about that graph. Let me leave that matrix to next time and tell you about the question I'm interested in. Suppose, suppose the graph"}
{"text": " isn't just, doesn't have just five nodes, but suppose every person in this room is a node. And suppose there's an edge between two nodes if those two people are friends. So have I described a graph? It's a pretty big graph, hundred nodes, and I don't know how many edges are in there."}
{"text": " There's an edge if you're friends. So that's the graph for this class. A similar graph you could take for the whole country. So 260 million nodes and edges between friends. And the question for that graph is how many steps does it take to get from anybody to anybody?"}
{"text": " What's, what two people are furthest apart in this friendship, say, for the U.S.? By furthest apart, I mean the distance from, well, I'll tell you my distance to Clinton. It's two. I happen to go to college with somebody who knows Clinton. I don't know him. So my distance to Clinton is not one, because I don't,"}
{"text": " happily or not, don't know him, but I know somebody who does. He's a senator and so I presume he knows him. OK. I don't know what your, well, what's your distance to Clinton? Well, not more than three, right. Actually, true. You know me, I take credit for reducing your Clinton distance. What's your distance to Monica?"}
{"text": " Not, anybody below four is in trouble here. Or maybe three, but, right."}
{"text": " And what's Hillary's distance from Monica? I don't think we'd better put that on tape here. One or two, I guess. Is that right? Well, we won't think more about that. So actually, the real question is, what are big, large distances? How far apart could people be separated?"}
{"text": " And roughly this number six degrees of separation has kind of appeared, it's a movie title, it's a book title, and it's with this meaning, that roughly speaking, six might be a fairly, not too many people, if you sit next to somebody on an airplane,"}
{"text": " you get talking to them, you begin to discuss mutual friends to sort of find out, OK, what connections do you have, and very often you'll find you're connected in like two or three or four steps, and you remark it's a small world, and that's how this expression small world came up."}
{"text": " But six, I don't know if you could find, if it took six, I don't know if you would successfully discover those six in a, in an airplane conversation. But here's the math question and I'll leave it for next, for lecture twelve and do a lot of linear algebra in lecture twelve. But the, the interesting point is that with a few shortcuts, the distances come down dramatically."}
{"text": " that, I mean, all your distances to Clinton immediately drop to three by taking linear algebra. That's like an extra bonus for taking linear algebra. And to understand mathematically what it is about these graphs, or like the graphs of the World Wide Web."}
{"text": " There's a fantastic graph. So many people would like to understand and model the web, where the edges are links and the nodes are sites, websites. I'll leave you with that graph. And I'll see you, have a good weekend and see you on Monday."}
{"text": " All right, whoops, I need to do this. All right, welcome back to operating systems. Things seem to work. So, that's not good."}
{"text": " Okay, so today we will talk more about operating systems. This lecture also will be a thing that you don't have to 100% know everything about. It will be a lot of interest stuff. Some stuff might go over your head, and that's okay. So, we're going to talk about libraries because you are going to make libraries, and they are a core part of an operating system, so we should learn about them. So first off,"}
{"text": " Question to you. Well, we actually haven't answered the question, what exactly is an operating system? Because there's actually, the answer is it kind of depends. So we know that the kernel is definitely part of the operating system. It operates in kernel mode. Good to know."}
{"text": " But for instance, is macOS, iOS, iPadOS, watchOS, tvOS, are they all different operating systems? Or what's the difference between them? Anyone want to tell me what the difference between them are? First one, they work on different devices, so they might be different operating systems."}
{"text": " Yeah, they have different, they kind of have different interfaces, and Apple says so, so I should listen to them. Any other one? Anyone else with any ideas why these are different? Or marketing BS, maybe? They're actually the same, so. So different application, or, well, let's get into it."}
{"text": " So applications, that's what we ultimately, at the end of the day, actually care about, right? Whenever I had the three core things, it was applications, on top of operating system, on top of, I shouldn't punch that, on top of the hardware. So libraries are an important part of an operating system, and what libraries you have to use depends on what your application does. So here's three applications, network manager, which is like a low-level,"}
{"text": " low-level application to manage your Wi-Fi, your Ethernet connections, all that fun stuff. LibreOffice, which is basically an open-source clone of Microsoft Office and Firefox. So those are all three different applications, and they might use different libraries."}
{"text": " All of them probably use the C standard library, and then things are built on top of that. So on Linux, there is a display server if you want to display any graphics, and the current one is called Wayland. That will let you have access to direct graphics."}
{"text": " CPU buffers and stuff like that. So maybe you don't want to use that directly. So maybe you use another library that has a GUI toolkit. On Linux, one of them is called JTK. And that will render buttons for you instead of just raw buffers that you might not care about. So Firefox uses JDK to render some user interface elements."}
{"text": " So it would use that library. But Firefox is a web browser. It does page layout and stuff like that. So it actually uses Wayland directly and just displays all your web pages because it renders them itself."}
{"text": " And it might also have something to do with the system daemon. So this kind of abstracts some hardware on your machine and will make some requests for you. We won't have to use that in that course, but it's one of the things it's called, that it is used. So Firefox might use all these together in order to work correctly. While LibreOffice might not request any details to hardware, it might just use the GUI toolkit, and that's about it."}
{"text": " Network manager might not use the GUI toolkit and it might use like the Udev directly. So what's an offering system, what libraries you need actually depends on the application. There's kind of no one size fits all answer."}
{"text": " So it depends. So for the Apple example, well, all those operating systems actually run the same kernel. And they're exactly the same in that respect. A lot of the libraries under the hood are exactly the same. They're 95% the same. But they all run different applications, because you can consider Apple makes a distinction between a watch application"}
{"text": " tablet application, phone application that have their own certain set of standards. So Apple is right in calling them different operating systems because it expects a certain type of application. But if Apple was a bit more open, it might depend on what applications you want to run."}
{"text": " So for instance, Android and your Debian VM both use Linux. Linux is the kernel. And depending on the application, if you just have your little Hello World application or something you've written in 105, well,"}
{"text": " Android uses Linux. It has a standard C library. You could run your application on your phone if you wanted to. It would work perfectly well. You wouldn't have to do anything special. So if those were the only applications you cared about, well, Android and Debian would actually probably be considered the same offering system. Just no one is sick enough to actually run terminal applications on their phone and compile stuff on their phone. But if you really wanted to, you could have done 105"}
{"text": " completely on your phone if you really wanted to. But again, you would probably have to be fairly crazy, like myself. So they might be the same if you only care about terminal applications. Otherwise, Android applications are a thing. So they would be very distinct operating systems. You couldn't just run an Android application on Debian and think that it's going to work."}
{"text": " So Linux distributions might be considered, so Linux is just the kernel. You might call a full operating system GNU slash Linux if you have ever heard of that terminology before. Basically, GNU distributes the standard C library, which is a core part since basically every application uses it, and gives you all the standard utility commands like cp, ls, all that stuff is written by them."}
{"text": " So you might call Debian a new Linux if you want to be a generic term for that type of software stack. But basically, at the end of the day, an operating just consists of a kernel because, well, something has to run in kernel mode, so an operating system will always have a kernel. And then it's any required libraries for your application. So if you just use a kernel directly, well, you don't need any libraries, but your life is going to be very difficult."}
{"text": " Now we have to do some review in order to talk about libraries. So we have to talk about how C compilation works and all of that fun stuff. So this should be of no surprise for you if you've ever created an executable with multiple C files. And if this is new,"}
{"text": " which it is for at least one person, then this is how it works. So if you have multiple C files together, this may have been hidden from you in the past, but what basically is going to happen is you write some code in the C files. Your compiler is going to compile each of those C files individually and create a compiled version of that file called an object file. Don't really need to know that for the course, although it's basically the compiled version of your code."}
{"text": " So end in .o. And then at the end of the day, it will link them all together. So that basically is just a generic term for it. It will combine all of those files together, all the compiled version of those files together, to form your executable. So that executable will have instructions for every single function you wrote in C. So any questions about that?"}
{"text": " So that may have been hidden for you. If you used make before or any other build system, it would have hidden this from you and done the compilation and link step for you. But if you separate it out and you know what's going on, this is what will happen."}
{"text": " So static libraries are basically the same thing, except they're just going to reuse something. So instead of combining everything into the executable and compiling it all individually, well, say I want to reuse that util, that foo, and that bar. Well, instead of just having them have a .o file and linking it,"}
{"text": " Well, I can combine those .o files, which have the function definitions and everything in them, into an archive. And this archive will basically just, it'll consist of all those .o files just sandwiched together. So this lib.a will just have all of these in it in just one file. But lib.a actually, you can think of it as actually containing those three files. Yep? Sorry, but are those three .o's the ones I wrote, or are they?"}
{"text": " Yeah, so those 3.0s would be the same ones from here. Yeah, so the question is, why is the compiler deciding to put it in the library? So the compiler doesn't decide. This is something you decide as a developer."}
{"text": " This is me deciding as a developer, I want to reuse the code that's in util, foo, and bar. So I will create a static library. So that way, whenever I create an executable, I just have to link together main.o and lib.a to create that executable. It behaves the same. And the idea behind that is, well,"}
{"text": " If I wanted to create a new executable with, like, main2.c, I could just replace main2.c and use lib.a, and I don't have to compile everything and link it together. I just say, use lib.a. So it just saves us some time. Otherwise, it behaves exactly the same. It's just a way for you to specify, I want to bundle these together because I might reuse them again. But behaviorally, it's just a, and you have to organize it this way. This is something you pick."}
{"text": " And you probably mean you haven't had to pick this yet, but eventually you might have to make this decision. What code you write is actually going to be reusable. So this is a static library, behaves exactly the same. I'm just bundling things together so I can reuse it. So in computer science,"}
{"text": " Always, if I say there's a static something, that means there's a dynamic something. It kind of always comes together. So you may have noticed that the C standard library is not a .a file. It's a .so file. So on Linux, dynamic libraries will be .so, which stands for shared object. On Windows, these might be known as DLL files. On Mac OS, they're called DYLIB files."}
{"text": " They're all the same thing, it depends on the operating system. But the idea behind that is kind of the same idea as static libraries, but there's one key difference. But the idea is still the same, that I have two applications that want to use the same code, so I don't wanna just reuse things, or I don't wanna waste space or reuse things over and over again. I want them both to just use the same code."}
{"text": " And that's why the standard C library is a dynamic library. So if you have two applications both using it, the operating system can be smart about it and just load it into memory the first time you use the standard C library. And then if another application uses it, the operating system can be smart enough to say, hey, I already loaded it into memory, so this program can also use it and we'll see how that sharing would actually work."}
{"text": " once we get to virtual memory, but that's the idea behind it. It's supposed to save some memory because I can actually share some information. So, how it looks. It looks very similar to the static library. So, it's the same idea, but instead of creating a lib.a that has all the .o files,"}
{"text": " I create a lib.so, and I have to specify a special flag to the compiler that does some low-level things a bit different, but essentially it does the same thing, and just smushes them all together in that lib.so file. So that lib.so file will contain the definition for any functions that were in those C files. Yep? So I kind of missed that part. Does lib.so exist?"}
{"text": " even after the compilation process completes? Yeah, so lib.so would be the result of after the compilation and the linking process. So it's the thing we actually care about. Thank you. Yeah, so like libc is a .so file. Yep? Will the executable that has static library be larger than the one that has the dynamic one? Will it be larger inside?"}
{"text": " Yeah, so the question is if the static one will be larger than the dynamic one. And the answer to that is yes. So in this case, in the static case, we're essentially just shoving all those files into the executable. So it's going to include all the function definitions and everything. And then here in the dynamic case, we're not going to do that."}
{"text": " This lib.so file will have all the definitions, but whenever we link to create an executable, we're not going to sandwich all those function definitions in our executable. We're just going to say, hey, whenever you run this program, I need this library to run. And the operating system will have to look it up whenever you run your program. So I would say,"}
{"text": " I have a main, and everything else I'm going to reuse, and it's in my library. So just my executable just consists of main. And then whenever you run that executable, the operating system is going to look up that dynamic library, and then any functions you call, it will actually call those ones. Yeah? The difference between compiling a static and dynamic library is just the compiler flag, essentially?"}
{"text": " Yes. Yeah, so the question was, well, is the only difference a compiler flag? And to create them, yeah, the only difference is a compiler flag. And the difference here is, in the static case, all the library is included in the executable. In the dynamic case, the library stands by itself, and it's used and looked up whenever you run it. So that will bring us some interesting benefits and drawbacks."}
{"text": " Oh, and also, there's this useful command line utility if you get into deep system programming. So you can use LDD on any executable, and it will tell you what dynamic libraries it uses. So it's a fun thing to poke around with. Won't have time to do that, but you can go ahead and do that."}
{"text": " So you might think, hey, they're static and dynamic. Why do I have both of them? When should I use one versus the other? So again, with static, basically it's just copying all that code and just shoving it in your executable whenever you compile it. And in the dynamic case, it's going to keep it separate and then look it up at runtime. So some drawbacks, well,"}
{"text": " Software evolves over time, right? People change it, they update it, hopefully they make it better. So if the library you're using is a static library and you're relying on it and you're using it, if they produce a new update or something like that that fixes something, you have to recompile your program because it's included in the executable. So if they make an update, you have to recompile everything. That's okay if you,"}
{"text": " have control for all the source code and you're using open source and all that, that might be okay. But if you don't have access to the source code, that might not be a thing. Whoops, so that's not good. And yeah, so that's not great if you have to recompile for every update. And another issue is, well, it also wastes a lot of space. So think if,"}
{"text": " The standard C library was a static library. Well, that would mean that every executable that uses printf would have the definition of printf in the executable. So in that case, if I have 1,000 executables, I have 1,000 copies of printf, just wasting space. Wasting hard drive space, and then if I execute them, they'd all waste, I keep hitting that, sorry. They would waste memory because"}
{"text": " that would be independent. The operating system wouldn't know they're actually the same. So it would waste space both on your hard drive and in memory. And while with dynamic libraries, I just have one copy of printf in that standard C library, and then every single program uses it. So can anyone think of any issues with having dynamic libraries? Yeah. Oh, sorry, go. You first?"}
{"text": " I just wanted to repeat the question. I didn't really hear that. Oh, so the question is, what's the issues with using dynamic libraries? If for static, any update, I have to recompile everything. You're not guaranteed to actually have the dynamic library available, unlike static, where it's actually built into the executable. OK, sorry. Let me rephrase the question. So is there an issue with dynamic library updates?"}
{"text": " will result in bugs or stuff like leading to unprecedented results if a program runs on an older version of a dynamic library? Yeah. Were you going to say the same thing? I was going to say the same thing. Same thing? OK. Yeah? Does that mean a program has to restart to receive the update from the dynamic library? Yes. Yeah. Same comment? The same thing if the version is set here."}
{"text": " Okay, yeah, that's another one. So to repeat that few issues, well."}
{"text": " You might have to recompile it if a static library updates, which kind of sucks, but with dynamic, you don't have to recompile it, but you're not guaranteed every update is good. So if it's an update that breaks something, then suddenly everything is broken, right? Because they're all relying on the one thing, then everything's broken. So if you're using a shared library, you better be sure that if you're making it, you better be sure whenever you update the code,"}
{"text": " you do things correctly, otherwise you'll break everything, which is not good."}
{"text": " Another comment is, well, if the application's already running and you update it, it might also have some problems. Some kernels will keep the version that started with when you launched it and not do like a halfway update. So that's another issue. That's a bit trickier. But yeah, the core one is, well, the update might just suck, right? So this actually happened back, I forget what year it was, but basically,"}
{"text": " The standard C++ library did an oopsie and broke something. And suddenly, every single program on your machine died. And everyone just had to recompile everything in order to fix it. And it sucked. So we're going to see an example of that. And it's really subtle what will break things. So yeah, major drawback is dynamic libraries can break"}
{"text": " can just break executables. And the change can be really, really subtle. So for example, if you didn't know this before, well, if you defined a struct in C,"}
{"text": " and you have fields in it, well, the way you define the fields, there is a certain way that is laid out in memory, and that is defined in the C standard, so that C compilers agree with each other, so that if you compile a struct in GCC and Clang, and then you're calling code between them,"}
{"text": " Well, if they agree on the layout of a struct, then they'll both agree and everything will be fine. It's the same thing that you had when you made function calls in assembly. Both sides have to agree. It's the same thing for compilers. Basically, all computers, it's just people agreeing on things over and over again and not breaking that social contract. And that's basically the only way computers work, which is kind of scary and kind of amazing how they actually work."}
{"text": " But at the end of the day, that's like most things in computers. So in this example, we might have an executable that uses a struct that is also used in the dynamic library. And bad things are going to happen. So there's some other text on the slide. Let's just get into example."}
{"text": " So, like I said, structs are laid out in memory a very specific way in C. So, let's say I was creating a library for a point. So, a point that just has an X and a Y. So, I might have something like this. So, I might assign struct point, I will say, it Y in X."}
{"text": " Everyone would agree with me that that is a good struct for a point. It has an x and a y. They're ints. Joy. So later, I might change my mind and be like, why did I say y then x? So later, I might come along and change it to this version. I might just say, well, for my struct point, x should come first, and then y should come first."}
{"text": " If you get into the detail of what the compiler actually does, these are actually represented in memory different. So you might see this term offset in this course. You can think of that as like an index into an array, except offsets are always just done in bytes. But otherwise, it's the same idea. So for version 1, the x field is offset by"}
{"text": " 4 bytes because the size of an int is 4 bytes. So the first thing in the struct is a y. So the first 4 bytes of the struct would represent y. And then the next 4 bytes would represent x. So you would say x starts at offset 4 or 4 bytes from the beginning."}
{"text": " And then in version two, it's offset by zero bytes because it's at the start, and this change is not an API change because both of the structs, I can describe them the same way. They both have an x and a y, and they're both ints. So I didn't change the API. I just changed the order, which actually changed the ABI."}
{"text": " So to explain it in a bit different, in case that didn't make sense, in both versions, the compiler could represent them both as an array of two ints, if you want to think about it that way, if that way is easier. And in the first version, it changes where y is and where x is. So in version 1, y is at index 0, and x is at index 1."}
{"text": " And in version two, when I swap the order, then in this case, x is at index zero and y is at index one. So any disagreements with that? Hopefully, yes. So this might make more sense to represent it. So let's go into the library itself. Between both of them, my library is going to be exactly the same. So this is not what I want."}
{"text": " So let's close this. So here is the C file that represents my library. And it's just gonna be one C file. So it uses point.h, which has that struct in it. Otherwise, I'm not going to change this between the two versions. The only difference is that struct. So in here, I'll have point create that creates a point, it does the malloc, and then it sets the fields. And then there's a getX."}
{"text": " And then there's a getY, and there's a destroy, which just calls free. So this is the code that is part of my library. Now, the code that uses the library is this code. So this is a point example, and it contains main, and this will be the only content of my executable."}
{"text": " So it uses point.h. So just reading point.h, you don't know what version. So it depends on what version. So this might be version 1 or version 2, depending on whatever I compile it with. So then in here, it will create a point where x is 1, y is 2. So remember, x is supposed to be 1, y is supposed to be 2."}
{"text": " So then I have two printfs. So I have a printf that uses the library. So I print off x and y using the accessors getX and getY. And then here, I'm printing them off using the struct. So now, if I compile this with version 1 and my library with version 1, whoops, that's probably confusing being up there."}
{"text": " Sorry, let me reset up it. So if I compile it with version 1 and I use version 1 of the library, they'll both agree with each other. So I'll see x is 1, y is 2. So there's a way to simulate."}
{"text": " There's a way to play with dynamic libraries on Linux using environment variables. So I can simulate an update by doing something like this. So this, if you haven't seen it before, will set an environment variable called LDLibraryPath. And I'm pointing it to version 2 of my library to simulate an update to just the dynamic library."}
{"text": " So what this will do is force the operating system to first look for libpoint in that directory before it uses the default directories. So this sets an environment variable and then tries to run the same executable. So this will simulate me just updating the library to version 2. So if I go ahead and run this, again, same executable I'm running. The only difference is what library I use whenever I run it."}
{"text": " Yikes. So you see the first line is still correct, 1, 2, but the other one flipped. And this is a really subtle change, but you could imagine that might have a profound impact. So imagine this was drawing a user interface or something like that, and your x and y's had to make sense. And now suddenly, they went like that."}
{"text": " you would probably be like, that's a pretty big bug. My screen flipped 90 degrees. That's not good. So yeah, so things like that can happen and it's not very good. So everyone see why that's a big problem and can kind of explain that? I guess so. Like the confidence. So here, I'll show it again just to be clear."}
{"text": " So here there are a lot of things going on. There's actually four versions of things going on. So there's two libraries and two executables, depending on what I compile with what version. So on the left here, in the gray boxes, are the two versions of the executable. And on the right are the two versions of the library. So in the executable compiled with version one,"}
{"text": " Whenever I'm using the library calls, well, .gitx, .gity, and .create, that will call whatever library I'm using at runtime. I don't know ahead of time which one that will be, because it depends whenever I execute the thing. So I'm not sure what version of this I'm using, but because I use the struct directly,"}
{"text": " in that point.h file, whenever I compiled with version one, it was y then x. So because I accessed the field directly, those are going to be compiled directly into that executable and the offsets are gonna be part of the executable and they won't change. So according to the executable, when it's using the struct, it thinks y is at index zero and x is at index one. So,"}
{"text": " At runtime, if I use this with version 1 of the library, version 1 of the library will use x at index 1 and y at index 0 for these three library functions. So point create will use that."}
{"text": " Point getX and point getY will all use that. So that's why this one is correct, because they're all from the library. It's just using the library. The library is going to agree with itself. It created the point, and it has the accessors. And in the case where they both match,"}
{"text": " this executable for the struct is going to be right as well because they both agree with each other. But when it got flipped, what changed is the library got updated to version two here. So now version two of the library thinks x is at index zero and y is at index one. So point create, get x and get y from the library will all use those indexes. So if I use version one of the executable,"}
{"text": " And I call the library. It would go ahead and call this library. The library created it. The library uses the accessor functions. So the library calls would be correct. It would always be 1, then 2. But now I have a mismatch. So my executable thinks y is at index 1."}
{"text": " But the library that created it said y is at index 1, and it thinks y is at index 0. So they're flipped. So that's why it flipped between the two versions. So this also works that if you use version 2 of the executable with version 2 of the library, that works fine. But if you use version 2 of the executable with version 1 of the library, that's another disagreement, and you'll get it flipped again. Yep."}
{"text": " Yeah, so there could be a few solutions. The solution would be like, oopsies, I broke the library, so you could force, you could say, you have to recompile your executable and only use version two from now on. So that is a solution, but then you get into the thing where like, oh, I can't update my library, it's stuck at version one, and then whenever I compile it now, now it's version two, and now I have a mismatch the other way, which isn't that great, and yeah, so this,"}
{"text": " This exact problem, this really subtle bug, is what happened with the standard C++ library. So in std list, someone made this mistake when they updated it, where they modified the fields, and suddenly,"}
{"text": " That broke literally every program. If it used a list, it behaved in really unexpected ways. And the only solution was your solution, which was just recompile everything and that's it. You have to recompile everything because everything is using the newer version of the library now. And that update to the new standard C++ library took some people years to do. So that is a warning for you. If you're developing these libraries,"}
{"text": " don't do things like this. You really, really have to know what you're doing. So what, yeah? Yeah, so the question is, I'm not quite sure how the library understands the change. So for both of them,"}
{"text": " This is what the library uses, right? So point create and point get x, and it both uses the struct. So like in version one of, whoops. Okay, showing the code would probably help. So there's point create and point get x that are both in the library that access the struct, right?"}
{"text": " And it uses the struct, so in this case, with version one of the library, it would be in a certain order, and whenever you compile it, the library's going to agree with itself, right? This x, it would think is one for version one of the library, and here it would be index one. So it always agrees with itself because it's the same library, right? So that's why the library calls are always correct, because it created the point, and it has accessor functions as well."}
{"text": " But the two libraries would be different. So in version 1 of the library, it would have x at index 1 and y at index 0. In version 2 of the library, it would be flipped. But it would agree, right? So in version 2 of the library, if this was at index 0 and it created the point, whenever you use this, this would also be at index 0. Yeah?"}
{"text": " Okay."}
{"text": " Yeah, so this has to do with when you compile it. So when you compile it, it creates an executable, and then it's stuck like that. So in this one, my executable also includes point.h, which has the struct in it. So if I compile it, it's stuck at whatever version I used that point.h from. So it's stuck. It's the same executable. It won't change, right? Yeah."}
{"text": " So that's a fun thing, so there are solutions to this. Ones recompile everything, that's a bad solution. What's another solution to not encounter this error? Yeah. Don't change the order, that's the best solution. So you could add fields to the struct and it would be fine. If you add them to the end, so if you add fields to the end, that's fine, you won't break anything."}
{"text": " The other solution would be that if you're going to change the fields of your struct,"}
{"text": " Don't include it in your header files. Don't let them compile it in. Hide it from them. So only make them access things through pointers, and then call into your library, and then your library has a struct file. So you make them just do everything through pointers instead of letting them know what the struct actually looks like. That's another option. That's why Java has a bit easier time with updates, because everything's a reference, which"}
{"text": " Fancy word for a pointer. So Java can do all this stuff under the hood because it can change stuff because it never actually, you never actually know where things are in memory. But in C, you might actually know where things are in memory and bad things might happen. So yeah, but for the purposes of the labs, whenever you create libraries, I would stick with the strategy of do not screw with the structs. That is a good strategy to have."}
{"text": " Because once you have them, they're set in stone. You're not allowed to change them. So the Linux kernel has structs defined. Is it ever allowed to change them? No, because then every single application might break on your machine, and lots of bad things would happen. So that's why sometimes,"}
{"text": " People will debate what goes in a struct in the library for years, because if they have it, generally you're stuck with it for like 30 years, because some things in software don't change that often. Yep?"}
{"text": " Yeah, so this is part of the give and take with them. So you might think, hey, these updates suck, and I don't want to do this. So some people might just say, hey, I'll go back to static libraries, and then I don't have this problem. Because everything's compiled in my executable, and it just won't change. It won't change between one run to the next, so it will always behave the same way."}
{"text": " In software engineering, there's like fads if people wanna use static or dynamic libraries all the time, it just changes flavors. So if you're relying on bad software with people that don't know how to write code that write bad dynamic libraries, you're gonna get fed up really fast and then do the static method like you said, and then it'll work for a time and then it will probably"}
{"text": " get really old, and you won't update it, and you won't have to recompile it, and it'll fall behind, and it'll have security vulnerabilities, and then you'll lose the source code, and then you'll never be able to update it again. And then you'll be like, man, I should have used the dynamic library. And then you'll go back and forth between the two. So the answer is dynamic libraries are better"}
{"text": " the dynamic library is of very high quality. Otherwise, you'll probably have an easier life with static. And generally, it changes from whoever you ask. So generally, you know, if you're a good programmer, you're like, I, dynamic libraries are great because all the updates work, everything works flawlessly, and I'm the best programmer on the planet. Hopefully that is us, so we're gonna make dynamic libraries in this course because"}
{"text": " That's what we'll do. Yeah, so some libraries will have both versions depending on what you want. And in general, you use the dynamic library. So the standard C library does have an option for static if you want. But generally, it is."}
{"text": " The C standard library developers are generally very, very, very, very, very good. So using dynamic is often a good thing to do for that, unless you really know what you're doing. OK. So there is a system to"}
{"text": " kind of convey what you mean through version numbers when you're using dynamic libraries. So you might have seen version numbers for stuff. Generally, for applications, they're fairly meaningless, and those are the numbers that you see, like Chrome's on version 100-whatever-the-hell. No one really knows. But for libraries, generally, the version number should actually mean something. So typically, you have like 1.1.2 or something like that."}
{"text": " So given a version number like that, you usually call the numbers major.minor.patch. And the rules for incrementing them are as follows. So if you increment the major version, that's supposed to signify that you made a change that broke the API or ABI, either one of them. And what that signals to developer is that, well, if I'm using version 1 of the library, I can't use version 2 of the library without having to recompile. So I know that."}
{"text": " I have to recompile if I want to use version two, but I should be able to use any version one of the library, and it should be okay. So the rule for incrementing the minor version is that you're adding functionality to your library. So I added a new function, and I didn't delete anything, and I didn't otherwise change function signatures or do anything silly like that."}
{"text": " So you add a new functionality, so then you know that, hey, my library needs version 1.1 because it has a function that wasn't in 1.0, and then you also know that that function that was in 1.1 is in 1.2 or something like that. And then finally for the last one, it's just supposed to represent whenever you made a bug fix, so it's supposed to always work. If it worked with 1.10, it should work with 1.11, yep."}
{"text": " Yeah, so this is just a convention that you hope developers follow. So the convention would be like, if I add a new function, I increment this number. So I could say like, in version 1.2, you can use this new function, magic calculator, whatever thing. And then people know, hey, I need version 1.2 for this."}
{"text": " Yep. Yeah, so patch versions should always just work with each other. Doesn't break anything, it should just fix things and make life better. So that if I'm running 1.1.1, I can upgrade to 1.1.2 and nothing, and it might just work better. And if you broke that version, well then hopefully there's an update to 1.1.3 that actually works. Yep."}
{"text": " No, so if they implement new functionality in the library, they don't have to recompile it, because it will just be included whenever you run your executable."}
{"text": " but your executable, you would have to recompile it, right? Assuming that you want to add, like you added new functions or methods, for example, and you want to add that to your code. No, so if they added new functions or anything, you don't have to recompile your code, but it wouldn't be able to use those new ones unless you recompile, so yeah. So if you wanted to use the new functions, you'd have to recompile, but if your code doesn't use those functions, and a new version of the library has those functions, you just wouldn't use them from the library, right?"}
{"text": " OK, so the advantages, basically, are seeing when there's, let's say, some sort of bug or something in the library. And I guess the developers want to make something a little bit more efficient, so it's stuff that are already being used. Yeah. Yeah. Yeah. So just new functionality, minor. Usually, if you increment either number, it should have bug fixes and stuff. That makes things better."}
{"text": " Yeah. OK, time. All right, so quick another example that will be fun. So they also allow for some easier debugging. So let's look at this example. So normal C program has a main, calls malloc, size of int, should allocate four bytes, right?"}
{"text": " Then I have a printf where I display the address that I got from malloc. So this cast here is just to make"}
{"text": " the compiler happy because it's just printing off a pointer and it wants it to be a void star, which basically means in C it's a pointer, I don't care what type it is. So this actually isn't doing anything. It's just printing off the address that we got from malloc and then freeing it. So, question to you. This should be very readable. How many times do I call malloc? Once? Hopefully once."}
{"text": " That's a good question. So does everyone agree we called it once? Hands up for once. Hands up for twice. All right, we got two twice. So hopefully this isn't too surprising. Look at it. malloc. This would start at main, call malloc, printf, free. I count one malloc. So let's go ahead and see this."}
{"text": " So go here. So let me free it again. So I do have one malloc. So what I can do is,"}
{"text": " I wrote my own malloc. So my own malloc will print off any time you call malloc, and then call the real malloc to do all the hard work. And it also does this for free. So my malloc and free will just print off if any one of these happens, and let us see calls that happen. And this is basically how Valgrind works. If you've ever used that, we'll see that. If I run it, I can see how many malloc calls happen."}
{"text": " Two, two people were correct. So it looks a bit weird because clearly the size of a byte is four, so that corresponds to this malloc, that looks right. And if I look at the address, well it ends in 12A0, and then I called free, that ends in the same thing, so that seems to match up. But then there's this weird malloc of 1,024,"}
{"text": " Did you know you did that? Who? Did you? Who can explain it? Yeah. So that is a good guess. One guess is for a string constant. So this string constant here."}
{"text": " The answer to that is, unfortunately, no. So this is basically a global variable. It's loaded with the process, so it doesn't need to use malloc or anything for it. So the compiler kind of figures it out, and it's more or less a global variable. Another good guess, does it have anything to do with the percent sign? That is very close, getting warmer. Sorry?"}
{"text": " Another guess, is it the pointer getting colder? Close, yeah. Yeah, how do you think printf is defined? So printf made the call to malloc."}
{"text": " So that makes sense because it had to take this string and then replace it so that it looked like this. So it needed to use some memory, so it makes sense that printf would use malloc. So that came from malloc. So, well, we just discovered something by messing with libraries. So if you used Valgrind before,"}
{"text": " You could use it on this too and get a report. This report is a bit weird because if we use it and we'll go really quick and then I'll let you go. So if you look here, Valgrind says, hey, there are two allocations and two frees, which is not true. It didn't free anything. I freed mine, but it didn't free it."}
{"text": " So if you look at the documentation real quick, it basically says that the standard C library might use memory, it might call malloc, but it doesn't have to free them because the operating system will go ahead and free all the memory when the process dies anyways, so it doesn't have to free them. And in Valgrind, there's hard-coded things that will be like, if the allocation came from the standard C library, it'll count as freed so you don't get any false positives."}
{"text": " Unfortunately, that's all the time we have. So just remember, phone for you. We're on this together."}
{"text": " you"}
{"text": " . ."}
{"text": " you"}
{"text": " you"}
{"text": " Bye!"}
{"text": " you"}
{"text": " All right, welcome to APS 105, Programming Fundamentals. We're going to put the fun in the fundamentals. So everyone excited for this course or slightly terrified? Hopefully this course will be one of your favorites, at least my hope if you're into software at all."}
{"text": " So, I'm Jon Eyjolfsson, your instructor. Do not feel bad if you cannot pronounce my last name. I could not pronounce it either until I was about 25 and then some nice Icelandic man told me how to pronounce it. So, just call me Jon if that's easier or I will teach you a trick how to spell and pronounce my last name. So,"}
{"text": " How it's spelled, kind of a mess. Kind of how it's pronounced, I've heard it all sorts of different ways. Eiffel-sin was probably my favorite, not even close. So here's the trick if you need to pronounce my last name. You know how to pronounce elf, right? It's just Christmas, so elves should be in your mind. So that's a perfect way to start pronouncing it. So let's say elf-sin, elf-sin, easy. And if you want to spell it,"}
{"text": " Just shove the L and the F over and shove a yo in the empty space. Now you can spell my last name too. In the unfortunate case, you have to spell it. I hope you don't have to spell it, but just in case there's a little hack, that's what I do. So."}
{"text": " Now we get to talk about how this course is structured and all that boring admin stuff. So there are four entries in your course timetable. The first, which is in the top left there, are your lectures. That's where you are right now. That's where we learn all the concepts and we can ask questions to the instructors and all that fun stuff."}
{"text": " What's directly related to the lectures are the tutorials. So the TAs will be at the tutorials. They will go through practice problems with you that are really close to exam problems. So I encourage you to go there. They'll start easy. They'll get progressively harder. So hopefully you can follow along, or at least gives you a good idea of what to expect for the exams."}
{"text": " And then the other half of this course are writing software and the labs. So the boxes in the green have to relate to the lab. So there's the plenary lectures. So those are additional practice for labs. They're run more like a lecture, but the TAs run them and they're directly related to the lab material. And then there are the lab sessions themselves. And that is where you get in-person help from the TAs. So again, I encourage you to go to that."}
{"text": " So word of advice, since this is, what, your second semester here at U of T, and I will give you my wisdom from starting off university as well and screwing it up. So don't do what I did. Start your labs early. So this is the cadence of the labs. So two weeks before they are due, there will be a handout posted."}
{"text": " So I encourage you to go look at the handout as soon as it is posted and then within a week from the handout being posted the material will actually be covered in the lectures. So a good thing to do is look at the handouts, see what things the lab is asking about and that is the stuff you should definitely pay attention to when it comes up in lectures or if you're trying to relate it back to the lab and you are wondering about"}
{"text": " how it actually relates to the lab, or how to solve something, good time to ask the question in the lectures. So within a week of the lab being due, all the material you will need will be covered, and then you should start working on the lab right away. And then, of course, there is the deadline, if you do not heed my advice, which is Saturday at midnight, which means if you leave it to the last minute, I guess you have ruined your weekend. So that is your prerogative, I guess."}
{"text": " You're all adults, I can't tell you what to do. I can just give you suggestions and you're free to ignore them. So I encourage you to have a weekend and have a life outside of this course. So start early."}
{"text": " So next I have to talk about academic integrity, which is a serious topic that is no fun for anyone. So the rules are you may discuss course content, but do not copy it from each other. So you're primarily harming your own learning. The best way to learn this course is through practice."}
{"text": " So if you are robbing yourself of practice, you're just going to fall behind. Next time you take a software course, you'll already be behind, and you'll get further and further behind, and it will just be a mess. So most of this course is just practicing, and the labs are intended to help you practice and encourage you to practice by assigning marks since, well, that's the thing to do."}
{"text": " So another word of advice. So you may or may not, I guess I probably shouldn't judge, if you've copied English assignments or something like that. Well, if you copy computer code, it's a lot easier to detect it. We might go into why that is, but trust me, you are not more clever than people who have been writing software for 30 years. So"}
{"text": " Some people think they are. I think last year, so this is the first year I have taught this course, but last year, I think, in one of the first labs, about 20 people got caught immediately, and that is no fun to everyone because then you have to meet with the course coordinator, and then you have to meet with the department, and then you have to meet with the thing, and they tell you that it's just not good for anyone, waste your time, waste our time, waste your learning, no good, don't do it, not fun for anyone."}
{"text": " So now we can talk about the grade weighting. So the majority of your grade is exams, which isn't that fun, but it is what it is. So your exams are worth 70% of your total grade, midterm, 30%, final exam, 40%."}
{"text": " The other 30% is labs, which are divided into nine labs. So how that 30% works is they're progressively weighted more as you learn more and the labs get more complicated. So there is a lab zero. That's a setup lab. It is not worth anything. So its weight is zero. And then the first actual work is labs one to three. So they'll be worth 2% each for a total of six."}
{"text": " Then labs four to six are worth 3% each instead of two, total of nine. And then the final three labs are worth 5% each, which is a total of 15. And that is how the 30% of your labs is going to work."}
{"text": " So the official resources for this course are Quarkus and then the online textbook. So the direct Quarkus link is there. So how my slides work is, well, they're PDFs. So anything is clickable. So you can just click the link if you want to."}
{"text": " And in addition to Quarkus, which is kind of the hub for this course, there's an online textbook, learningc.org. No other materials required. Don't have to go to the library. Don't have to buy a book. Nothing like that. And the nice thing about this book is it was written by the course coordinator, and it has exercises along with the chapters, and it actually follows the course quite closely."}
{"text": " The last one is the Piazza discussion form, which is on there. So the TAs, some of their job is to monitor that, help you if you have any questions that may arise outside of the lab sessions, but the lab sessions is probably a faster way to get help from the TAs."}
{"text": " So some additional resources for this section. I live stream the lectures just in case you are sick or anything like that, or you want to stay home or you're cozy or something like that. And I have the recordings all on YouTube so you don't have to go through Quarkus. You don't have to log into anything. It's nice and easy."}
{"text": " the lecture slides are just on my website so again you don't have to log into anything and everything's linked on there which is all fun and then there is an unofficial discord community so if you find that link it will join you to the discord server and one thing i like to do so i'll take questions just from you guys and i will also try to get to know your names i'm bad about"}
{"text": " pronouncing names and using names and everything like that, but I will try. Again, I pronounced my own name wrong for 25 years, so don't be offended. So, if you don't want to ask questions to me directly in class, I also kind of monitor the Discord chat while I'm lecturing. So if you're more comfortable with asking questions in the Discord chat, I have"}
{"text": " section three on my phone here and I can see that while I am lecturing. And I will try my best to answer the questions if that is an easier way for you to ask questions during the lecture. And that also has the benefit of if you have to stay at home, you can also still ask questions because well, lectures are live streamed and I look at the chat."}
{"text": " So any questions with any of the admin stuff so far, or are we all good? Yep. Oh, okay. Yep. And name. Sorry. Morris. Okay. Yep."}
{"text": " The final exam, I have to double check with the course coordinator, because I know she wants to do it in computer lab. But I think it's still TBD on that. But I'll get back to you. All right. Any other questions about the course at all before we kind of dive headfirst into it? So we'll all cover this again. So I'll point out anything we actually need to know. So."}
{"text": " People probably have a range of experience from absolutely nothing to you don't need to be here. So this course has to be set to people that may not have any programming experience whatsoever. But again, if you have some programming experience, please still show up to lectures. And everyone, please still show up to lectures if you are able, because I get lonely and it's no fun lecturing to an empty room. So please still show up."}
{"text": " So how all my lectures are going to work is if you talk to someone who has been programming for a long time, it seems like they're speaking a completely different language because they use words, they use words weirdly and everything like that. So what I'm going to do is any new term that comes up will be highlighted here in blue, and I will explain it on that slide. And if you do not know what that term still means, please ask me."}
{"text": " The first thing is, well, what the hell is a program? So a program is something that a computer can execute, which is just another word for run. And the art of writing a program is called programming. And it is kind of an art. It is not an exact science. But some people consider it an art, but it's actually kind of more like engineering, which is good because, hey, we're in ECE."}
{"text": " So why are we doing C programming in this course specifically? So humans write programs in something called a programming language. C is an example of a programming language, and it first appeared in the 70s. So programming language is just a set of rules that allow you to write some text that we will see how that gets transformed into something a computer will run in a few slides."}
{"text": " So you may have heard the term programming language before and may know some different programming languages. So specifically why we chose C for this course is it is a small language with not that many features and it's closer to how a computer works."}
{"text": " So it is a lot more difficult to do some tasks in C. But what if you have to learn eventually how a computer works, which you will do over the course of your degree, then C is good because basically it doesn't hide anything from you. It is really close to how a computer actually works. So it immediately springboards you into the hardware courses and everything like that. And again, hardware is a word we may not have seen before."}
{"text": " So we're programming a computer. We have to answer, what is a computer? So a computer has two parts. The first part of a computer is called hardware. And that is the physical components of the computer that you can actually touch."}
{"text": " So what that would look like, so here is what is sitting at my desk at home and this is what part of a computer actually looks like. So there are three main components to a computer and the first is under that fan in the middle, so that is called the CPU or central processing unit."}
{"text": " So some might consider that the brain of the computer, that's where all the calculations actually happen, and that is what actually does the work. The rest of your components are just storing information."}
{"text": " So, the next most important part of your computer is the RAM, or Random Access Memory, and that's kind of like short-term memory. So, any information that is stored in RAM, the CPU can directly access, and that is where all your programs will primarily execute, and the CPU interfaces directly with RAM, and will read values from the RAM. The next piece of storage,"}
{"text": " likely is probably an SSD or it's solid state drive, and that's long-term memory. So that's where all your files are stored, all of your assignments. That's where Windows is or Mac OS, depending on what type of computer you have. And that is also called long-term memory."}
{"text": " So we model a computer as a black box. We model most things in engineering as a black box. So the black box just takes some input, something happens, we don't really know the details of it, we don't actually need to know the details of it, and then we get some result out of it, or in other words, some output. So for a computer, your input is provided by like a keyboard,"}
{"text": " typing letters on a keyboard, moving a mouse, clicking a mouse, maybe..."}
{"text": " you know, swiping your fingers on a trackpad or a touchpad, trackpad, whatever you want to call it, or a touchscreen. And then that input gets fed into the computer, which has, again, three major components. So compute, which is the CPU, memory, which is synonymous with RAM, even though, you know, you might consider it short-term and long-term memory. But whenever we say memory in reference to computer, we're talking about RAM. And then there is storage."}
{"text": " So that's SSDs or HDDs if you have a very old machine. And then you have some output that will go to a monitor or screen or something that you, the human, can actually see."}
{"text": " So what's the other major part of a computer? The other major part is, well, software. And software is just the information that your computer needs to run. So the most important information are instructions that the CPU can actually run, and the instructions tell the CPU what to do. So"}
{"text": " As you go on, computers seem really, really complicated and really, really smart, but in actuality, they are very, very stupid. So CPUs aren't really that much complicated than doing addition. If you can do addition of two numbers, well, you're pretty much as good as a CPU."}
{"text": " But the only difference between you and a CPU is really, really smart people made that go really, really, really fast. So you can do a few additions, maybe a second, 10 seconds, something like that. CPUs can do billions and trillions. So that's the main reason why we use CPUs. So the next question is, well, if software is just information, how do they store that information?"}
{"text": " So, computers just store it using a series of numbers. At the end of the day, everything that goes into a computer turns into a number at some point, and then we as humans assign meaning to them. That is the kind of dirty secret about all computers, that we just assign random meanings to numbers, and then if you play with the numbers in the right way, you get some result that surprises you."}
{"text": " But at the most basic level, all computers can store is a 1 or a 0 or a 1. That's it. And since we're electrical people, well, what does that look like? Well, it's kind of like a light bulb. So a 0, you can think of it as off. That means the light is off. And a 1, well, it means I turned on the light. So a 1 is the same as on."}
{"text": " That means it's on, that's a one. So that's as complicated as computer Git. Course done. All right, it gets a little more complicated than that, because we need more than just a single zero or a one to do something."}
{"text": " So usually as humans, we represent numbers in decimal. So if we really, really break it down and be really, really precise about how we represent numbers, well, we represent numbers as sequences of digits. So all the digits are in an order. And depending on what order they're in, they have some special meaning. Computers aren't that much different."}
{"text": " So a digit is just a number between 0 and 9. So there are 10 options. Because we are humans, we like 10s because we have 10 fingers and 10 toes. At least most of us do. I still do, despite some close calls. So"}
{"text": " Computers, same idea, except they represent numbers as sequence of bits. And what a bit is, is a bit is just short for a binary digit. And that means it's a digit that's either zero or one. So there's only two options in this case. Zero, one, lights on, lights off, that's it."}
{"text": " So we can actually write numbers using just bits. This is called binary. So binary is just a numeral system that only uses bits."}
{"text": " So if we go back to elementary school, hopefully, they probably made you do this at one point. So here's a decimal, 176, and then they had you write out the hundreds column, the tens column, the ones column, and then you put a digit in each one of them. Everyone's done that before? All right, so everyone's done that maybe in grade three, something like that?"}
{"text": " So then, as soon as they taught you what exponents were, you realize that, oh, the columns are actually like that. So the first one is 10 to the power of zero, second one is 10 to the power of one, the third one is 10 to the power of two, and if we had more digits, it would keep going up by another exponent."}
{"text": " So if we represent 176, it's just 1, 7, 6, 100th column, 10th column, 1's column, or using exponents. So if we were to write a binary number, the only difference is that base. So instead of 10, the base 10 is because we're using digits. So if we're using bits instead of digits, well,"}
{"text": " then our base becomes two. So we would write out the columns, you know, to the power of zero, to the power of one, to the power of two. And since we only have two options for each bit, well, we probably need a lot more of them to express the number 176. So in this case, we actually need eight of them."}
{"text": " So if we take the exponents and just make it easier on ourselves and just convert them just to an actual number, they'll look like this. So we'll get 1, 2, 4, 8, 16, 32, 64, 128. And those numbers probably look familiar if you have had to buy a laptop because the size of the memory is probably one of these options. And why it's one of these options is because, well, computers inherently are binary. They like powers of two."}
{"text": " So if we were to represent the number 176 in binary, we could do that by just, and this is how we would do it. It would be 1 0 1 1 0 0 0 0. We don't really, knowing how to do this is not important to this course. It might be in a second year course. But for now, we just need to know how a computer would actually represent a number in binary."}
{"text": " So to verify this, well, we can do what we did before when they were all powers of 10. Being powers of 2 doesn't actually change anything. So if we want to write the number back out, it would be like 1 times 100 plus"}
{"text": " seven times 10 plus six. Well, in this case, it's the same thing, but it's either zero or one. So to get this number back to a decimal that we humans can understand, it would be one times 128 plus one times 32 plus one times 16. And we wouldn't have to add any of the other ones because anything times zero is zero. So we can verify that this is the correct representation."}
{"text": " Because 128 plus 32 plus 16 equals 176. So they actually mean the same thing. So."}
{"text": " Computers, they can only store information in finite amounts. So a byte, that's our next term, so that is the only actual important thing from that long spiel. Know what a bit is, and then know what a byte is. So a byte is a binary number that is up to eight bits long, or exactly eight bits long, and then there'd be leading zeros."}
{"text": " So because there are eight bits and each bit can either be a zero or a one, well, we took some statistics in high school too. So if we have two choices for all eight of our bits, we have two of the eight different options. So we can actually represent 256 different things using a single byte."}
{"text": " And why is it called a bite? It's because we do not have a sense of humor because, well, a bit sounds like, you know, you're taking a small bit of some food and then they're like, well, what would be bigger than a bit? And then someone said, ha ha, a bite, because that's bigger. So if you had to go bigger than that, maybe that's like a gulp or a chomp or something like that. But I guess we'll get to that when we need to. But"}
{"text": " For computers right now, pretty much a byte is like the smallest useful unit of information that a computer actually uses."}
{"text": " So few other notation things. So in math, if you were being very explicit about what base a number was in, you would write it as like a subscript. So this would be like five in base 10. So like a normal human number. And that is the exact same as one, zero, one in base two, which would be binary. So in this case, in most programming languages,"}
{"text": " what the equivalent would be is five. So whenever you write a number in programming languages, it assumes you are a human and you are writing it in decimal. But if you want to write a number in a different base in a programming language, instead of having a subscript or anything like that, what they do is just prefix it with zero B to indicate that it is a binary number and then,"}
{"text": " there would just be ones and zeros that follow after that, and that would represent your binary numbers. So this would be 0B101. Again, in this course, you won't actually have to write binary numbers, but it's good to know that at some point, they will get converted to binary because they will have to run on your computer."}
{"text": " So another note that trips up students even in third years, for some reason, whenever we just talk about binary, they think all the rules just fly out the window. So if I wrote the number 176 again, but I had to use four digits for whatever reason, well, implicitly, there's leading zeros there. I can write as many zeros in front of that number as I want, and it won't change the meaning of it."}
{"text": " Same is true for binary numbers. So if I write 0B000000101, that's the same as writing just 101. There's implicitly leading zeros, so you don't need to write them if you want. All right."}
{"text": " So that is how you represent numbers on a computer. So we can actually represent letters and other numbers in binary. So the way computers do this is they don't need a full byte. So basically, this is how it represents things you type on your keyboard, as long as you have a standard keyboard."}
{"text": " So it doesn't need all 256 options. Your keyboard doesn't have that many keys on it. If it did, well that would be quite the keyboard. So for keyboards you only need seven bits, so"}
{"text": " There's some text on the slide that says the most significant bit is always zero. Just ignore that for now. So for representing any character on your keyboard, you only need seven bits. So that would be to the seven or 200, or sorry, 128 different possibilities. And what you can type on your keyboard is called a character. So a character is how a computer represents English."}
{"text": " And the parts of English are like letters, digits, punctuation, and spaces, and some other things that we'll see in the next lecture. So for instance, if you type an A on your keyboard, how it's likely going to be represented is it's going to be represented like this in binary. Or if we don't know how to read binary yet, it's just the decimal 65. So if I type a uppercase A,"}
{"text": " It means 65, and that's the magic. So we'll get into more of this as we go throughout the course, but just remember, at the end of the day, computers are not some magical thing. It's just a bunch of numbers floating around, and we just assign meaning to them. So if you ever think they're magical, just remember, they don't even know what an A is. You have to translate an A as 65."}
{"text": " And if you went up to, I don't know, one of your parents and say, hey, I got a 65 in the course, they'd probably think, oh, no, that's not good. But then you're like, no, no, no, it's actually an A. I was speaking computer. And then, I don't know, horrible joke. Don't mind me. We're weird people, so get used to it."}
{"text": " So your programs, or another word for program is application, or app, or whatever you want to call them, they all mean the same thing. They run in some type of operating system that we have all used at this point. So the operating system, and from this point on, I will just shorthand it as OS."}
{"text": " is just software that interacts directly with the hardware. And you'll learn much more about this in ECE 344, which I happen to also teach. So hopefully I will see you there. So other terms."}
{"text": " So code, code is just text written in a programming language. So just a bunch of characters written in a programming language that have to conform to some rules, which we'll see as we go through the course. And another term you might hear is source code. So source code is just code for particular software. It's just"}
{"text": " kind of a shorthanded way of saying it. So instead of saying something long-winded and saying you want, you know, I want the code that represents Firefox or something like that, you just say, where's Firefox's source code? So then they would give you some code that's written in a programming language that if you create a program out of it, it's Firefox."}
{"text": " Another term that we will encounter in this course is called a library, and that is just code written by someone else that you can use. And C provides a library. They have a very, very creative imagination, and their imaginative name for this library is the Standard C Library. I could not think of a more boring name myself if I tried, so you have to give them some credit for that at least."}
{"text": " So, the weird thing about programming is we need to use a program in order to create programs. So, a compiler is the program that transforms your source code into a program that your operating system can actually run. So, what it looks like is it takes your source code and then that,"}
{"text": " You can represent a compiler as a black box. Again, if you want to learn more about a compiler, that's a third or fourth year course here, which is also a lot of fun. But for now, we'll treat the compiler like we're treating the computer, and we'll treat it as a black box."}
{"text": " So the input to the compiler is your source code. And then the compiler does some magic. And then at the end of the day, it outputs machine code. And machine code is the actual binary representation of the instructions that the CPU knows how to run. So again, the CPU just"}
{"text": " understands numbers, there are certain numbers assigned to tell the CPU to do certain things, like there is a certain number that if the CPU sees, that means it will add the next two numbers, for example. And all the CPU will do is just run those over and over again, and once you, in one of the second year courses, you will actually design a CPU that does this. But for now, we can just treat it as a black box."}
{"text": " So we often use the term compile as a verb, like saying let's compile our program. That just means let's take our source code and then turn it into machine code so I can actually run it on my computer and see what it actually does. All right, again, no questions so far? Cool, all right, oops."}
{"text": " All right, so we need another program to handle input and output for us. So you're not going to have to write anything that directly interacts with the keyboard or a monitor or anything like that. You're going to use primarily something called a terminal, and that uses keyboard for input, so it will translate the key presses for you, and then it will show the result on your monitor or your screen for the output."}
{"text": " So it is a text interface. It just uses characters you see on your keyboard, nothing else, nothing else special. So if you want to see more graphical things like windows come up, fun spinning 3D windows and all of that fun stuff, that will be a later course. This is the introductory course. So we are just going to use the text interface."}
{"text": " So every program we create in this course, our input's going to be text and our output's going to be text, just to keep things simple and have you focus on actually using programming to problem solve. So how you present your results doesn't end up really mattering that much. It just might be a bit easier to use, but we're going to be programming in this course."}
{"text": " So here is an example of your first program. So don't worry if this does not make any sense yet. This is just to introduce you to what it looks like. And I will break it down line by line, but I know each line may not be comprehensible yet. So I'll give a brief idea of what each line does. And hopefully that will set us up for questions and we can actually see how to run something like this."}
{"text": " So, this is your typical first program. Your first programming in any programming language is going to be to get the output, hello world, to see that you can actually show something that you have actually written in text."}
{"text": " So the first line here, this includes stdio.h. It does not have a medical problem. STD is short for standard, not something else. Get your head out of the gutter. So that include at the beginning, that means just tells the compiler to read the contents of another file. In this case, there is a file called stdio.h somewhere else on your computer."}
{"text": " it will read the contents of that file, and that is short for STD, short for standard, and IO is short for input output. So that means standard input output, how to actually get input in and show output. There is a function in here, we don't know what function means yet, but it contains a declaration of something called printf, and that basically is how we can show some output."}
{"text": " So, and how the compiler and you typically read a program is from top to bottom, but when it actually runs the program, it does not go top to bottom. But first, we'll see what it does. So this int main void has a bunch of gibberish in it right now that we don't really know what it means. What this does is define something called a function called main."}
{"text": " that outputs a number. So this basically describes that black box I was talking about again. So it's something the computer understands that takes some input and then produces some output. In this case, int is short for integer or a number. So that means the result of this function, kind of like a mathematical function, is a number. So the rule is whenever you write a C program, your,"}
{"text": " if you try and run this program, it will start running it at main, it will not start running it at the top. So you can read it from the top down, but when you start running it, it starts running at main. So if the first thing this will do if we try to run it, is it will run this printf function, which we can see kind of take something that looks a bit like hello world in quotes with like a weird backslash and an N,"}
{"text": " We'll see what that does in the next lecture, but this, at the end of the day, basically just calls a function called printf, and that function handles output for us. So it outputs a string to the terminal that we can actually see, and a string is just a sequence of characters. So like H-E-L-L-O, so H-E-L-L-O."}
{"text": " is a character, E is a character, it'll be assigned some number but we don't have to worry about that because C will translate it for us. But it just takes a bunch of characters and then everything looks okay, hello world, that's all things we can type on our keyboard. And then there's this backslash N which looks kind of weird, you've probably never sent an email to someone with a backslash N."}
{"text": " So that actually does something else that's special that we will get into and we won't actually see it when we run this program."}
{"text": " Then the final line means stop executing this program. So this is how you stop executing main. And then output the value zero. So that is the result of running this function. And the operating system takes that value and does something with it. If it reads a zero, that means no errors have happened. Everything is hunky dory. The printer didn't catch on fire or anything like that. We are all good. So."}
{"text": " Let's see what that looks like. If you have started Lab0 that is already posted, the result of your Lab0, you'll set up something called VS Code. VS Code is where you'll do all of your programming. It is an IDE, short for Integrated Development Environment."}
{"text": " That is where you write your code, you can compile your code, and run your code, and all of that fun stuff. So I have exactly what was on the slide here. I created a file called hello-world.c. Again, if this doesn't look familiar to you,"}
{"text": " it will after you set up lab zero so also during the lectures i will have a bunch of code examples so please feel free to tell me we don't know anything yet because the course hasn't started but in general after the course starts"}
{"text": " We can, part of the lecture is dedicated to just seeing what happens, telling me what would happen if I did this. We can do live coding examples, we can see the result, and the best thing about me being here is I can explain what is actually going on, because some of the stuff will be mystifying to you, and some of the stuff, if you ask me the right thing to do, might be even mystifying to me because, well,"}
{"text": " I've been programming for a long time, so I'm used to seeing sane stuff. So if you just tell me to do something random, I might not even know what it can do. So here is our program. As you go through Lab0, you'll figure out how to actually invoke or run your compiler so you actually get the machine code for something to run. I believe the default in Lab0 is to use a compiler, something called GCC."}
{"text": " which is short for the GNU C compiler, that is just the name of the people that wrote the software, and then they did not have a creative name for it, so CC is short for C compiler. So, if we use GCC, we can save the name of the file to actually compile, and then the resulting name of the,"}
{"text": " the resulting name of the executable that we can actually run. So now, after this point, I've created a program called hello-world."}
{"text": " If I type dot slash and then hello world as a name and press Enter, when I press Enter, my computer will start executing that program that I have written. So if I hit Enter, I can see the output. So the output here is hello world, which is what I have written, and that dash n does not show up."}
{"text": " So that dash n doesn't show up because, well, it's something called a new line that we'll get into in the next lecture. And just typically you end each line with a new line whenever you're done a line of text. So if I wanted to change it to output something different, I could just go ahead and change what comes after hello. So I could just say hello class."}
{"text": " And then the part of this course is I have to, after I make a change and save it, you should be sure to save it, in order to see your change when you actually run the program, you have to compile it again, because that hello world file, that's still the result of when I compiled it the first time. So if I run it again, it will still say hello world."}
{"text": " So if I run the compiler again, so I'm just telling it, hey, compiler, again, compile the C file and create this program for me again. And then it goes, OK, sure, I've done that. Now, if I execute it again, it will say, hello, class. So that's our first lesson. So any questions of anything we have done so far? Yep? Why not just leave ODAF? Sorry?"}
{"text": " Like, for example, on a test, would you prefer that we put, like, if you want to put something, would you prefer that we put void there or just leave it out? Because I think you can also leave it out. Yeah, so anything for the, for tests or anything like that, don't worry about it right now. We'll get to it later. We'll have problems that come up and we'll answer that. Don't worry about tests for now. This is the first lecture. This is stress-free for now."}
{"text": " All right, any other questions? Anything else fun you want me to do? So typically, I will built in some extra minutes for the lecture just in case there are questions. I like taking questions. And in this case, I built in that time and there are no questions. So we get to go early. So just remember, I'm pulling for you. We're all in this together."}
{"text": " In the previous lectures, we have been studying about different aspects of operating system. And, what we have mostly seen was the introduction to operating system and also operating system structures. Now, moving on, we are moving on to one of the most important parts of operating system which is process management. So, you must have heard this term many times, processes and threads."}
{"text": " So, in this lecture we will be trying to get an introductory idea and understanding of what are processes and what are threads. And usually people are confused many times between the difference between processes and threads. So, we will try to understand what these are and what are their differences. So, first of all, before we understand processes, let us first try to understand how a program is developed."}
{"text": " So, whenever you want to make a program, what you do is, you first write the program in some high level languages. Like for example, let's say that you write the program in C, C++, Java or something like that. And that program is written in a high level language. Now, we know that at the basic level, computers does not understand the high level language, but it understands only binary codes which are zeros and ones. So, the program has to be converted to binary code."}
{"text": " So, for that using a compiler you compile your program and it helps to convert that program into a machine code which is understandable by your machine. Alright! So, after that you have your program which is converted into a binary executable code and it is ready for execution. But, it is not enough to just have that binary code for a program to execute or for a program to tell the computer what it wants to do. So, what it has to do is it has to be loaded into the memory"}
{"text": " and for a program to execute it needs some resources of the computer system. So, who will give the resources? Who will allocate these resources? What is the brain that works behind all this? It is the operating system which we have been discussing so far. So, the operating system"}
{"text": " will help in loading that executable program into the memory and allocate its resources. And, then the program will begin its execution. Alright! So, we first have a program which is written and which is ready for execution. But, till that time it is just a passive entity. That means, it just sits there without doing anything. But, the moment it begins execution, at that instance we call that program as a process."}
{"text": " So, a process can be thought of as a program in execution. When a program starts execution, at that time we call it a process. So, when it is not executing, it is just a program sitting there doing nothing. But, the moment it begins execution, at that time we call it as a process."}
{"text": " So, in the earlier computers it supported only one process or one program at a time. But, in today's computer it supports multiple processes, multiple programs running at the same time. And even one single program can have many processes associated with it."}
{"text": " So, when a program begins its execution, at that time it is known as a process. Now, let's try to understand what are threads. So, thread is actually the basic unit of a process which is in execution. So, this is how we can define it. A thread is a unit of execution within a process. A process can have anywhere from just one thread to many threads."}
{"text": " So, we already understood what is a process. When a program is executing, it is called a process. And a thread is the unit of execution within a process. So, within a process, there may be one or more units of its execution. And those units are known as threads. And again, in earlier systems, one process had only one thread. But now, a single process can have many threads or many units of execution within it."}
{"text": " So, a process can have anywhere from one thread to many threads. So, that is the difference between a process and a thread. If you look at this diagram, I hope you should be able to visualize and understand what it actually means. So, here we call this entire thing as a process. When a program begins its execution, it becomes a process. And within this process, there are certain units of its execution. And each unit is known as a"}
{"text": " thread. So, these are all the units or the threads which are under execution within this process. Now, if you want to see the processes which are in execution in your system, you can see it using your task manager in windows. You can open up the task manager and you can see which are the programs that are loaded and what are the processes which are executing."}
{"text": " So, let me show you an example of that. So, here this is a screenshot of my task manager. If you open up your task manager, and if you look at this application tab, we can see which are the programs that are running. So, here I have three programs running over here. And here we have the process tab. So, if you click on the processes tab, you can see what are the processes running in your system. So, if you click this, you come to"}
{"text": " this window over here where you see that there are all these processes running in your system. So, for example, if you look here, you see that there is the chromium browser running over here. And if you look at the processes tab, we see that there is not only one process associated with this chromium browser, but there are multiple processes. For example, you see there is chrome.exe here, it's there even here and"}
{"text": " There are quite a few even over here. So, we see that there are multiple processes associated with a single program. And this is the memory that it is using which is shown over here. So, this is just an example of how you can see the programs and the processes running in your system. Because if you see what is happening, it becomes more interesting for you to learn and understand what is happening."}
{"text": " So, here we have seen the processes. But, we did not see any threads over here. So, if you want to see the threads that are also there in your system, then you can use a program known as process explorer. You can download that program and it will show you even the threads that are running."}
{"text": " for each program and for each processes. So, this is how the process explorer looks like. You can download this. It is a very small application. You can download and install it. And, you can see that these are the processes as we saw before. So, for example, here I have the chrome.exe process running over here. And, if you right click on this and go to the properties, then you can see the threads."}
{"text": " So, here you will get this window and if you click on this threads tab, you can see that these are the threads which are the units of execution of this particular process and which are running over here. So, these many threads are running within this process chrome.exe. So, in this way you can see the processes and threads that are running in your system. So, I hope with this visual example it was more clear to you what are processes and what are threads and how they work."}
{"text": " So, this was just a basic introduction of what are processes and what are threads and how we can differentiate between a process and a thread. So, this process is a very important topic in operating system and we will be studying this in more details and many topics are there under this which we will be discussing in the coming lectures. Thank you for watching and see you in the next one."}
{"text": " OK, here's the last lecture in the chapter on orthogonality. So we met orthogonal vectors, two vectors. We met orthogonal subspaces, like the row space and null space. Now today we meet an orthogonal basis and an orthogonal matrix. So we really, this is, this chapter cleans up orthogonality."}
{"text": " Really, I should use the word orthonormal. So my vectors are q1, q2, up to qn. Can I use the letter q here to remind me I'm talking about orthogonal things?"}
{"text": " Not just any vectors, but orthogonal ones. So what does that mean? That means that every Q is orthogonal to every other Q. It's a natural idea. To have a basis that's got, that's headed off at ninety degree angles, the inner products are all zero, of course, if"}
{"text": " Q is, certainly QI is not orthogonal to itself, but there we'll make the best choice again, make it a unit vector. Then QI transpose QI is one for a unit vector, the length squared is one, and that's what I would use the word normal. So ortho for this part, normal, normalized, unit length for this part."}
{"text": " OK. So first part of the lecture is how does having an orthonormal basis make things nice? It certainly does. It makes all the calculations better. A whole lot of numerical linear algebra is built around working with orthonormal vectors, because they never get out of hand. They never overflow or underflow."}
{"text": " I'll put them into a matrix Q. And then the second part of the lecture will be, suppose my basis, my columns of A are not orthonormal. How do I make them so? And the two names associated with that simple idea are Graham and Schmidt. So the first part is, we've got a basis like this,"}
{"text": " Let's put those into the columns of a matrix. So a matrix Q that has orth- I'll put these orthonormal vectors, q1 will be the first column, qn will be the nth column. And I want to say, I want to write this property, qi transpose qj,"}
{"text": " being zero, I want to put that in a matrix form. And just the right thing is to look at Q transpose Q."}
{"text": " So this chapter has been looking at A transpose A, so it's natural to look at Q transpose Q, and the beauty is it comes out perfectly. Because Q transpose has these vectors in its rows, the first row is Q1 transpose, the nth row is Qn transpose, so that's Q transpose."}
{"text": " And now I want to multiply by Q. That has Q1 along to Qn in the columns. That's Q. And what do I get? You really, this is the first, simplest, most basic fact that how do orthonormal vectors, orthonormal columns in a matrix, what happens if I compute Q transpose Q?"}
{"text": " Do you see it? If I take the first row times the first column, what do I get? A one. If I take the first row times the second column, what do I get? Zero. That's the orthogonality. The first row times the last column is zero. And so I'm getting ones on the diagonal, and I'm getting zeros everywhere else. I'm getting the identity matrix."}
{"text": " You see how that's, it's just like the right calculation to do. If you have orthonormal columns, and the matrix doesn't have to be square here. We might have just two columns. And they might have four, lots of components. So, but there."}
{"text": " Orthonormal, and when we do Q transpose times Q, that Q transpose times Q or A transpose A just asks for all those dot products. Rows times columns. And in this orthonormal case, we get the best possible answer, the identity. OK. So this is, this is like, so, I mean, now, now we have a new bunch of important matrices."}
{"text": " What have we seen previously? We've seen in the distant past we had triangular matrices, diagonal matrices, permutation matrices. That was early chapters. Then we had row echelon forms. Then in this chapter we've already seen projection matrices."}
{"text": " And now we're seeing this new class of matrices with orthonormal columns. That's a very long expression. I am sorry that I can't just call them orthogonal matrices."}
{"text": " But that word orthogonal matrices, or maybe I should be able to call it orthonormal matrices. Why don't we call it orthonormal matrices? I mean, that would be an absolutely perfect name for Q. Call it an orthonormal matrix because its columns are orthonormal. Okay. But the convention is that we only use that name orthogonal matrix, we only use this"}
{"text": " this word orthogonal, we don't even say orthonormal for some unknown reason, matrix when it's square. So in the case when this is a square matrix, that's the case we call it an orthogonal matrix. And what's special about the case when it's square? When it's a square matrix,"}
{"text": " We've got its inverse. So, so in the case if Q is square, then Q transpose Q equals I tells us, let me write that underneath, tells us that Q transpose is"}
{"text": " Q inverse. There we have the easy-to-remember property for a square matrix with orthonormal columns. I need to write some examples down. Let's see. Some examples, like if I take any permutation, some examples. Let's do some examples."}
{"text": " Any permutation matrix, let me take just some random permutation matrix. Permutation. Q equals, let's say, I'll make it three by three, say zero, zero, one, one, zero, zero, zero, one, zero. OK. That certainly has"}
{"text": " unit vectors and its columns. Those vectors are certainly perpendicular to each other. And if I fig- and so that's it. That makes it a Q. And if I multiply- if I took its transpose, if I multiplied by Q transpose, shall I do that? Let me stick in Q transpose here."}
{"text": " Just to do that multiplication once more, transpose, it'll put the, put, make that into a column, make that into a column, make that into a column, and the transpose is also another Q, another orthonormal matrix, and when I multiply that product, I get I. OK. So there's an example. And actually, there's a second example."}
{"text": " But those are real easy examples, right? I mean, to get orthogonal columns by just putting ones in different places is, like, too easy. So let me keep going with examples. So here's another simple example. Cos theta, sine theta."}
{"text": " There is a unit vector. Oh, let me even take it, well, yeah. Cos theta sine theta, and now the other way I want sine theta cos theta, but I want the inner product to be zero. And if I put a minus there, it'll do it. So the, that's a unit vector, that's a unit vector, and if I take the dot product, I get minus plus zero. OK."}
{"text": " So for example, Q equals, say, one one one minus one. Is that an orthogonal matrix? I've got orthogonal columns there, but it's not quite an orthogonal matrix. How shall I fix it to be an orthogonal matrix?"}
{"text": " Well, what's the length of those column vectors? The dot product with themselves is, right now it's two, right? The, the length squared. The length squared would be one plus one would be two, the length would be square root of two, so I better divide by square root of two. OK. So there's a, there, now I have got an orthogonal matrix. In fact, it's this one when, when theta is pi over four."}
{"text": " The cosines and sin- well, almost. I guess the minus sign is down there. So maybe, I don't know, maybe minus pi over four or something. OK. Oh, let me do one final example, just to show that you can get bigger ones. Q equals, let me take that matrix up in the corner, and I'll sort of repeat that pattern."}
{"text": " Repeat it again, and then minus it down here. That's one of the world's favorite orthogonal matrices. I hope I got it right. Can you see whether?"}
{"text": " If I take the inner product of one column with another one, let's see. If I take the inner product of that column with that, I have two minuses and two pluses, that's good. When I take the inner product of that with that, I have a plus and a minus, a minus and a plus, good. I think it all works out. And what do I have to divide by now to make those into unit vectors?"}
{"text": " Right now those, those, the vector one one one one has length two, square root of four. So I have to divide by two to make it unit vector. So there's another. That's my entire array of simple examples. This, this, this construction is named after a guy called Atamar and,"}
{"text": " We know how to do it for two, four,"}
{"text": " sixteen, sixty-four, and so on, but, we, nobody knows what, which, exactly which size matrices have, which size, which sizes allow orthogonal matrices of ones and minus ones. So a, a Adamard matrix is an orthogonal matrix that's got ones and minus ones."}
{"text": " And a lot of ones, some we know, some other sizes, there couldn't be a five by five, I think, but there are some sizes that nobody yet knows whether there could be or can't be a matrix like that. OK. You see those orthogonal matrices."}
{"text": " Let me ask, why is it good to have orthogonal matrices? What calculation is made easy?"}
{"text": " if I have an orthogonal matrix. And let me remember that the matrix could be rectangular. Shall I put down a rect- I better put a rectangular example down. So these were all square examples. Can I put down just a rectangular one, just to be sure that we realize that this is possible? Help me out. Let's see. If I put, like, a one two two."}
{"text": " And, minus two, minus one, two. That's an or- that's an or- that's a matrix. Oh, its columns aren't normalized yet. I always have to remember to do that. I always do that last, because it's easy to do. What's the length of those columns?"}
{"text": " So if I wanted them to be length one, I should divide by their length, which is, so I look at one squared plus two squared plus two squared, that's one and four and four is nine, so I take the square root and I need to divide by three. OK. So there is, well, without that, I've got one orthonormal vector. I mean, just one unit vector."}
{"text": " Now, put that guy in. Now I have a basis for the column space, for a two-dimensional space, an orthonormal basis, right? These two columns are orthonormal. They would be an orthonormal basis for this two-dimensional space that they span. Orthonormal vectors, by the way, have got to be independent. It's easy to show that orthonormal vectors"}
{"text": " since they're headed off at all at ninety degrees, there's no combination that gives zero. Now, if I wanted to create now a third one, I could either just put in some third vector that was independent and go to this Gram-Schmidt"}
{"text": " calculation that I'm going to explain. Or I could be inspired and say, look, with that pattern, why not put a one in there and a two in there and a two in there and try to fix up the signs so that they worked? Hm. I don't know if I've done this too brilliantly. Let's see, what signs? That's minus, maybe I'd like a minus sign there. How would that be?"}
{"text": " Um, yeah, maybe that works. I think that those three columns are orthonormal, and they, the beauty of this, this is the last example I'll probably find where there's no square root."}
{"text": " The punishing thing in Gram-Schmidt, maybe we better know that in advance, is that because I want these vectors to be unit vectors, I'm always running into square roots. I'm always dividing by lengths, and those lengths are square roots. So you'll see, as soon as I do a Gram-Schmidt example, square roots are going to show up. But here are some examples where we did it without any square roots. OK."}
{"text": " OK. So, so great. Now next question is, what's the, what's the good of having a Q? What, what form, what formulas become easier? Suppose I want to project, so suppose Q, suppose Q has orthonormal columns."}
{"text": " I'm using the letter Q to mean this. I'll write it this one more time, but I always mean, when I write a Q, I always mean that it has orthonormal columns. So suppose. I want to project onto its column space."}
{"text": " So what's the projection matrix? What's the projection matrix if I project onto a column space? OK, that gives me a chance to review the projection section, including that big formula, which used to be have four, those four A's in a row, but now it's got Q's, because I'm projecting onto the column space of Q. So do you remember what it was? It's Q."}
{"text": " Q transpose Q inverse Q transpose. That's my four Qs in a row. But what's good here? What makes this formula nice if I'm projecting onto a column space when I have orthonormal basis for that space? What makes it nice is this is the identity."}
{"text": " I don't have to do any inversion. I just get QQ transpose. So QQ transpose is a projection matrix. Oh, I can't help, I can't resist just checking the properties. What are the properties of a projection matrix? There are two properties to know for any projection matrix."}
{"text": " And I'm saying that this is the right projection matrix when we've got this orthonormal basis in the columns. Okay. So there's the projection matrix. Suppose the matrix is square. First, just tell me first this extreme case. If my matrix is square and it's got these orthonormal columns, then what's the column space?"}
{"text": " If I have a square matrix and I have independent columns and even orthonormal columns, then the column space is the whole space, right? And what's the projection matrix onto the whole space? The identity matrix."}
{"text": " If I'm projecting in the whole space, I, every, every vector b is right where it's supposed to be and I don't have to move it by projection. So this would be, this will be I, this is, this is, I'll put in parentheses, this is I if Q is square."}
{"text": " Well, that, we, we said that already. If Q, if Q is square, that's the case where Q transpose is Q inverse, we can put it on the right, we can put it on the left, we always get the identity matrix if it's square. But if it's not a square matrix, then it's not, we don't get the identity matrix."}
{"text": " We have QQ transpose, and just again, what are those two properties of a projection matrix? First of all, it's symmetric. Okay, no problem. That's certainly a symmetric matrix. So what's that second property of a projection? That if you project and project again, you don't move the second time. So the other property of a projection matrix should be that QQ transpose"}
{"text": " twice should be the same as QQ transpose once. That's projection matrices. And that property better fall out right away, because from the fact we know about orthonormal matrices, Q transpose Q is I."}
{"text": " OK, you see it. In the middle here is sitting Q Q transpose Q, sorry, that's what I meant to say. Q transpose Q is I, so that's sitting right in the middle, that cancels out to give the identity, we're left with one Q Q transpose and we're all set. OK. So this is the projection matrix."}
{"text": " equation, all the messy equations of this chapter become trivial when our matrix, when we have this orthonormal basis. I mean, what do I mean by all the equations? Well, the most important equation was the normal equation. You remember old A transpose A x hat equals A transpose B. But now, now A is Q."}
{"text": " Now I'm thinking I have Q transpose Q x hat equals Q transpose b. And what's good about that? What's good is that matrix on the left side is the identity."}
{"text": " The matrix on the left is the identity, Q transpose Q. Normally it isn't. Normally it's that matrix of inner products and you've got to compute all those dopey inner products and solve the system. Here, the inner products are all one or zero. This is the identity matrix. It's gone. And there's the answer. There's no inversion involved."}
{"text": " Each component of x is a q times b. What that equation is saying is that the i-th component is the i-th basis vector times b. That's the simple."}
{"text": " That's probably the most important formula in some major parts of mathematics, that if we have orthonormal basis, then the component"}
{"text": " in the i-th, along the i-th, the projection on the i-th basis vector is just qi transpose b. That, that, that, that number x that we look for is, is just a dot product. OK. OK, so I'm ready now for the sort of like second half of the lecture."}
{"text": " We don't start with an orthogonal matrix or orthonormal vectors. We just start with independent vectors and we want to make them orthonormal. So I'm going to, can I do that now? Now, here comes Graham-Schmidt. So, so Graham-Schmidt. So this is a calculation."}
{"text": " I won't say, I can't quite say it's like elimination, because it's different. Our goal isn't triangular anymore. With elimination, our goal was make the matrix triangular. Now our goal is make the matrix orthogonal. Make those columns orthonormal."}
{"text": " So let me start with two columns. So I start with vectors A and B. And they're just like here, let me draw them. Here's A. Here's B. For example. A isn't specially horizontal, wasn't meant to be. Just A is one vector, B is another. I want to produce."}
{"text": " Those two vectors, they might be in twelve-dimensional space, or they might be in two-dimensional space. They're independent anyway. So I better be sure I say that. I start with independent vectors. And I want to produce out of that Q1 and Q2. I want to produce orthonormal vectors. And Gram-"}
{"text": " And Schmidt, tell me how. OK. Well, actually, you could tell me how. We don't need, frankly, I don't know. There's only one idea here. If Graham had the idea, I don't know what Schmidt did. But, OK, you'll see it. We don't need either of them, actually. OK. So what am I going to do? I'll take that, this first guy."}
{"text": " OK. Well, he's fine. That direction is fine, except, yeah, I'll say, OK, I'll settle for that direction. So I'm going to, I'm going to get, so what am I going to, my goal is I'm going to get orthogonal vectors, and I'll call those capital A and B."}
{"text": " So that's the key step, is to get from any two vectors to two orthogonal vectors. And then, at the end, no problem, I'll get orthonormal vectors. How will- what will tho- those will be my q's, q1 and q2. And what will they be?"}
{"text": " Once I've got A and B orthogonal, well, look, it's no big deal. Maybe that's what Schmitt did. He, brilliant Schmitt, thought, OK, divide by the length. All right. That's Schmitt's contribution. OK."}
{"text": " But Graham had a little more thinking to do, right? We haven't done Graham's part. This part, except, OK, I'm happy with A, A can be A. That first direction is fine. Why should co- no complaint about that. The trouble is the second direction is not fine, because it's not orthogonal to the first. I'm looking for a vector."}
{"text": " that starts with B but makes it orthogonal to A. What's the vector? How do I do that? How do I produce from this vector a piece that's orthogonal to this one? And the, remember, these vectors might be in two dimensions or they might be in twelve dimensions."}
{"text": " I'm just looking for the idea. So what's the idea? Where did we have orthogonal, a vector showing up that was orthogonal to this guy? Well, that was the first basic calculation of the whole chapter. We did a projection, and the projection gave us this part,"}
{"text": " which was the part in the A direction. Now the part we want is the other part, the E part, this part. This is going to be our, this is, this is, that guy is that guy. This is our vector B, that's, that gives us that ninety degree angle. So B is, you could say, B is really what we previously called E. The, the, the error vector."}
{"text": " And so, and what is it? I mean, what do I, what is B here? A, A is A, no problem. B is, OK, what's this, what's this error piece? Do you remember? It's, it's I start with the original B and I take away what? It's projection, this P."}
{"text": " The vector b, this error vector, is the original vector removing the projection. So instead of wanting the projection, now that's what I want to throw away. I want to get the part that's perpendicular. And there will be a perpendicular part, it won't be zero."}
{"text": " Because these vectors were independent, so if B was along the direction of A, then if the original B and A were in the same direction, then I've only got one direction. But here they're in two independent directions, and all I'm doing is getting that guy. So what's its formula?"}
{"text": " What's the formula for that? I want to subtract the projection, so do you remember the projection? It's some multiple of A, and what's that multiple? It's that thing we called x in the very, very first lecture on this chapter. There's an A transpose A in the bottom,"}
{"text": " And there's an A transpose B, isn't that it? I think that's Graham's formula."}
{"text": " Or Gram-Schmidt. No, that's Gram. Schmidt has got to divide the whole thing by the length, so he's just, his formula makes a mess which I'm not willing to write down. So let's just see that, what am I saying here? I'm saying that this vector B is perpendicular to A. That these are orthogonal. A is perpendicular to B."}
{"text": " Can you check that? How do you see that yes, of course, our picture is telling us yes, we did it right. How would I check that this matrix is perpendicular to A? I would multiply by A transpose and I better get zero, right? I should check that. A transpose B should come out zero."}
{"text": " So this is A transpose times now what did we say B was? We start with the original B and we take away this projection and that should come out zero. Well, here we get an A transpose B."}
{"text": " minus, and here is another A transpose B, and the, and it's an A transpose A over A transpose A, a one, those cancel, and we do get zero. Right. Now I guess I can do numbers in there."}
{"text": " But I have to take a third vector to be sure we've got this system down. So now I have to say if I have independent vectors A, B and C, I'm looking for orthogonal vectors A, B and capital C, and then of course the third guy will just be C over its length, the unit vector."}
{"text": " So this is now the problem. I got B here. I got A very easily. And now if you see the idea, we could figure out a formula for C."}
{"text": " So this is like a typical homework quiz problem. I give you two vectors, you do this. I give you three vectors, and you have to make them orthonormal. So you do this again, the first vector's fine, the second vector is perpendicular to the first, and now I need a third vector that's perpendicular to the first one and the second one, right?"}
{"text": " This is the end of the lecture, is to find this guy. Find this vector C that's perpendicular. At this point we know A and B. But C, the little c that we're given, is off in some oh, it's got to come out of the blackboard to be independent. So can I sort of draw off? Off comes a C somewhere. I don't know, where am I going to put the darn thing?"}
{"text": " Maybe I'll put it off, oh, I don't know, like that, somehow, c, little c. And I already know that perpendicular direction, that one and that one, so now what's the idea? Give me the Gram-Schmidt formula for c. What is this c here? Equals what?"}
{"text": " What am I going to do? I'll start with the given one, as before. Right? I start with the vector I'm given. And what do I do with it? I want to remove out of it, I want to subtract off, so I'll put a minus sign in, I want to subtract off its components in the A, capital A and capital B directions. I just want to get those out of there."}
{"text": " Well, I know how to do that. I did it with B, so I'll just, so let me, let me take away, what if I do this? What have I done? I've, I've got little c, and what have I subtracted from it? Its component, its projection, if you like, in the A direction."}
{"text": " And now I've got to subtract off its component B transpose C over B transpose B. That multiple of B is its component in the B direction. And that gives me the vector capital C that if anything is, if there's any justice,"}
{"text": " This C should be perpendicular to A and it should be perpendicular to B. And the only thing it hasn't got is unit vector, so we divide by its length to get that two. OK. Let me do an example. I'll make my life easy, I'll just take two vectors."}
{"text": " So let me do a numerical example. If I'll give you two vectors, you give me back the Gram-Schmidt orthonormal basis, and we'll see how to express that in matrix form. Okay. So let me give you the two vectors. So, so I'll take the vector A equals, let's say, one one one. Why not?"}
{"text": " And B equals, let's say, one, zero, two, OK? I didn't want to cheat and make them orthogonal in the first place, because then Gram-Schmidt wouldn't be needed. OK, so those are not orthogonal. So what is capital A? Well, that's the same as big A. That was fine. What's B?"}
{"text": " So B is this b- is the original B, and then I subtract off some multiple of the A. And what's the multiple? What goes in here?"}
{"text": " B, here's the A, this is the little b, this is the big A, also the little a, and I want to multiply it by that right ratio, which has A transpose A, oh, here's my ratio. I'm just doing this. So it's A transpose B. What is A transpose B? It looks like three. And what is A, oh my."}
{"text": " What's A transpose A? Three. I'm sorry. I didn't know that was going to happen. OK. But it happened. Why should we knock it? OK. So do you see it all right? That's A transpose B, there's A transpose A, that's the fraction."}
{"text": " So I take this away and I get one, take away one is a zero, zero minus this one is a minus one, and two minus the one is a one. OK. And what's this vector that we finally found? This is b. And how do I know it's right?"}
{"text": " How do I know I've got a vector I want? I check that A and B are perpendicular. That A is perpendicular to B. Just look at that. The dot product of that with that is zero. OK. So now what is my Q1 and Q2? Why don't I put them in a matrix?"}
{"text": " Of course, since I'm always putting these, so the Q, I'll put the Q1 and the Q2 in a matrix, and what are they? Now, when I'm writing Qs, I've, I've, I'm supposed to make things normalized. I'm supposed to make things unit vectors. So I'm going to take that A, but I'm going to divide it by square root of three."}
{"text": " And I'm going to take this b, but I'm going to divide it by square root of two to make it a unit vector. And there is my matrix. That's my matrix with orthonormal columns coming from Gram-Schmidt, and it sort of, it came from the original one one one one zero two, right? That was my original, guys."}
{"text": " These were the two I started with, these are the two that I'm happy to end with, because those are orthonormal. So that's what Gram-Schmidt did. And, well, tell me about the column spaces of these matrices. How is the column space of Q related to the column space of A?"}
{"text": " So I'm always asking you things like this, and that makes you think, OK, the column space is all combinations of the columns. It's that plane, right? I've got two vectors in three-dimensional space. The column space is a plane. The column space of this matrix is a plane. What's the relation between the planes? Between the two column spaces?"}
{"text": " They're one and the same, right? It's the same column space. All I'm taking is here this b thing that I computed, this b thing that I computed is a combination of b and a, and a was little a, so I'm always working here with this in the same space. I'm just, like, getting ninety degree angles in there."}
{"text": " where my original column space had a perfectly good basis, but it wasn't as good as this basis, because it wasn't orthonormal. Now this one is orthonormal, and I have a basis then that for so now projections, all the calculations I would ever want to do are a cinch with this orthonormal basis. One final point."}
{"text": " One final point in this chapter. And it's just like elimination. We learn how to do elimination, we know all the steps, we can do it. But then I came back to it and said, look at it as a matrix."}
{"text": " in matrix language and elimination gave me what was elimination in matrix language? I'll just put it up there. A was L U. That was matrix, that was elimination. Now I want to do the same for Gram-Schmidt."}
{"text": " Everybody who works in linear algebra isn't going to write out the columns are orthogonal, or orthonormal, and isn't going to write out these formulas. They're going to write out the connection between the matrix A and the matrix Q. And the two matrices have the same column space, but there's some matrix is taking, and I'm going to call it R,"}
{"text": " So A equals QR is the magic formula here. It's the expression of Gram-Schmidt. And let me just capture that. So that's the my final step, then, is A equal QR. Maybe I can squeeze it in here."}
{"text": " So A has columns, let's say A1 and A2. Let me suppose N is two, just two vectors. Okay. So that's some combination of Q1 and Q2 and times some matrix R. They have the same column space."}
{"text": " This is just, this matrix just includes in it whatever these numbers like three over three and one over square root of three and one over square root of two. Probably that's, probably that's what it's got. One over square root of three, one over square root of two, something there. But actually, it's got a zero there."}
{"text": " So the main point about this A equal Q R is this R turns out to be upper triangular. It turns out that this zero is upper triangular. I could, we could see why. Let me see, I can put in general formulas for what these are. This, I think in here, should be the inner product of A1 with Q1."}
{"text": " And this one should be the inner product of A1 with Q2. And that's what I believe is zero. And this will be something here, and this will be something here with inner A1 transpose Q2, sorry, A2 transpose Q1 and A2 transpose Q2. But why is that guy zero?"}
{"text": " Why is A1 Q2 zero? That's the key to this being, this R here being upper triangular. You know why A1 Q2 is zero, because A1, that was my, this was really A and B here. This was really A and B."}
{"text": " So this is A transpose Q2. And the whole point of Gram-Schmidt was that we constructed these later Qs to be perpendicular to the earlier vectors. To the earlier, all the earlier vectors. So that's why we get a triangular matrix. The, the, so the, it's, the result is extremely satisfactory."}
{"text": " that ortho- that if I have a matrix with independent columns, the Gram-Schmidt produces a matrix with orthonormal columns, and the connection between those is a triangular matrix. That last point, that the connection is a triangular matrix, please look in the book. You have to see that one more time. Okay. Thanks. That's great."}
{"text": " and lift off on differential equations. So this section is about how to solve a system of first order, first derivative, constant coefficient, linear equations."}
{"text": " If we do it right, it turns directly into linear algebra. The key idea is the solutions to constant coefficient linear equations are exponentials."}
{"text": " So if you look for an exponential, then all you have to find is what's up there in the exponent and what multiplies the exponential, and that's the linear algebra. So, and the result, one thing we will find, it's completely parallel to powers of a matrix. So the last lecture,"}
{"text": " was about how would you compute A to the k, or A to the one hundred. How do you compute high powers of a matrix? Now, it's not powers anymore, but it's exponentials. That's the natural thing for differential equation. OK. But can I begin with an example? And I'll just go through the mechanics. How would I solve?"}
{"text": " The differential equa- two differential equations, so I'm going to make it, I'll have a two by two matrix, and the coefficients are minus one, two, one minus two, and I better give you some initial condition. So suppose it starts u at time zero, this is u1, u2, let it, let it,"}
{"text": " Suppose everything is in u1 at time zero. So at the start it's all in u1, but what happens as time goes on, du2 dt will be positive because of that u1 term, so flow will move into the u2 component. And it will go out of the u1 component."}
{"text": " So we'll just follow that movement as time goes forward by looking at the eigenvalues and eigenvectors of that matrix. That's the first job. Before you do anything else, find the matrix and its eigenvalues and eigenvectors. So let me do that. OK. So here's our matrix."}
{"text": " Maybe you can tell me right away what are the eigenvalues and eigenvalues anyway, and then we can check, but can you spot any of the eigenvalues of that matrix? We're looking for two eigenvalues. Do you see, I mean, if I just wrote that matrix down, what do you notice about it? It's singular, right."}
{"text": " That's a singular matrix, that tells me right away that one of the eigenvalues is lambda equals zero. I can, that's a singular matrix, the, the second column is minus two times the first column, the determinant is zero, it's, it's singular, so zero is an eigenvalue and the other eigenvalue will be from the trace,"}
{"text": " I look at the trace, the sum down the diagonal is minus three, that has to agree with the sum of the eigenvalues, so that second eigenvalue better be minus three. I could, of course, I could compute, why don't I over here compute the determinant of A minus lambda I, the determinant of this minus one minus lambda two one minus two minus lambda matrix, but we know what's coming."}
{"text": " When I do that multiplication, I get a lambda squared, I get a two lambda and a one lambda, that's a three lambda, and then the, now I'm going to get the determinant, which is two minus two, which is zero, so there's my characteristic polynomial, this determinant. And, of course, I factor that into lambda times lambda plus three."}
{"text": " And I get the two eigenvalues that we saw coming. What else do I need? The eigenvectors. So before I even think about the differential equation or what, how to solve it, let me find the eigenvectors for this matrix. Okay. So take lambda equals zero. So that, that's the first eigenvalue. Lambda one equals zero. And the second eigenvalue will be lambda two equals minus three."}
{"text": " By the way, I already know something important about this. The eigenvalues are telling me something. You'll see how it comes out, but let me point to, these numbers are, this eigenvalue, a negative eigenvalue, is going to disappear. There's going to be an e to the minus three t in the answer."}
{"text": " That e to the minus three t as time goes on is going to be very, very small. The other part of the answer will involve an e to the zero t. But e to the zero t is one, and that's a constant. So I'm expecting"}
{"text": " that this solution will have two parts, an e to the zero t part and an e to the minus three t part. And the, and as time goes on, the second part will disappear and the first part will be a steady state. It won't move."}
{"text": " It will be at the end of, as t approaches infinity, this part disappears and this is the e to the zero t part is what I get. And I'm very interested in these steady states. So that's, I get a steady state when I have a zero eigenvalue. OK, what about those eigenvectors? So what's the eigenvector that goes with eigenvalue zero? OK, the matrix is singular as it is."}
{"text": " The eigenvector is the guy in the null space, so what vector is in the null space of that matrix? Let's see, I guess I probably give the free variable the value one, and I realize that if I want to get zero, I need a two up here. OK? So A x1 is zero x1. A x1 is zero x1. Fine."}
{"text": " OK. What about the other eigenvalue? Lambda two is minus three. OK. How do I get the other eigenvalue then for the moment? Can I mentally do it? I subtract minus three along the diagonal, which means I add three. Can I, I'll just do it with an erase, erase for the moment. So I'm going to add three to the diagonal. So this minus one will become a two."}
{"text": " And I'll make it in big loopy letters. And when I add three to this guy, the minus two becomes, I can't make one very loopy, but how's that? OK. Now that's A minus three I, A plus three I, sorry. That's A plus three I. It's supposed to be singular, right? If things, if I did it right, this matrix should be singular and the x2, the eigenvector, should be in its null space."}
{"text": " OK, what do I get for the null space of this? Maybe minus one, one. Or one minus one. Doesn't matter. Those are both perfectly good. Right? That's in the null space of this. Now I'll, because A times that vector is three times that vector. Ax2 is minus three x2. Good."}
{"text": " OK, can I get A again so we see that correctly? That was a minus one and that was a minus two. Good. OK. That's the first job. Eigenvalues and eigenvectors. And already the eigenvalues are telling me the most important information about the answer. But now, what is the answer? The answer is the solution."}
{"text": " will be u of t, OK, now I use those eigenvalues and eigenvectors. The solution is some, there are two eigenvalues, so there are going to be two special solutions here. Two pure exponential solutions. The first one is going to be e to the lambda one t x1,"}
{"text": " And the sec- so that solves the equation, and so does this one. They both are solutions to the differential equation. That's the general solution. The general solution is a combination of that pure exponential solution and that pure exponential solution. Can I just see that those guys do solve the equation? So let me just check, check on this one, for example."}
{"text": " check that my equation, let's remember the equation du dt is Au, I plug in e to the lambda one t x1, and let's just see that the equation's OK."}
{"text": " I believe this is a solution to that equation. So just plug it in. On the left-hand side, I take the time derivative. So the left-hand side will be lambda one, e to the lambda one t x one, right? The time derivative, this is the term that depends on time, it's just ordinary exponential, its derivative brings down a lambda one. On the other side of the equation, it's A times this thing."}
{"text": " A times e to the lambda one t x1. And does that check out? Do we have equality there? Yes, because e to the lambda one t appears on both sides, and the other one is Ax1 equal lambda one x1, check. Do you, so we've come to the first point to remember. These pure solutions."}
{"text": " Those pure solutions are the, those pure exponentials are the differential equations analog of last time we had pure powers. Last time, so"}
{"text": " So last time the analog was lambda one to the k-th power x1, some amount of that, plus some amount of lambda two to the k-th power x2. That was our formula from last time. I put it up just to, so you, your eye compares those two formulas."}
{"text": " powers of lambda in the, in the difference equation, that this was in the, this was for the equation u k plus one equals A u k, that was for the finite step, stepping by one, and we got powers, now this is the one we're interested in, the exponentials."}
{"text": " So that's, that's the solution. What are C1 and C2? Then we're through. What are C1 and C2? Well, of course we know these actual things. Let me just, let me come back to this. C1 is, we haven't figured out yet, but e to the lambda one t, the lambda one is zero. So that's just a one times x1, which is two one."}
{"text": " So it's c1 times this one that's not moving times the vector, the eigenvector two one, and c2 times what's e to the lambda two t? Lambda two is minus three. So this is the term that has the minus three t and its eigenvector is this one minus one. So this vector,"}
{"text": " solves the equation and any multiple of it. This vector solves the equation if it's got that factor e to the minus three t. We've got the answer except for c1 and c2. So, so everything I've done is immediate as soon as you know the eigenvalues and eigenvectors. So how do we get c1 and c2? That has to come from the initial condition. So now I, now I use u of zero."}
{"text": " is given as one zero. So this is the initial condition that will find c1 and c2. So let me do that on the board underneath. At t equals zero, then. I get c1 times this guy."}
{"text": " plus c2 and now I'm at time zero, so that's a one and this is a one minus one and that's supposed to agree with u of zero, one zero. Okay. That should be two equations. That should give me c1 and c2 and then I'm through. So what are c1 and c2? Let's see."}
{"text": " I guess we could actually spot them by I, or we could solve two equations in two unknowns. Let's see. If these were both ones, so I'm just adding, then I would get three zero. So what's the solution, then? If C1 and C2 are both ones, I get three zero, so I want, like, one third of that. Because I want to get one zero. So I think it's C1 equals a third."}
{"text": " c2 equals a third. So finally I have the answer. Let me keep it in the, in this board here. Finally the answer is one third of this plus one third of this."}
{"text": " Do you see what, what's actually happening with this flow? This flow started out at, the solution started out at one zero. Started at one zero. Then as time went on, people moved, essentially. Some fraction of this one moved here. And, and in the limit,"}
{"text": " There's, there's the limit, as it, right? As T goes to infinity, as T gets very large, this disappears and this is the steady state. So the steady state is, so the steady state u, we could call it u at infinity, is one third of two and one. It's, it's two thirds, one third."}
{"text": " So that's the, we really, I mean, you're getting, like, total, insight into the behavior of the solution, what the differential equation does. Of course, we don't, wouldn't always have a steady state. Sometimes we would approach zero. Sometimes we would blow up. Can we straighten out those, those cases?"}
{"text": " The eigenvalues should tell us. So when do we get, so let me ask first, when do we get stability? That's u of t going to zero. When would the solution go to zero, no matter what the initial condition is?"}
{"text": " Negative eigenvalues, right. Negative eigenvalues. But now I have to, I have to ask you for one more step. Suppose the eigenvalues are complex numbers. Because we know they could be. Then we want stability, this, this, we, we want, we need all these e to the lambda t's all going to zero."}
{"text": " And somehow that asks us to have lambda negative. But suppose lambda is a complex number, then what's the test? What if lambda's a complex number like, suppose lambda is negative plus an imaginary part. Say lambda is minus three plus six i."}
{"text": " What happens then? Could we just, like, do a case here? If this lambda is minus three plus six I t, how big is that number? Does this imaginary part play a role here or not? How big is? What's the absolute value of that quantity?"}
{"text": " It's just e to the minus three t, right? Because this other part, this e to the six i t, that has absolute value one. Right? That's just this cosine of six t plus i sine of six t, and the absolute value squared will be cos squared plus sine squared will be one."}
{"text": " This complex number is running around the unit circle. It's the real part that matters. This is what I'm trying to do. Real part of lambda has to be negative. If lambda's a complex number, it's the real part, the minus three that either makes us go to zero"}
{"text": " or doesn't, or blows up, the imaginary part will just, like, oscillate between the two components. OK. So that's stability. And what about, what about a steady state? When would we have, a steady state always in the same direction? So let me, I'll take,"}
{"text": " this part away when so that was like checking that it's that is the real part that we care about. Now we have a steady state when when lambda one is zero and the other eigenvalues have what? So I'm looking like that example was like perfect."}
{"text": " for a steady state, we have a zero eigenvalue and the other eigenvalues, we want those to disappear. So the other eigenvalues have real part negative. And we blow up, for sure, we blow up if any real part of lambda is positive."}
{"text": " So if I reverse the sign of the matrix A, suppose instead of the matrix I had, the A that I had, I changed all its signs. What would that do to the eigenvalues and eigenvectors? If I know the eigenvalues and eigenvectors of A, tell me about minus A. What happens to the eigenvalues? For minus A, they'll all change sign."}
{"text": " So I'll have blowup. This, instead of the e to the minus three t, if I change that to minus, if I change the signs in that matrix, I would change the trace to plus three, I would have an e to the plus three t and I would have blowup. Of course, the zero eigenvalue would stay at zero, but the other guy is taking off in, if I reversed all the signs."}
{"text": " OK, so this is the stability picture. And for a two by two matrix, we can actually pin down even more closely what that means. Can I do that? Let me do that. I want to, for a two by two matrix,"}
{"text": " I can tell whether the real part of the eigenvalues is negative. Well, let me tell you what I have in mind for that. So two by two stability. Let me, this is just a little comment. Two by two stability. So my matrix now is just A B C D."}
{"text": " And I'm looking for the real parts of both eigenvalues to be negative. Okay. What, how can I tell from looking at the matrix without computing its eigenvalues whether the two eigenvalues are negative?"}
{"text": " or at least their real parts are negative. What would that tell me about the trace? So the trace, that's this A plus D. What can you tell me about the trace?"}
{"text": " In the case of a two by two stable matrix, that means the eigenvalues are negative, or at least the real parts of those eigenvalues are negative, then when I take the tr- when I look at the matrix and, and find its trace, what, what do I know about that? It's negative, right. This is the sum of the, this equals, this equals lambda one plus lambda two, so it's negative."}
{"text": " The two eigenvalues, by the way, will have, if they're complex, will have plus 6I and minus 6I. The complex parts will be conjugates of each other and disappear when we add and the trace will be negative. Okay, the trace has to be negative. Is that enough, is a negative trace enough to make the matrix stable?"}
{"text": " shouldn't be enough, right? Can I, can you make, what's a matrix that has a negative trace but still it's not stable? So it has a blow-up, it still has a blow-up factor and a decaying one. So what would be a, so just to see, maybe I just put that here, this, now I'm looking for an example where the trace could be negative but still blow up."}
{"text": " Yeah, let's just take one. Oh, look, let me make it minus two zero zero one. OK. There's a case where that matrix has negative trace. I know its eigenvalues, of course, they're minus two and one, and it blows up. It's got a plus one eigenvalue here."}
{"text": " So there'll be an e to the plus t in the solution and it'll blow up if it has any second component at all. I need another condition. And it's a condition on the determinant. And what's that condition? If I know that the two eigenvalues, suppose I know they're negative. Well, negative. What does that tell me about the determinant?"}
{"text": " Let me ask again. If I know both the eigenvalues are negative, then I know the trace is negative, but the determinant is positive. Because it's the product of the two eigenvalues."}
{"text": " So this determinant is lambda one times lambda two, this is lambda one times lambda two, and if they're both negative, the product is positive. So positive determinant, negative trace. I can easily track down the, this condition also for the, if there's an imaginary part hanging around."}
{"text": " OK, so that's, like, a small but quite useful, because two by two is always important, comment on stability. OK. So let's just look at the picture again. OK. The main part of my lecture, the one thing you want to be able to, like, just do automatically is this step of solving the system."}
{"text": " Find the eigenvalues, find the eigenvectors, find the coefficients. And notice, what's the matrix in this linear system here, I can't help, if I have equations like that, that's my equations column at a time, what's the matrix form of that equation? So this system of equations is some matrix"}
{"text": " multiplying c1 c2 to give u of zero, one zero. What's the matrix? Well, it's obviously two one, one minus one, but we have a name, or at least a letter, actually a name for that matrix. What matrix are we dealing with here in this step of finding the c's? Its letter is?"}
{"text": " s, it's the eigenvector matrix. Of course, these are the eigenvectors. They're in the columns of our matrix. So this is sc equals u of zero. Is the, is the, that step where you find the actual coefficients, you find out how much of each pure exponential is in the solution."}
{"text": " by getting it right at the start, then it stays right forever. You're seeing this picture that each pure exponential goes on its own way once you start it from u of zero. So you start it by figuring out how much each one is present in u of zero and then off they go."}
{"text": " OK, so that's a system of two equations in two unknowns, coupled, the matrix sort of couples u1 and u2, and the eigenvalues and eigenvectors uncouple it, diagonalize it. Actually, OK, now can I?"}
{"text": " Can I think in terms of S and lambda? So I want to write the solution down again in terms of S and lambda. OK, I'll do that on this far board. OK. So I'm coming back to, I'm coming back to our equation du dt equals Au."}
{"text": " Now this matrix A couples them. The whole point of eigenvectors is to uncouple. So one way to see that is introduce set U equal A, not A, it's S, the eigenvector matrix that uncouples. So I'm taking this."}
{"text": " equation, as I'm given, coupled with, with A has, is probably full of non-zeros, but I'm, by uncoupling it I mean I'm diagonalizing it. If I can get a diagonal matrix, I'm, I'm in. OK. So I plug that in, this is A S V, and this is S dv dt,"}
{"text": " S is a constant, it's the, this is the eigenvector matrix. This is the eigenvector matrix. OK, now I'm going to bring S inverse over here. And what have I got? That combination S inverse A S is lambda, the diagonal matrix."}
{"text": " That's, that's the point, that, that in, if I'm using the eigenvectors as my basis, then my system of equations is just diagonal, I, each, there's no coupling anymore, dv1 dt is lambda one v1, so let's just write that down, dv1 dt"}
{"text": " is lambda one v one and so on for all n of the equations. It's a system of equations, but they're not connected. So they're easy to solve, and why don't I just write down the solution? v, well, v is now some e to the lambda one t, well, OK,"}
{"text": " I guess my idea here now is to use, the natural notation v of t is e to the lambda t v of zero. And u of t will be s e to the lambda t s inverse, u of zero. This is the, this is the,"}
{"text": " a formula I'm headed for. This, this matrix, S e to the lambda t S inverse, that's my exponential, that's my e to the A t, is this S e to the lambda t S inverse."}
{"text": " So my job really now is to explain what's going on with this matrix up in the exponential. What does that mean? What does it mean to say e to a matrix? This ought to be easier, because this is e to a diagonal matrix, but still it's a matrix. What do we mean by e to the A t? Because really, e to the A t is my answer here."}
{"text": " My answer to this equation is this u of t, this is my e to the A t u of zero. So it's my job is really now to say what does that mean? What's the exponential of a matrix and why is that formula correct? Okay. So I'll put that on the board underneath."}
{"text": " What's the exponential of a matrix? Let me come back here. So I'm talking about matrix exponentials. e to the A t. OK. How are we going to define the exponential of a, of, of something? The trick, the, the idea is, the, the thing to go back to is,"}
{"text": " Exponential, there's a power series for exponentials. That's how you, you, the good way to define e to the x is the power series one plus x plus one half x squared, one sixth x cubed, and we'll do it now when the, when we have a matrix. So the one becomes the identity, the x is A T,"}
{"text": " The x squared is A t squared, and I divide by two. The cube, the x cube is A t cubed over six, and what's the general term in here? A t to the nth power divided by, and it goes on, but what do I divide by?"}
{"text": " So you see the pattern, here I divided by one, here I divided by one, by two, by six, those are the factorials, it's N factorial. That was like the one beautiful Taylor series. The one beautiful Taylor series, well, there are two, there are two beautiful Taylor series in this world. The Taylor series for e to the x,"}
{"text": " is the sum with x to the n-th over n factorial. And all I'm doing is doing the same thing for matrices. The other beautiful Taylor series is just the sum of x to the n-th, not divided by n factorial. Can you, do you know what function that one is? So if I take, this is the series, all these sums are going from zero to infinity."}
{"text": " What, what function have I got? This is like a side comment. This is one plus x plus x squared plus x cubed plus x to the fourth, not divided by anything. What, what's that function? One plus x plus x squared plus x cubed plus x fourth forever is one over one minus x. It's the geometric series."}
{"text": " the nicest power series of all. So actually, of course, there would be a similar thing here. If I wanted, I minus A T inverse would be, now I've got matrices, I've got to have matrices everywhere, but it's just like that series with and just like this one without the divisions. It's I plus A T plus A T squared."}
{"text": " plus A T cubed and forever. So that's actually a reasonable way to find the inverse of a matrix. If I chop it off, well, it's reasonable if T is small. If T is a small number, then T squared is extremely small, T cubed is even smaller, so approximately that inverse is I plus A T."}
{"text": " I can keep more terms if I like. Do you see what I'm doing? I'm just saying we can do the same thing for matrices that we do for ordinary functions, and the good thing about the exponential series, so in a way this series is better than this one. Why?"}
{"text": " Because this one always converges. I'm dividing by these bigger and bigger numbers, so whatever matrix A, and however large T is, that series, these terms go to zero, the series adds up to a finite sum, e to the A T is a, is, is completely defined. Whereas the second guy could fail, right? If A T is big,"}
{"text": " Somehow if A T has an eigenvalue larger than one, then when I square it, it'll have that eigenvalue squared, when I cube it, the eigenvalue will be cubed. That series will blow up."}
{"text": " unless the eigenvalues of A T are smaller than one. So when the eigenvalues of A T are smaller than one, so I better put that in, the eigen- all eigenvalues of A T below one, then that series converges and gives me the inverse. OK. So this is the guy I'm chiefly interested in, and I wanted to connect it to"}
{"text": " Oh, OK, what's, how do I, how do I get, this is my, like, main thing now to do. How, how do I get e to the A t? How do I see that e to the A t is the same as this? In other words, I can find e to the A t by finding s and lambda, because now e to the lambda t is easy."}
{"text": " Lambda's a diagonal matrix, and we can write down e to the lambda t and will, right, in a minute. But how, do you see what, do you see that we're hoping for a, we're hoping that we can compute e to the A t from S and lambda, and I have to look at that definition and say, OK, how do I get an S and a lambda to come out of that?"}
{"text": " OK, can you see how I, I want to connect that to that, from that definition. So let me erase this, the geometric series, which isn't part of the differential equations case, and get the S and the lambda into this picture. Oh, OK. Here we go."}
{"text": " So identity is fine. Now, all right, you can see how am I going to get A replaced by S and Ss and lambdas? Well, I use the fundamental formula of this whole chapter. A is S lambda S inverse and then times T. That's A T. OK, what's A squared T?"}
{"text": " I've got the divide by two, I've got the T squared, and I've got an A squared. All right. So I've got a s- there's A, there's A, now square it. So what happens when I square it? We've seen that before. When I square it, I get S lambda squared S inverse, right?"}
{"text": " When I square that thing, there's an S and an S cancels out an S inverse, I'm left with the S on the left, the S inverse on the right, and lambda squared in the middle. And so on. The next one will be S lambda cubed S inverse times T cubed over three factorial."}
{"text": " What do I do now? I want to pull an S out from everything. I want an S out of the whole thing. Oh, look. I better write the identity how? I want to be able to pull an S out and an S inverse out from the other side, so I just write the identity as S times S inverse. So I have an S there and an S inverse from this side, and what have I got in the middle?"}
{"text": " If I pull out an S and an S inverse, what have I got in the middle? I've got the identity, a lambda t, a lambda squared t squared over two, I've got e to the lambda t. That's what's in the middle. That's my formula for e to the A t. Oh, now I have to ask you, does this formula always work? This formula always works."}
{"text": " Well, except it's an infinite series. But what do I mean by always work? And this one doesn't always work, and I just have to remind you of what assumption is built into this formula that's not built into the original. The assumption that A can be diagonalized. You remember that there are some small,"}
{"text": " some subset of matrices that don't have n independent eigenvectors, so we don't have an S inverse for those matrices and the whole diagonalization breaks down."}
{"text": " We could still make it triangular, I'll tell you about that, but diagonal we can't do for those particular degenerate matrices that don't have enough independent eigenvectors. But otherwise, this is golden. Okay. So that's the formula, that's the matrix exponential. Now it just remains for me to say what is e to the lambda t. Can I just do that? Let me just put that in the corner here."}
{"text": " What is the exponential of a diagonal matrix? Remember lambda is diagonal, lambda one down to lambda n. What's the exponential of that diagonal matrix? Because our whole point is that this ought to be simple."}
{"text": " Our whole point is that when to take the exponential of a diagonal matrix ought to be completely decoupled, it ought to be diagonal, in other words. And it is. It's just e to the lambda one t, e to the lambda two t, e to the lambda n t. All zeros. So if we have a diagonal matrix and I plug it into this exponential formula,"}
{"text": " Everything's diagonal and the diagonal terms are just the ordinary scalar exponentials e to the lambda one t. OK, so that's, in a sense I'm doing here on this board with, with like formulas."}
{"text": " What I did in the first half of the lecture with specific matrix A and specific eigenvalues and eigenvectors. So let me show you the formulas again. So I guess what should you know from this lecture? You should know what this matrix exponential is and, like, when does it go to zero?"}
{"text": " Tell me again now the answer to that. When does e to the A t approach get smaller and smaller as t increases? Well, the S and the S inverse aren't moving. It's this one that has to get smaller and smaller, and that one has this simple diagonal form."}
{"text": " and it goes to zero provided every one of these lambdas, I need to have each one of these guys go to zero, so I need every real part of every eigenvalue negative. Right? If the real part is negative, that takes the exponential, that forces the exponential goes to zero. OK. So that's really the difference, if I can just"}
{"text": " draw the here's a picture of the of the this is the complex plane. Here's the real axis and here's the imaginary axis. And where do the eigenvalues have to be for stability in differential equations? They have to be over here. In the left half plane. So the left half plane is this plane, real part of lambda less than zero."}
{"text": " Where do the eigenvalues have to be for powers of the matrix to go to zero? Powers of the matrix go to zero if the eigenvalues are in here. So this is the stability region for powers, this is the region absolute value of lambda less than one."}
{"text": " That's the stability for f- that tells us that the powers of A go to zero, this tells us that the exponential of A goes to zero. Okay. One final example, let me just write down how to deal with a, with a final example. Let's see."}
{"text": " So my final example will be a single equation, u double prime plus a b u prime plus k u equals zero. One equation, second order. How do I -- and maybe I should have used, I'll use, I prefer to use y here, because that's what you see in differential equations."}
{"text": " And I want u to be a vector. So how do I change one second order equation into a two by two first order system? Just the way I did for Fibonacci. I'll let u be y prime and y."}
{"text": " What I'm going to do is I'm going to add, an extra equation, y prime equals y prime. So I take this, so by, so using this as the vector unknown, now my equation is u prime, my first order system is u prime, that'll be y double prime y prime, the derivative of u,"}
{"text": " OK, now the differential equation is telling me that y double prime is m- so I'm, I'm just looking for what's this matrix? y prime y. I'm looking for the matrix A. What's the matrix?"}
{"text": " In case I have a single first order equation and I want to make it into a two by two system. Okay, simple. The first row of the matrix is given by the equation. So y double prime is minus b y prime minus k y, no problem. And what's the second row of the matrix? Then we're done."}
{"text": " The second row of the matrix I want just to be the trivial equation y prime equals y prime, so I need a one and a zero there. So matrices like these."}
{"text": " The general case, if I had a five by five, if I had a fifth order equation, and I wanted a five by five matrix, I would see the coefficients of the equation up there, and then my four trivial equations would put ones here. This is the kind of matrix that goes from a fifth order to a five by five first order."}
{"text": " So the and the eigenvalues will come out in a natural way connected to the differential equation. OK. That's differential equations. That a parallel lecture compared to powers of a matrix, we can now do exponentials. Thanks."}
{"text": " Now see first of all what is a heap? Heap is basically you can say it is a tree based data structure and in this case the tree is a complete binary tree or you can say the tree is a"}
{"text": " almost complete binary tree. What is that thing? What is that almost complete binary tree? All the levels in the tree are completely filled except possibly the last level and in the last level all the keys are aligned as left as possible. How a binary tree can be represented using an array in memory that for that video I will provide you the link in the description box you can check it out there we have we have already discussed that thing fine."}
{"text": " Now see now two types of heaps are there one is max heap and one is min heap. Fine now what is difference between max heap and min heap? So now what is min heap and what is max heap? See"}
{"text": " here see let us analyze this way here you can see this the 70 70 is greater than 50 and 40 yes means parent is greater than its child node this 50 is also greater than than its child node 45 and 35 this 40 is greater than 39 and 16 both greater than its child nodes 45 is also greater than its child node that is 10 and 9"}
{"text": " so here what you can say is here the parent node each parent node is greater than its child node fine so max heap is what in max heap you can say for every node i the value of the node is value of the node is either less than or equal to its parent value fine or you can write like this except root node here you are writing"}
{"text": " See this condition is not true for root node. This condition is true for every node except root node. Why so? Because root node is not having any parent."}
{"text": " fine and here I am saying that the value of the node is less than or equal to its parent value but it is not having any parent value so that is why this condition is not true for root node fine or in simple word you can say every parent or you can say every node is having value greater than or equal to all its descendant values."}
{"text": " fine see this 70 is greater than to all its descendant values you can check this 40 is also greater than its descendant value this 50 is also greater than to all its descendant values fine or you can say for every node i for every node i the value of that node would be either greater than or equal to its child node ok and that condition is true for all the nodes."}
{"text": " So here if you are taking i value, see this is the binary, this is the array representation of this binary tree. You see first condition for heap is what? It is a complete binary tree or you can say it is a almost complete binary tree. This is a complete almost complete binary tree. Yes, all the levels except the last level are completely filled and the elements in the last level are as left as possible."}
{"text": " fine so here this is the array representation of this thing I have already discussed this thing in previous video fine array name is a index I am going to start from 1 so 1 here 2 here 3 here we have 4 5 6 7 8 and 9 like this we are going to write down this tree in a array level by level and from left to right fine."}
{"text": " and see now if you are taking i value is equal to 3 for every node i suppose i is equal to 3 this condition should be held now check a of parent of i, i means 3 fine now parent of this thing is 1 right so the value of a of parent of i is 70 it means you can say 70 would be greater than or equal to a of i"}
{"text": " i value is 3 a of 3 what is a of 3 value 40. So this condition is true 70 is greater than 40 yes. So this condition is true for all the nodes except root node because root node is having no parent node. So this is max heap and in max heap the root node would always be the largest element. Here you can check 70 is the largest element among all these fine. Now what about min heap?"}
{"text": " just opposite to this thing parent node would be less than or equal to its child node or you can say for every node i the value of that node would be less than or equal to all its descendant nodes fine or in another word you can say for every node i the value of that node is greater than or equal to its parent value."}
{"text": " So, this condition should be held a of parent should be less than equal to a of i here a of parent i would be greater than equal to a of i and same this condition is true for all the nodes, but not for root node except root node why so, because root node is not having a any parent."}
{"text": " So, for all the i, i means the ith index because we are going to store these nodes these values in the array and this is the ith index 1 2 3 4 up to n fine. So, for every node i the value of that node would be either greater than or equal to its parent node or in another word you can say the parent value should be greater"}
{"text": " less than or equal to its less than or equal to its child node. So, here equal to I am writing that is why here duplicates are allowed fine see here 30 here also you can write 30."}
{"text": " Because the parent node should be either less than or equal to child node. Here parent node should be greater than or equal to its child node. So in min heap the root element would always be the minimum element among the array. Here you can check 10 is the minimum among all these."}
{"text": " Now see how to insert data in max-heap. Let us suppose we are going to insert a data suppose data is 60. I want to insert 60 in this case."}
{"text": " Now, simply what students will do they will check they will compare 60 with 70 or this 60 is less than in max heap obviously root sorry the parent value should be greater than or equal to its child value. So, yeah here 60 we cannot write. So, 50 and 40 minimum is 40. So, we insert 60 here 40 would go down and 16 would go down."}
{"text": " But in that case it will not follow that complete binary tree property. You have to take care of that thing also. Heap is always a complete binary tree. Fine. So, see you cannot insert from root. Always the data would be inserted from leaf node. That is very important point."}
{"text": " So, in the leaf node we are going to insert the data fine and you have to check that after inserting this data in the leaf node that tree should follow the property of complete binary tree fine. In complete binary tree in the last level we can we can insert data as left as possible we have to insert data as left as possible. So, we can insert 60 here to the left of"}
{"text": " See we cannot insert to the right of 60 35 here 60 no because this will not this will violate a property of almost complete binary the data at the last level should be as left as possible. So, you cannot leave this blank and insert"}
{"text": " to the right side you have to first of all fill left position left child fine so here we are going to insert 60 at this place fine and in array where you will insert this you will increase the size size is n to n plus 1 and here i am going to insert 60 at 10th index it is 10th index"}
{"text": " it is not done now see it is satisfying the property of complete binary tree but second thing is it is max heap is it satisfying the property of max heap after inserting the 60 you have to check that thing also now how to check that thing see now 60 you have to check you have to compare the 60 with its parent value"}
{"text": " And what parent value should be in max if parent value should be either greater than or equal to this 60. Now, check parent of this 60 is 35."}
{"text": " fine 35 is less than 60 so that is not allowed in maxi parent should be greater than or equal to child node so what what will be done here swapping would be done 60 would go up and 35 would go down so here we will write 60 and here we will write what 30"}
{"text": " Now here I am making changes in this tree but in code when you are writing a code then this array would be there with you. This is just a pictorial representation. We cannot draw this thing when you are writing a program. So in program how it will be done?"}
{"text": " 10th index so here you can say i is equal to 10 now find out parent of this one now how to find out parent i have just discussed the formula formula is i divide by 2 and floor value so 10 divide by 2 that is 5 so go to the index 5"}
{"text": " at index 5 here it is 35 it means 35 is parent of 60 and 35 is less than 60 so that is not allowed in makeC now in array what will be done the 60 would go here and 35 would go there means swapping fine now here we have 60 but it is not done now"}
{"text": " Because again we are going to check, again we are going to compare this 60 with its parent. Fine. Till we reach to the root node. Fine. Now see, now in check here, 60, parent of 60 is 50. So parent is less than 60. Now again swapping would be done. 60 would go up and this 50 would go down. Fine. Swapping would be done."}
{"text": " here in this case now here i value is now i value is 5 now find out parent 5 divided by 2 and floor value means 2.5 if you are taking floor value then 2 so go to the index 2 here we have 50 it means 50 is parent of 60 but 50 is less than 60 that is not allowed in max heap that is not following the max heap property so swapping would be done so here we will write"}
{"text": " 60 and here we will write in the array 50 fine now i value is 2 now i value is 2 again we have to check parent till we till we reach i value to 1 means to the root now here check with parent parent is 70 70 is greater than 60 that is satisfying maxi property now no swapping would be done"}
{"text": " fine now this is done now in array in this array representation check i is 2 now find out root 2 by 2 i divided by 2 floor value that is 1 go to the index 1 at 1 we have 70 means 70 is parent of 60 right 70 is greater than 60 so that is fine no swapping would be done fine so this is done now insertion of 60 is done after insertion the array would be something like this and tree would be something like this"}
{"text": " Now suppose I want to insert an element having value 5. Now we cannot insert from root simple funda is insert data from the leaf node in the tree fine. In the leaf node where I can insert I can insert to the this to the right of 50 here I can insert 5."}
{"text": " You have to take care of that thing also after inserting this 5 in the leaf node that that tree holds the still holds the property of complete binded tree fine. Now this 50 sorry 5 now here we are going to increase the size of array and that would be here we will insert 5 and index is 11th index."}
{"text": " Now check we have to check it is satisfying the maxi property or not. Now you have to check after inserting this 5 is this satisfying the maxi property or not. Now find out parent of this node the index is 11 parent of this node is 50, 50 is greater than 5. So, this is satisfying maxi property no swapping would be done. Now in this case only one comparison is there and no swapping is done."}
{"text": " Here you can find out see it is at ith index i is equal to 11 parent would be 11 by 2 floor value means 5.5 that is index 5 go to index 5 here we have 50 50 is parent of 5 it means 50 is parent of 5 50 is greater than 5. So, no swapping would be done. So, that is done."}
{"text": " So, see in this case only one comparison was there, no swapping is done. But maximum, maximum how many comparisons can be there? Previous case, like previous case, one is this one, one is this one and one is this one. How many? According to the height of the tree, fine. And height of a complete binary tree is always log n."}
{"text": " So the time complexity, the time taken to insert any element in a max heap is order"}
{"text": " insertion operation will take a time order of log n maximum I am going to take because in this case only one comparison is there no swapping is done but maximum how many comparisons can be there with this one with this one and this one up to the height of the tree and height is always log n so order of log n time would be taken fine this is how we are going to insert a data in maxi now I am going to write you know a piece of code for this insert heap function see I am going to take a function"}
{"text": " insert heap and here I am going to pass array a fine because we are we are having this representation in our program we are not having this tree fine so I am I am working with this array only. Now array total number of elements n and next is which value the data you want to insert you can say value."}
{"text": " fine which value you want to insert ok. Obviously, you have to take care of this data type also here I am not writing the correct one I am just going to tell you the logic. Now, next thing is we are going to increase this size means n is equal to n plus 1 right"}
{"text": " Now next thing is in the last free space we are going to insert that key value because at starting we have inserted that 60 so we have inserted 60 at this place fine. So now we are going to insert at array of n we are going to insert that value fine and we are going to take one variable that will point"}
{"text": " this side because obviously we are going to compare this with its parent then again its parent till we reach to the location 1. So, we have to take care of one variable and we are going to you know insert a loop here. So, one variable would be there suppose I am taking i and i is equal to n, i would be at this place."}
{"text": " at this place only. So, after inserting this 5 here at last what we have done we have computed parent value of this 5 and why parent value because we have to compare this value with its parent is it still satisfying the max-c property or not is parent is greater than this inserted node or not fine. So, what we have done? So, suppose we are going to calculate parent"}
{"text": " Now parent how parent is to be calculated I divided by 2. So now how parent is to be calculated I divided by 2 it's and it's floor value. So I simply just write down the that symbol. Okay, but when you are going to code this thing, then you will write that floor function. Okay. Now, next is after calculating parent value, you will compare this with parent. So now you will compare if if array name is a."}
{"text": " a of this parent so now this parent value parent value a of parent i divided by 2 means i means here 11 11 by 2 floor value that is 5 so in parent we have 5 so we will check a of 5 a of 5 is 50 it means 50 so here 50 is less than a of i."}
{"text": " i is at this place. Fine? So is 50 less than 5? No. Fine? If it would be less than 5 then what we will do? We will swap these elements like we have done when we were inserting 60. Fine? So if this parent is less than the inserted node then we will do what? Swapping. So swap"}
{"text": " a of parent and a of i and after swapping after swapping what we will do we will move this i also fine and that i would be at the place of parent now so i is equal to"}
{"text": " Now that i, i pointer would be moved, i value would be moved and that parent value would be at, would be stored in i. Why so? Because again we are going to check with its parent, with parent till we reach to the root, till we reach to the location 1, till we reach i is equal to 1. So if this thing, thing is true then swapping would be done. Else, else we will do what?"}
{"text": " See, we are going to continue this process until what?"}
{"text": " we reach to this place. When this i variable reach to the place 1 it means this is the root node. Root node is don't having any parent node so that is why we are not going to find parent node and you have to stop this thing to find out parent and this comparing of parent and that inserted element and then swapping and all fine. So you have to put this thing in a loop and that loop would be while"}
{"text": " i is greater than 1. In that case only if i is greater than 1 it means this process would be repeated and when i reach to 1 it means we have reached to the root node. So, you have to stop this thing. So, because root is don't having any parent no need to calculate parent."}
{"text": " So, now this is if this is your else and this is your while loop. So, this is how we are going to implement this insert operation in the max heap."}
{"text": " fine. Simply you have to modify a little bit and you can write down how to insert you can write down insert heap function for a min heap. This condition would be changed in that case. See this is I am not saying that this is the exact code and there would be no error. Obviously, there would be some error, but this is how this is the main logic this is how we are going to implement this thing ok. Now, we will see how the data is to be deleted from max heap."}
{"text": " So, in this case it is not like that you can delete any data like 16 you can delete this 16 no you can only delete the root node that is the condition that is the rule fine. So, here what you can delete is if you want to implement a delete operation in this maxi then the only way is you can delete this 50 first of all fine. So, suppose you have deleted this 50."}
{"text": " Now at the place of 50, this place is empty now. What you will do? Which data, which data is to be here? So the last element, the last element or you can say the last element in the array would be"}
{"text": " shifted to the root node because we have deleted this root node so the last in the tree you can see the last data is what 10 in the array also you can see the last is what 10 so here what you will do this 10 10 would be deleted from here and 10 would be inserted at the place of root now this is a heap"}
{"text": " So in this case also we have deleted this 10 from here and we have inserted 10 here only. Here is now 10. Now heap is up to this point n minus 1. At starting n is what 9 now n is what after 1 deletion n is what 8. So heap is now till n minus 1."}
{"text": " one size has been reduced now see now you have to check after deletion is it still satisfying the maxi property it is not like that you have deleted 50 and you are done with the deletion no you have to check this is satisfying maxi property or not how you will check now we have we have we have shifted the last node to the root node now you have to check you have to compare this root node with its child"}
{"text": " because the parent node would always be either greater than or equal to its child node. Now compare. It is having two child. One is 45 and one is 35. Which one is greater? 45 is greater. Now compare this 45 with this root node, parent node."}
{"text": " 45 is greater than this parent node then obviously shifting would be done now shifting would be done 45 would go up and 10 would go down right so here now you will write 10 and here you will write what 45."}
{"text": " This is not done now. This is not done now. This process will be continued till we reach to the last level. Fine? Now again, 10 would be compared with its child. Child node are two. One is this one, one is this one. Now compare these childs. Which one is larger? 33 is the larger one. So now I compare this 33 with this 10."}
{"text": " Obviously 10 is less than 33 but the parent should be greater than or equal to its child node. So we have to do swapping like this. Now 10 would go down and 33 would go up."}
{"text": " still we have one child left now calculate child is there yes one child is there another is not there now compare with this one this parent node is less than its child node then swapping would be done in make sheep so now 12 would go up and 10 would go"}
{"text": " Now, 12 is here and 10 is at this place. Now, this is the tree. Now, this is satisfying the maxi property. So, this is how you are going to delete. Now, if you implement this here only, then how you will implement in this array? See, here we have 10. In deletion, you are going to adjust the tree from top to down. And when we were inserting in that case, we were adjusting the tree from"}
{"text": " here bottom to top right so now 10 10 is there now find out the child node of this 10 because we are going to compare this 10 with its children fine now left child would be at 2 into i that is 2 into 1 at second index and right child would be at 2 into i plus 1 that is"}
{"text": " at third second and third means 45 is left child and 35 is right child when you are you are you are considering only this array so in the tree also 45 was the left child and 35 was the right child now compare these two childs which one is larger 45 is larger now we compare this 45 with this 10"}
{"text": " Now 10 is less than 45 now we are going to swap now we will do what swapping now 10 would go here and 45 would go here."}
{"text": " Now updated array is here we have 10 and here we have 45. Now again 10 is here but we are not done. We will still calculate the left child of this 10 and right child of this 10 until we have reached up to this n."}
{"text": " When you find out the left child is greater than this 8 and right child is also greater than this 8th index then you are going to stop. Fine because obviously after 8 we are not having any node. So now see now i value is equal to"}
{"text": " 2 now so left child would be at 2 into 2 that is 4 and right child would be 2 into 2 plus 1 that is at 5 4 and 5 means 33 and 16 now out of these which one is larger that is 33 now compare 33 with this 10"}
{"text": " 10 is parent and 33 is its child. So parent cannot be less than child in max-heap. Now you have to swap these two. Now at the place of 33 we will write 10 and at the place of 10 you will write what? 33. Now here we have 10. Now i value is 4 now. Now again calculate left child of this and right child of this. So left child would be at"}
{"text": " 4 into 2 into i that is 2 into 4 at index 8 and right child would be 2 into 4 plus 1 that is at 9."}
{"text": " So find out at 8 yes, 9 we don't have any 9th index. We don't have any value in this 9th index. So this is we are not going to compare this right child. We are going to just compare this left child. Now compare this 10 with this index the value having at index 8 with its left child. 10 is less than its child. So you are going to swap this thing. So here we will write 10 and here you will write what 12."}
{"text": " this is what we have done in this tree. So, after doing this updation the array would be something like this."}
{"text": " This is how we are going to delete and see here we have one space left at 9th we have 8 here we have 7, 6, 5, 4, 3, 2 and 1 and the deleted item was 50 right. So what you can do you can simply do what you can put 50 at this place you can use this space."}
{"text": " see although the heap is from 1 to 8 but this space is free in an array so you can the deleted element can be put here only now see next next deletion check next deleted element would be 45 because we can only delete data from the root node fine now see suppose 45 has been deleted now what now 45 has been deleted 45 next element is 45"}
{"text": " what after deletion what you will do you will replace this you will put here the last element in this tree last element is 10 or you can see in the array last element is 10 so now you are going to put this 10 at this place and now now heap is till 1 to 7 and this space is free fine now here you will write what 10 and we are going to delete this from this"}
{"text": " pray."}
{"text": " but now this is not the deletion now you have to hipify this again you have to check it is satisfying the max-heap property or not now 10 is here calculate its child node child node are 33 and 35 which one is greater 35 is greater out of these node now 35 would be compared with its parent that is 10 so now 10 is less than 35 that is not possible in max-heap so you are going to swap this thing so here you will write 35 and here you will write"}
{"text": " Now again calculate its left and right child. 25 is left, 34 is right. Compare these two. Which one is greater? 34 is greater. Now compare 34 with this 10. 10 is less than 34. That is not possible. Now you have to swap this thing. Here you will write 34 and here you will write"}
{"text": " 10 this is the mix heap after deletion of 45 so same you can do with this array like we have done in this case find out the left and right child of this one i is equal to 1 so left side left side would be 2 into i that is 2 right would be 2 into i plus 1 that is at 3"}
{"text": " now 33 and 35 which one is larger 35 compare 35 with this 10 so obviously 10 is less than 35 so parent cannot be less than child so we are going to swap this thing here you will write 10 and here you will write 35 again 10 is at this place again find out its left child 2 into i that is at 6th index and 2 into i plus 1 right would be at 7th index so these two would be child of children of this 10 which one is greater 34 is greater 34 is compared with this 10 so"}
{"text": " 10 is less than 34 that is not possible in maxi parent should be greater than or equal to its child node so now you are going to swap here you will write what 34 and here you will write what 10 now again 10 is here now again calculate its left child left child would be 2 into i 7 into 2 that is 14 but we are not having any 14th index so now we are going to stop this"}
{"text": " fine. So now after after this arrangement the array would be something like this 50 is there and next we have deleted element is 45. So we can store 45 here because this is free space."}
{"text": " Next element can be deleted as 35. So again we will do what 35 would go there and 10 would go here. Now here I think you are analyzing that the largest element is at this position. Now the second largest element again would be the third largest element would be at this place and when you deleted all the elements then this array would be in sorted order."}
{"text": " I hope you are getting this concept, fine. So this is the basic, this is the base idea of heap sort. If you are going to sort the data in ascending order, then just build a max heap"}
{"text": " delete one by one elements from the mix heap and after deletion or after deleting of all the elements you can find out that your data is has been arranged in ascending order and if you want to sort the data in descending order then just use"}
{"text": " min heap because the root element in min heap is the minimum element and obviously deletion would be from the root element. So, that is why first element would be deleted the root element. So, root element would be here only. So, the minimum element would be here only then the next minimum then the next minimum and the largest element would be at here only. So, data would be at that time in descending order."}
{"text": " So this is the idea of heap sort. In next video I am going to discuss with you heap sort. We are going to take one array, we are going to construct a heap, first of all max heap, then we are going to delete one by one data from that max heap and ultimately you see that the data is sorted in ascending order, fine. And also we will discuss what is that heapify method. So I will see you in the next video, till then bye bye, take care."}
{"text": " All right. Hello, everybody. Welcome to Fun Wednesdays. So today, we're talking about file systems. Fun. So everyone's kind of familiar with this, at least on Linux or Unix or anything besides Windows."}
{"text": " So the usual POSIX file system looks something like this. It's part of the FSH, so there's actually a hierarchy standard. That's what that stands for. So it's actually defined, some directories are actually defined as they should exist on a normal Unix system. So there's slash."}
{"text": " which is the special root directory, which everything has to start with. And we'll have a lab, so you really understand that the root directory is a bit of a special case. And there's really no magic aside from that, aside from a magic number, which we're kinda getting used to."}
{"text": " And then in root, there should be a few directories. So there should be a bin directory. That's all your binaries or executables. That on Linux should be ELF files. There's a dev directory, which should represent all your devices. An ETC, which should have configuration files. Home directory, which should be individual for each users. And in that example, there would be one for myself."}
{"text": " and that's where you would put all your files in. And then there might be a mount directory, something where you mount other devices that you plug into your system, like a USB stick or something like that. So usually there's a concept of a working directory, which is the directory you're currently in. So if you do any relative paths, which everyone's probably done before, they're relative to the current working directory."}
{"text": " So there is an absolute and relative path. Relative path is relative to the current working directory. And an absolute path will start with root. So if I'm trying to describe this todo.txt, well, if I'm currently in this John directory,"}
{"text": " I might be able to say, hey, the relative path is dot. Has anyone ever saw dot entries before, or dot, dot, or used dot, or dot, dot? You got thumbs up, so we'll go over that and see what they actually mean. But for this, the relative path for todo would be dot saying current directory, which is John. There's a file called todo.txt in it."}
{"text": " And then if we did an absolute path, it'd be slash home slash john slash todo.txt. So basically, how do I find that todo.txt starting at the root directory? And then similarly for USB, well, if you did the relative one, you would have to start at john. And if that's your working directory, you'd do dot dot to get to home."}
{"text": " which would be up one directory, then dot dot to get to root, then mount USB. So the relative path would be dot dot slash, dot dot slash, mount USB, and then the absolute path would be root, mount USB, and that's it."}
{"text": " So here's the answers to that. Hopefully that is not terribly surprising. The only things is there's some special symbols here. There is dot, which means the current directory, and then dot dot, which means the parent directory, so whatever you live in. And then there's the tilde sign, if you haven't seen that before, but I'm guessing you have. And it means it's the user's home directory, so where they should store all their files."}
{"text": " And then all the relative paths are calculated from the current working directory. If you want to get the current working directory from your shell, you can print out that variable, like echo $PWD, and that will tell you what directory you're currently in. Or you can just type the command PWD, which essentially will read that for you."}
{"text": " So any questions about that? Hopefully straightforward. So here's a fun little history lesson. So you know on Linux systems, if you start a file with a dot, it's like a hidden file."}
{"text": " kind of a hidden file where you don't really see it. Well, that was actually a big old mistake of someone trying to be way too efficient and too clever for their own good. So within a directory, there's going to be an entry for dot and dot dot and whatever ULS. Typically, you don't want to see those. So you would want to hide dot and dot dot."}
{"text": " But some tricky developer was like, well, that's two cases. That's silly. I can cover this in one if statement. So if it starts with a dot, I just won't show it. And then suddenly, if your file began with a dot, you wouldn't see it when you typed ls. And then they just made that into a feature. So that's the history behind that. That's why that works, just because someone wanted to cover two cases and wanted to do it with a single if statement. So that's the history of that. That's a fun little thing."}
{"text": " So when we access our files, we'll either access them sequentially or randomly, and this kind of ties into the whole memory thing. So if you read a file sequentially, well, that's what we've usually been doing if we open a file and we read it. So whenever you use a system called read, it advances the position inside the file internally, and we'll see what that looks like a bit today."}
{"text": " And then next time you call read, it just continues from where it left off. And consequently, if you went and did writes instead of reads, well, if you did multiple write calls, it would just keep appending to the end, so it would kind of shift that position forward and forward and forward. So if I did a write system call that said hello, and then another one that said there, I would see hello there all in a row, and I wouldn't be overwriting things."}
{"text": " So that's usually how you deal with file descriptors and write to files and things like that. But you don't have to. You can randomly access any byte you want in a file. You can read and write them in any order. You can overwrite them. You can do whatever. And for that, you would need a specific position where you want to read a byte from or where you want to write a byte to."}
{"text": " So we've already seen the open system call. So that will take essentially a path name that could be absolute or relative. Some flags that would be like read write. So that's what O read write is, write only, read write. Also, there's a flag called O append that will make that position go to the end of the file. So if I just want to write to the end of the file, you add O append to the flags. And then whenever you do a write system call,"}
{"text": " it will just be appended to the end of the file. So what we haven't seen yet is this lseq system call. And that system call will actually change that internal position for that file descriptor. So you have to give it a file descriptor, that lseq. You have to give it a file descriptor as the first argument. So that's what I want to change internally."}
{"text": " And then the second argument is an offset, which is how many bytes do I want to go? And then it's relative from the last argument there. So it's an int once, but it can only be one of three values. So it's just like a really crappy enum because this is C and we can't do anything better than that."}
{"text": " So whence can be either set, seekSec, seekCurrent, or seekEnd, and that's where that offset is relative to. So if you do seekSet and then give it an offset of, say, 10, that's relative to the beginning of the file. So that means I want to read the 10th byte."}
{"text": " or move the position to the 10th byte, so whatever I read and write, it goes to the 10th byte. And then if you do current, that is a relative position to wherever the pointer currently is."}
{"text": " as you would probably guess, the end is relative to the end of that file. So if I want to read, I don't know, the second last byte, I could say lseek relative to seek end and then minus two. So I want to come two bytes back and then I can go ahead and read or write whatever byte I want from there."}
{"text": " So it's good to know of this because it will actually cause us problems with the friends we already know, like fork. So we already saw how to do this, accessing a directory. So there's opendir, readdir, and closedir."}
{"text": " And it works like this. This actually does not translate exactly to a system call. And there's actually a specific format for this. So we'll actually see this in the last lab of the course."}
{"text": " But this is what it actually looks like in a process. So each process in its process control block has a file table. And they're just stored there. And the file descriptors are basically just an index into this table."}
{"text": " So I kind of alluded before that, hey, file descriptors are just a pointer. So these are the things that they actually point to. So this would have two processes, process 1 and process 2. And it would have three file descriptors that are just represented by their index. And then they each point to an individual file. And there are three components to a file."}
{"text": " There is a position, so where that internal position is to read or write from for the next byte. There's flags, which would be all the permissions, so read, write."}
{"text": " da, da, da, what you actually can do with the file. And then there is another layer of indirection here. There's a pointer to a vnode. And a vnode is just supposed to represent anything it can read and write bytes to. So a file would be an example of a vnode or your pipe, for example. So that's what it would look like. So in this,"}
{"text": " diagram process one, file descriptor zero points to this. So it would have a position flags, which are independent because they point to that entry, and then they point to file A, and then file descriptor one has its own position, own flags, and then points to file B. And then in process two here, file descriptor zero points to its own entry, which would have its own position, which is independent of process one."}
{"text": " It would have its own flags, and the VNode would also go to that same file. So both of these processes could have that same file open for different purposes. Process 1 could have it open for writing. Process 2 could have it open for reading."}
{"text": " And that is stored in the individual entry. But when you're actually reading and writing bytes to it, you don't really care. It's just a file. And as long as it has the correct flag set for permissions, then it can go ahead and do that operation. So any questions about this? Because this actually makes our lives more difficult."}
{"text": " So each process has this file table and its process control block. Again, like I said, the file descriptor is just an index to this table, but it's a bit more complicated than that. So each item actually points to a system-wide global open file table, or you can call it a Goff table if you really want, a bit of a silly name, but there's just a big global table."}
{"text": " And that's where all the information about the position and flags are stored, and when it points to vnode, and again, vnode, anything that can support a read or write. So that could represent a pipe, network socket, we'll see network sockets, regular files, whatever you want."}
{"text": " So remember what happens when you fork. So the process control block is copied on the fork. And specifically for us, there is a local file descriptor table. And that would also get copied on a fork. So both process control blocks would point to a global open file table entry."}
{"text": " And they would actually point to the same entry. So they would share information, which can cause you some issues. So this is what would happen. So we say we have, again, process control block 1, process control block 2."}
{"text": " And then they're pointing to the same global open file table entry. So this is global. It is managed by the kernel and not independent of each process. So this is what it would look like after a fork. So they would, oh, sorry, yep. Yeah, so this is, so if you call dupe2, it essentially replaces whatever that entry points to."}
{"text": " So yeah, so like in here, if we had, you know, what we had in the lab is we set up a pipe. So it would have like file descriptor three points to a global open entry that represents the pipe. And then when you do two, you're essentially just making file descriptor one or whatever point to that same entry, and then you can close that entry."}
{"text": " So this is what it would look like after a fork. And you can notice something possibly bad here where they're sharing some information. So if they are sharing a position and one process calls read,"}
{"text": " well, it's going to advance that position in both processes. So for example, if you tried to read a file and you had to try and read that same file after a fork in both processes, well, because they share that position,"}
{"text": " One process is going to read some parts of the file, and then the other process may read nothing or just a mutually exclusive part of that file. So one might read the first half, one might read the second half, or one might read the entire file, one reads nothing, because they actually share that entry there, which sometimes is not what you expect."}
{"text": " So yeah, that's one of the gotchas. So that current position is actually shared for both processes because it points to that same global entry. And that's all it points to. So in addition, besides reading and writing, which would change that position for you,"}
{"text": " One process could also do an lseq system call, and that changes the position for both processes, because both processes are pointing to the same entry. If one process changes that position, and the other process is still pointing to it, well, guess what? It's now using that same position. So one process can actually affect the other one through file descriptors, which may not be something you expect."}
{"text": " But however, if you don't want this, if you open the same file in both processes after forking, they both create their own independent global open file table. The only way you can share global file table entries is just by forking. That's it. You can play with your file descriptors so they look the same. But by default, the only way you can share stuff is actually through forking."}
{"text": " So let's say we have this as our main. So in our main, we open todo.txt, say it's read-only, and then we fork, and then we open b.txt, it's read-only. We assume there's no open files, not even the standard ones. So what would I expect to happen, and what would all their relationships be? So I'll give you a sec to do that, and then we can go over it."}
{"text": " Oh, true."}
{"text": " Okay, any guesses as to what will actually happen here? Yep. Yep, yep, so what's gonna happen here, say I'm running along,"}
{"text": " Process ID 2 is going and executing this main. When it opens, assume nothing else is open. So it would return a new file descriptor. So if there's nothing open, it gets the lowest number, kind of like your thread lab. So todo.txt would be open in process 2's file table. There would be an entry for 0. And then it would point to something in this global open file table. And it would have its own position."}
{"text": " It would have its own flags, and then it would have its own vnode. And then that points to some actual file called todo.txt. And then you go along, you do the fork, so the new process."}
{"text": " is an exact clone of the parent at the time of the fork. So it would copy that open file table. So in process three,"}
{"text": " it would have an entry for zero that actually points, whoops, that actually points to that exact same entry. So now they're sharing a position. So now if the child did a read system call or something like that and read the first four bytes, well, now the parent can't read the first four bytes without resetting the position and all that stuff."}
{"text": " And then afterwards, you don't know what process is going to execute, and they both do an open independently of each other. Whatever you do in open, it creates a new global entry in the table. So say process two runs first, it would create a new file descriptor one, which would point to a new entry in the global open file table."}
{"text": " It would have its own position, it would have its own flags, and it would have its own vnode. And then that would point to b.txt. And then in process two, it would do open, create a new entry in its local file table that points to a new global entry."}
{"text": " So it would point to this one, which would have its own position, its own flags. And then that vnode would point to the same b.txt because it's actually the same file. Yep? Why is it done with global sub-integers? Is that allowed?"}
{"text": " Yeah, so that's just to make it easy to share. So whenever you fork, they're just all shared by default because they're essentially just pointing to something. Yeah? What does LOF stand for? I don't think you'd be able to remember that. Sorry? LOF. Oh, sorry. Yeah, so LOF is the local open file table. So that's just the file descriptors pointing to global entries. Sorry. Yeah, so any other questions about this example?"}
{"text": " So again, here's a nicer picture of what it would look like. So the parent, two file descriptors. So it has two local entries. It's basically just the size of its file descriptor table. An LOF is a local open file table."}
{"text": " and they just point to global entries. So the parent would have two, and the child would also have two. Both their file descriptor zeros are pointing to the same thing, because that was done before the fork, so it would have been copied. And then after that, they both open the same file. So they would both have their own global entries that are independent of each other, but they're actually pointing to the same underlying file. Yep."}
{"text": " Oh, so this in the middle is the global open file table. And then this in each process, that's the local file table for each process. Yep."}
{"text": " Yeah, the local open file table is just a number and then points to the global file table. Yep. I thought 0, 1, and 2 are taken for the standard. Yeah, so 0, 1, and 2 are usually taken. But I said here, assume there's no previously open files, not even the standard ones. So this would be a bit weird. But usually, 0, 1, and 2 would be taken. So it'd be the same thing. I just didn't want to write three extra things here. Yep."}
{"text": " Yep, yep, the lseq position is the same, changing that position variable there, which is which byte to read in the file, yep."}
{"text": " Yeah, so the standard ones would point to the same global open file table as whatever the parent that made them. So usually if you look at that proc file system, which we know how to do now, and look at the standard file descriptors, they all point to the same thing in pretty much every process."}
{"text": " Okay, yeah, and this is also why they share and you have a standard input. Why, if you share that over multiple processes, well, only one process is gonna read anything you type from the keyboard because they all share that position. So essentially, the active one would read it and then the other ones can't read it. So that's why your standard in only gets read by one process and not everything in the tree."}
{"text": " Okay, so now talking about how we actually store files on your file system. So we saw SSDs yesterday. We saw that they contain pages, which are basically just fixed size blocks of memory. So if we want to store a file, well, we would store them also in pages. So one way to store them would be like contiguous allocation. So say I have a green file that would span like three pages. Well, I could just"}
{"text": " allocate it somewhere on that SSD. And then to describe where that file is, I can tell you what page it starts with and how many pages it has. That would be contiguous allocation. I don't have to tell you much about it. Then for the red file, I can tell you where it starts, tell you it has six pages. And then for the blue file, I tell you where it starts, tell you it has four pages."}
{"text": " So, is this a good idea for your file system? So, yep."}
{"text": " Yeah, so if I get rid of something, it might leave a weird-sized gap that I can't fill. In addition, it's a bit better because I'm using pages, so I'm going to have page-sized gaps, but there might not be enough pages to fill something. But also, typically, you make files bigger and smaller. So what would happen if I wanted to make that red file bigger? Yeah, well, I could, but what would I have to do?"}
{"text": " Yeah, so I couldn't make it bigger, because it would overrun into the blue. And then I can't say it's like 7 now, because it's wherever blue is. So I could just take it, move it here, and then copy all those pages, copy all the contents of that file, and then just stick the new block at the end of that, because now I have room for it."}
{"text": " Or I could have moved the blue file down, copied all of it, and then just made space for the red. But typically, this is pretty bad, pretty wasteful. And we've kind of already solved this problem when we had memory, right? So memory was also in pages exactly like this. What did we do for memory? Yeah."}
{"text": " Yes, we did do multi-level page tables, but even without doing multi-level page tables, we just made different mappings, right? Yeah."}
{"text": " Yeah, well, or we could use a free list, that's another option. So both are valid options. We'll get to yours later, so let's start with yours. So first, okay, yeah, Contiguous is really fast as long as there's no modifications. Really space efficient, because if I was to describe a file to you, again, all I have to say is what page or block it starts at and how many blocks it takes up and its size. So it's really fast to access"}
{"text": " any block in a file because you can figure out what block it's supposed to be in. So if I said, for example, this is a long-winded way of saying, assume the block size is that four kilobyte page. Well, if I want to write or if I want to read byte"}
{"text": " 5,000, well, I know it's on block two for that file, so I can just go over one and read it. I don't have to traverse through every other block or read anything. I can directly look it up, because it's essentially like an array lookup."}
{"text": " But files can't grow easily. There's internal fragmentation. So remember, we kind of talked about fragmentation, where it's essentially just wasted space. And for all of this, since the file system only cares about blocks and pages, and they're all the same fixed size, we don't have to worry about any external fragmentation when files are deleted or truncated, because all our blocks are the same size. So one's just as good as the other."}
{"text": " But we're going to have some internal fragmentation where, hey, if I have a file that's only 10 bytes and a block is 4,000 bytes, well, essentially, most of those bytes are going to be wasted. But that's just what file systems do. That's the trade-off they have. Every file system is going to have that trade-off where they only deal with blocks and they don't care about individual bytes."}
{"text": " So here's our linked list idea, where we could just store a linked list of pages. So this is called linked allocation, and if you were to do this, well, you actually have to store the pointer on the block itself. So for example, if a file started here at block zero, well, it needs a pointer to point to the next block, and then that block points to the next block, which points to the next block, points to the next block, points to the next block."}
{"text": " And eventually, that block will have a null pointer to say, hey, that's the end of the file. It's essentially just a linked list, but it's just distributed over blocks. So what you do here is you give up a little bit of space in the block to store the pointer. So instead of using 4,096 bytes to store data, say I use 8 bytes for a pointer. So I just lose 8 bytes in my block, but that's something you can live with."}
{"text": " Now, files can grow and shrink quite easily, because it's that same idea as memory or the file system. One page is as good as the next. So if I want to make this file bigger by a block, I can just go to the end here."}
{"text": " and then grab a new unused page and then point to that page and say, that's the next block, and I make my file bigger. And it doesn't care. They don't have to be contiguous or anything like that. I can just do that. So now we can grow and shrink them as we want. It's still that same thing with external fragmentation, internal fragmentation. That's just a trade-off we'll make."}
{"text": " But this is a bit slow. So if we want to access, say, block four, I have to read this block."}
{"text": " access the pointer on this block, and typically you assume that things are nice and cached on blocks, but to get to the next pointer, I have to go to a new block, which won't be cached because it's really far away, read a pointer there, now next block, not gonna be cached, too far away, read a pointer there, oh, that sucks, it's too far away, and I have to read it, I'm not gonna be able to use a cache, it's gonna be really, really slow."}
{"text": " So can you think of a better way to speed that up and to get those pointers closer together? Yep."}
{"text": " So yeah, so the idea was to keep all the pointers in the first block, or alternatively, you can just keep all the pointers separately to describe that block. So essentially, you just have a bunch of pointers all in a row that are all right next to each other. So you just have like an array of pointers."}
{"text": " And then if you need to walk through the blocks, well, they're not far away anymore. It will hopefully be within that page. Maybe it takes other pages depending on how big the file is, but you can just walk through the blocks. They'll all be relatively close together and hopefully it will be faster."}
{"text": " So that's exactly what a file allocation table is. The file allocation table is just a list of pointers. And it just makes all the pointers right next to each other. So instead of storing the pointers on the blocks themselves, the blocks are now free. And you have this separate table that has an index for every block. And you can point to them. So at index 0."}
{"text": " It would point to block 6, block 6 would point to 2, 2 would point to 13, 13 points to 9, 9 points to 18, and we're done. So this is the first file system that's actually used. So how many have heard of something called FAT32 or something like that?"}
{"text": " So that's what this is. So FAT32 means it's a file allocation table. 32 means the pointers are 32 bits in size. So your pointers are four bytes. So this is an actual one that's actually used. And everyone, if you're using a Windows computer, you are using this because your boot drive has to be formatted this way. So that's what FAT32 is, and it's the first useful one."}
{"text": " So essentially it's linked allocation, but we put all the pointers together so it's not as wasteful. We can use the whole block and everything is nice and closer together. So it's got faster random access. So if the file allocation table can be held in memory or cached, well, computers are really good at accessing values that are close together. So hopefully it's really, really fast, but the bad thing is"}
{"text": " Each file needs to have a file allocation table, and the size of the file allocation table is proportional to the size of the disk, because it has to be able to point to any single block on the disk."}
{"text": " The bigger your disk is, the bigger the file allocation table has to be, and that's per individual file. So it gets really out of control really fast, which is why people don't use them for anything that is like gigabytes of size or something like that. It's just too crappy and you waste way too much space. So can we think of a better idea than a file allocation table, even though it's actually something that's used?"}
{"text": " So we heard multilevel page tables, right? So would the multilevel page table idea work for this? Or what about something simpler? So at the end of the day, oh, yeah? Distributed?"}
{"text": " Whoops. OK, so kind of like multilevel-ish. So at the end of the day, for multilevel or even single level, what does it do?"}
{"text": " So essentially, it takes a virtual address and looks it up, turns it into a physical one. So if you want it to be really, really fast for files and do that, well, essentially, that's just like a table lookup. You could do the same thing. So what about just an array of pointers and entry 0 points to block 0 for that file?"}
{"text": " Entry 1 points to block 1. Entry 2 points to block 2. So you just make an array of pointers that aren't this crazy thing, but the first pointer points to the first block, or the 0th block, da-da-da-da-da. They all point to the next block. You essentially just turn it into an array."}
{"text": " So that's what indexed allocation is. So indexed allocation is just an array of blocks for an individual file. So they just point to that. So if I have a file, you essentially just give it an array. And if I want to look up block four, well, it's like looking up element four in an array. That's really, really easy. I know exactly what byte to go to. So if I want to see what byte four is, well,"}
{"text": " I have block four and it points to this block. So block four of my file is that block on the hard drive. So does that make sense to everyone?"}
{"text": " So the idea for multi-level page tables here is this red block here. So in order to store all the indexes, you store all the indexes on a page. And then to describe a file, you say, oh, where is its array, pretty much? So its array would live in a block, and that block just has a bunch of pointers."}
{"text": " for that file. So it would, yeah, so it just, same idea as kind of multi-level page tables of just fitting pointers on a block. And this is kind of the idea of a single-level multi, single-level page table, yep."}
{"text": " Yeah, so the question is, what happens if I want to grow the file? So in this case, say my page size is 4 kilobytes, I can fit like 1,000 blocks. I can grow my file up to 1,000 by just adding more pointers, right?"}
{"text": " The problem is, is when I run out of space on that block, and then that becomes the multi-level page table idea. Whoops. So we'll get to that next lecture. But essentially, when we run out, we'll pretty much use the multi-level page table idea. So, yep? So then for the fat before, in this one, where is the fat?"}
{"text": " So those two columns would be stored on the drive as well, but the size of them depends on how big the hard drive is. So I can't draw them because I have no idea how big they would be. So whenever you format a drive, it would figure out how big it needs to be and make it the right size. Yep."}
{"text": " Yeah, so to describe a file in this case, I would say, hey, this file, its index block is at page red. So if you want to figure out any block that makes up the file, start at page red and use it as an array."}
{"text": " Just one file. Yeah, so the red block here is just essentially that array of pointers for one individual file. So if I was to describe the file to you as part of the file system, I would say, hey, if you want to read todo.txt, all of its indexes are the red block. So go read the red block. Yep? So why is this one not linear to this?"}
{"text": " Yeah, so this one's not linear to disk size, but it's only using one block, so it's gonna have some limitations here. So my file can only be a certain size, so it was like the point that was brought before. As soon as I run out of pointers that fit on the block, I can't make the file any bigger anymore. So it's not necessarily better because it's limited in this regard. Yeah, so we'll work out. So yeah, so talking about its limits,"}
{"text": " So it can shrink and grow. We still have the same fragmentation things. Fast random access time because it's essentially an array. But now we're at a limitation where the file size is limited by the maximum size that can fit in a block, right? Our index block just lives on a block. So."}
{"text": " Let's see. So let's see how big of a file it could actually support. So in this example, we'll say that our index block stores a bunch of pointers to data blocks, so there's no other information. It's just literally pointing to a block that has its own index."}
{"text": " And then we'll say that the size of a block on a disk is eight kilobytes, so it's a bit bigger, and then a pointer to a block is four bytes. So the question is, what's the maximum size of file that can be managed by this index block? So I'll give you two seconds to think, or a little bit to think about that. Oops."}
{"text": " All right, how big can my file be? Yeah. 2,000."}
{"text": " How big is 2,000 pointers in actual megabytes or something like that? Oh, it's not 8,000 KIB. Because you have a pointer to a block is 4 bytes. Yeah. A disk block is 8 KIB in size. Mm-hmm. Divide?"}
{"text": " Yeah, so you divide, but that's how many pointers you can fit on a block. And then each of those pointers points to a block that's eight kilobytes, so you multiply them together. Right here. Yeah, file, sorry. Another comment? No? Okay, so just really quick. It's like the same idea of page tables. So this is my block size if I write it in powers of two."}
{"text": " So it's 2 to the 13. And then if I want to answer how many pointers I can fit on a block, well, this is my pointer size. And then if I want to answer how many of them fit in a block, well, I just divide them. So how many pointers fit on a block? Well, that is, if we do our fun math, it's 2 to the 11. So this is number of pointers."}
{"text": " So if I only have one block that can represent my file, I can point up to 2 to the 11 things. And if I want to get the size of the file, oops. Well, I have 2 to the 11 pointers and each pointer points to a block. The block is 2 to the 13. So that's the maximum size of my file, which would be 2 to the 24."}
{"text": " And if I want to go ahead and change that into units, we can actually understand. That's the same as 2 to the 4 times 2 to the 20. And then that's 2 to the 4 megabytes, because it's powers of 2, and we're not trying to swindle you. And then 2 to the 4 is just 16. So the maximum size of a file for this would be 16 megabytes. So who here would be satisfied with that?"}
{"text": " We got one. So someone that doesn't care about movies or animated GIFs or anything like that. So that's a good idea. So far, we've had a good idea. And here's the calculation, just so you have it. So so far, that was a good idea. But it's not quite practical, maybe enough for some text files. But we have to do a bit better than that."}
{"text": " And we'll do a bit better than that tomorrow in the cursed room, unless we want to do lab 3 stuff. Yeah? So this still kind of does scale linearly, right, with the number of blocks? Because you have one pointer per block, and then you have, depending on the number of blocks, you have like a, it increases until it hits the maximum limit, right?"}
{"text": " Yeah, so for this, my file is represented by a block of indexes. But as soon as I run out of things I can fit on that block, that's it. So I have a limitation with the size of the file. But to describe my file, I just say, hey, where's its index block? That's it."}
{"text": " OK, so file systems, very good for persistence. It's the software layer on top of that, because for SSDs, you just get a bunch of blocks or pages, however you want to think of it. And it's up to the kernel to decide. So you need a file system on top of that to enable persistence. And file systems just describe how files are stored on disk."}
{"text": " The first and only one we've seen today that is actually usable is that fat or file allocation table. All the other ones are kind of a work in progress that we're working on. And we'll see the real thing either tomorrow or Wednesday."}
{"text": " But API-wise, we can open files, change the positions. It will actually use the file system under the hood to figure out what physical block on the hard drive it should point at. Then we saw each process has its own local open file table. And there is a global open file table, which is where, whenever you call open, actually creates entries for. And then as part of fork, it copies all those pointers there. So you're pointing to the same entry in the global open file table."}
{"text": " Then we saw some more interesting allocation strategies for the actual disk itself. So contiguous, which we argued doesn't work, linked, which we argued sucks, and then fat, which is just linked, but all the pointers are closer together, and people actually use that. And then we saw indexed, which isn't actually used, and we'll go over what's actually used instead of indexes, but you can probably guess."}
{"text": " It could have the same idea with multi-level page tables where we take a few hops and then we have a much larger space we can actually use. So with that, just remember, pulling for you, we're on this together."}
{"text": " Okay, good afternoon, that's kind of loud. Wow, okay, no, not that."}
{"text": " All right, good afternoon. So we're going to do a bit of review. This isn't new content, but we will solve a mystery. So everyone loves solving mysteries, and then we'll get into time. You can work on your lab. I can help you, and we can wrap that up. So memory mapping, we kind of touched on this a little bit. We kind of know the principles behind it, but we didn't actually explore actually useful things we can do."}
{"text": " So everyone loves large language models now, right? ChatGPT, everything like that. So there was this post on GitHub that got circulated around. So they have like a 30 billion parameter model that takes like 20 gigabytes. And there's one implementation of it that's like, oh my god, whenever I try to use the model, get some output out of it."}
{"text": " Well, my laptop doesn't actually use 20 gigabytes of RAM, which is the size of the model. It only uses 6.8. So how is that possible? So this is from Lama, sorry, Meta's large language model, or Facebook, Meta's stupid name. So it's supposed to be like this is an efficient implementation, and it's so efficient that people were just ultimately really, really confused."}
{"text": " So here's the post. So it's like, oh, this model only fits in this mail RAM. How is this even possible? So we will explore how this is possible. And you'll be able to answer the questions here better than anyone else has posted in the replies here. So just really quick."}
{"text": " So there's a system call that has kind of been used in the labs that we haven't actually explored. And we can actually control our own processes' virtual memory. We can't modify our own page tables directly. But we can ask the kernel nicely through a system call to change page tables for us. So that's what you do with an mmap system call. It's just short for memory map."}
{"text": " And you can actually use it to map files into your own processes virtual address space. So this makes it so that the pointer you get, which is your own virtual address, returns, it allows you to just access that file directly through memory addresses instead of doing like read and write system calls. So you don't have to do any system calls after the nmap, you just read and write memory and it actually reads and writes from the file."}
{"text": " So let's go ahead and see that example. So it's surprisingly small. And here's the whole example. So at main, we know how to open a file, I hope. So you have an open system call that, say, we're going to open this file. So this is just a C file. So it's just going to open itself. It's essentially going to cat itself. So it opens this file as read only. Of course, we get a file descriptor back."}
{"text": " We can probably guess what file descriptor number we'll get back, because 0, 1, 2 are all used. So we can just make sure that we get file descriptor 3 back, because we're just kind of flexing our OS knowledge here. And then there's this structure stat and an fstat system call."}
{"text": " And you kind of know what this does if you have been good and you've done lab 6. So this will get all the information about that file if that file descriptor is pointing to a file. So if you've done lab 6, you know that this will actually kind of read that inode and give you the fields from that inode. So one of the things we care about is the size of the file, because you have to tell mmap how many bytes I want to map in. Whoops, that's a big thing."}
{"text": " So after that, you can do mmap. So mmap takes like six arguments, but a lot of them don't have to be used or they're for permissions. So mmap takes the first argument where you can kind of suggest what virtual address you want if you're super picky about it."}
{"text": " If you want the default, you just say null. And then the next argument is the number of bytes you want to read. So we're going to make it match the size of the file. So that stat structure essentially just has all the fields that would be in an inode. It just works for file descriptors that aren't regular files. But in this case, this is just a regular file. So it would actually use an inode."}
{"text": " And then the next argument are the permissions. So for this, we'll say our memory map, we should just be able to read. We don't want to write because we're not going to try and modify the file. Then there's flags. So there's a private flag, which means you want that memory mapping to be private to you. This is how one of your test cases worked. So another option is to set it to shared. And that means whenever you fork, that virtual memory will be available in your child process as well."}
{"text": " So you can actually share memory through this, too, if you want. Next one is the file descriptor you want to map. So that is our mmap file that we specify. But in general, this can be any file you want to open. And then offset, which is just how many bytes to start mapping into that file. So if you set 0, it means I want to start reading at the beginning of the file."}
{"text": " All right, so any questions about that? We'll kind of explore it as we go on. So after that, we're done with our file descriptor. We can close it. We don't need it anymore. Our kernel is set up so that if we try and access through this pointer now, which is data, it's valid for length bytes, which is our size. And we can just read from it. Yeah? So the difference between this is normally we'd be using file descriptor to access"}
{"text": " Yeah, normally you'd be using a read and write system call, right? If you wanted to read from a file, you'd be using read. You'd have to set up a buffer, then transfers back and forth. And it's kind of a pain. So the main thing there is that you have to be doing a system call, which has to go to the OS. The OS has to go and check the required permissions and all that, or go to the right place. Whereas in this case, we're just going"}
{"text": " So in this, you're actually requesting. So normally, if you open a file, we have to read from it, right? So you read, and it copies the contents of that file into the buffer. And it would go on. If you call read again, it copies the next byte, so on and so forth. This doesn't copy anything. It says,"}
{"text": " Take this file, map it to my virtual memory there. So if I access that address, it actually accesses the file. So you don't have to copy. There's no buffer involved. If you access the address specified by data, that's the start of the file. So you can just read it directly. No system calls, no mess, no anything like that. So it's actually quite useful."}
{"text": " So that way, that data pointer we get back is to the beginning of the file. So we could just have a for loop. If we want to print every character in the file, we can just go ahead, for loop 0 to however many bytes we have. And we'll just print out that character. So data i. And that's all we do. And then if we unmap it, that means we're done. That's essentially its version of free. So if we run this now."}
{"text": " It should pretty much do what cat did before, except now I don't even have to do a read system call. So if I do that, it just spits out the contents of the file. Yeah? So you said it makes that point to refer to the file itself. Yep. Can you quantify the file itself? Yep."}
{"text": " Yeah, so you can kind of tell behind the hood if you've done the lab 6. So lab 6, all the contents of a file points to a block. So what the kernel would do is make that virtual page."}
{"text": " It would say, oh, this virtual page should actually map to this block in the file. So if you try and access that memory, you get a page fault, and it would actually fill in that memory contents with the block so they match. So it would load it into memory, does a whole bunch of steps for you, and it's actually quite awesome. So it saves you a lot of work."}
{"text": " OK, so why did I? So yeah, any questions about that and how it works? So I'll go over it real quick. So yeah, like six arguments, like I said. I probably don't have to go over this, but it's like suggested address, which generally you just say null, don't care. However many bytes to map, protection flags, mapping flags."}
{"text": " By default, this was originally set up that you map a file. But if you want to use this, because it's actually quite good at just allocating memory if you really want to or sharing memory, one of the flags is anonymous. So if you have an anonymous flag, that means the file descriptor doesn't have to be valid. It's actually not backed by a file. It's just some random shared memory or just random memory you could get. So you could do."}
{"text": " You could just ask for some pages, too, and you could do your own slab allocator or do whatever with it, too. So it's a very sweet thing to do. And it's also really lazy. So all it does is set up page tables, kind of like what I alluded for. It doesn't actually read from the file at the time of the mmap. So how it would work, we've done Lab 5. So it would create an invalid PTE entry with whatever address it decides to use."}
{"text": " Since it's invalid, it can use the rest of the bits in the PTE entry to be whatever the hell it wants. And one of the things it could be if we're mapping a file, well, you could store the information that says, oh, this page maps to this block of the file. And then if that process tries to access that memory, you'll, of course, get a page fault. And then you can do your copy-on-write thing like you did in Lab 5. But instead of that, page fault happens."}
{"text": " you read the page table entry and be like, oh, this is supposed to be this block of the file. And to resolve that page table or that page fault, you go ahead, read that in to memory, and then just set it as being valid now because it's actually been used. And you can return back to the program. The program can use it. And it would read it kind of on demand."}
{"text": " So only the first access to that page would be a page fault. Then the kernel loads from that file into memory. And then it works, right? And the nice thing about that, too, is if it's a gigantic file, like for that large language model, well, it only reads the part of the file that actually gets used."}
{"text": " So if I set up a 20 gigabyte file, I would have to set up all the page tables for that. But if I only used it, only use parts of it, then it would only load parts I actually access and I actually try and use."}
{"text": " So yeah, going back to the question then. So how does a 20 gigabyte file only use 6.5 gigs of memory? Well, for these large language models, they're gigantic. It's a 20 gigabyte model. But for any one question you ask it, well, it's"}
{"text": " really, really sparse and you're not going to use actually all the model. So there's some parts of the model that are dense that you do use, but a large portion of the model just is really sparse and you don't use it. So if you have this, let's go back."}
{"text": " So if you have this, you mmap the file, and then you use it. Well, it's only going to actually read into memory what's actually being used. And it turns out that, hey, it's actually quite good for this implementation. Go back."}
{"text": " So that was actually the solution that caused this whole thing, which you guys should be able to do now. So if you go there, it's like, oh, it doesn't do the impossible. So someone has taken an operating system course and knows it hasn't done the impossible. But it is using only 6 gigs of RAM."}
{"text": " Then let's see. So someone says there's some voodoo going on. And yeah, so here's someone that made it, which made the improvement. I'm glad you're happy. So the thing that makes this possible is now we're using mmap to load large models. That was the only thing they changed to bring the RAM usage down like 15 gigabytes."}
{"text": " So we can actually read this. This lets us read the weights without having to read them or even copy them, because it does that nmap thing. So if you just read the memory address, then you let the kernel handle it under the hood. So it says, the operating system, so clearly this person at least knows the stuff in this course, creates a page table entries which reserve 20 gigabytes of virtual memory address spaces. Crudely speaking,"}
{"text": " The mapping of 20 gigs of RAM requires 40 megabytes of page tables, this calculation. The individual page tables aren't actually loaded into memory, the resident blah, blah, blah. So this calculation, you guys should know, does this actually kind of look correct? Like what are the parts of this calculation that should be correct? Since this person kind of knows what they're talking to. Does that make sense?"}
{"text": " So I'll give you a hint. So the whole file is 20 gigabytes, so 20. And then here, this is just 2 to the 10 times 2 to the 10 times 2 to the 10 three times. So that just means gigabyte. So that means 20 gigabytes. Why would they divide it by 4,096?"}
{"text": " Cool. Page size. Yeah. So that's our page size. So that's how many pages 20 gigabytes would take. And why do we multiply by 8? Yeah."}
{"text": " Yeah, that's the size of the page table entry. So we need this 20 gigabytes is how much memory we're using. And they're divided up into pages. So each page is 496. And each page table entry takes 8 bytes. So this is how many, at minimum, we would need. And this is just to divide it to get megabytes."}
{"text": " So this is just 2 to the power of 10 times 2 to the power of 10, which is megabytes. So yeah, this is actually 40 megabytes. So can we improve on this? So instead of crudely speaking, can someone be more specific of exactly how much this takes? Because it's not quite right."}
{"text": " Yeah? No? Yeah? Are you supposed to consider multilevel page tables? Yeah. Yeah, this would be the real system's multilevel page table, right? So this number is how many L0 entries you would need, which is best case scenario. Yeah? So you need an integer multiple of that times that?"}
{"text": " So that's the number L0, so that's the top one, or the bottom one? Bottom. OK, so you just split that up into a bunch, right? Yeah, well, yeah. So we'd need to split it up into a bunch. Yeah, so we'd need to split up into how many L0s we need. And then from how many L0s we need, then we can figure out how many L1s we need."}
{"text": " And then once we figure out how many L1s we need, well, we're pretty much done, because we'll only have one L0 page table. So for a bit of fun, because we should be exact or, I guess, a bit sadistic."}
{"text": " Well, here's some calculations. So this is someone posting that you need this. Someone later in the post clarified because someone threw those numbers up. Of course, someone couldn't read them. But since we've taken this course, we can read them. So someone else said that, oh, you had to simplify it. It's 20 gigabytes divided by the 4k page size times 8 bytes per page table entry divided by 1 kb, which they had to typo because that's supposed to be megabyte."}
{"text": " And then we kind of argued that, oh, that's just for L0. So how much space do we actually need? So that's correct. So if we took, you know, we have 20 gigabytes. So this is 20 times 2 to the 3. So that's 20 gigabytes. And then if we divide by page size, so oops, that's supposed to be 2 to the 12, because that's our page size."}
{"text": " means, yeah, we do need 20 times 2 to the 18 page table entries. And from that, we can figure out how many L0 page tables we need. So we just take that number and divide it by 2 to the power of 9."}
{"text": " Why 2 to the power of 9? Because that is how many entries we can fit in a page table if it just fits on a page, right? That's the page size divided by the page table entry size. So this is also assuming best case scenario, where all of your entries are located beside each other, so they don't span over tables. Worst case is it would be super spread out, and you have different tables for each one. But we'll assume the best case scenario, where everything's located together."}
{"text": " So in this case, you need 10,240 full L1 page tables, which matches their 40 megabytes. So far, we should be good. And then we know that each L1 page table can point to 512 L2 page tables."}
{"text": " So we can figure out how many of those we need. So if we take however many entries, L0 entries we need, and divide it by 512, well, that's how many full L1 page tables we need. So we would need 20 full L1 page tables."}
{"text": " So in total, we would need 10,260, not 40, page tables. And if you divide that by, or yeah, if you multiply it by the page size and then divide by megabytes, actually, this is like that really nerd thing. Actually, we need 40.04 megabytes of memory, in the best case."}
{"text": " So why did I do that? I have no idea. I wanted to, and you guys should be able to. But it kind of makes sense, too, that if the L1 entry is full, well, it can point up to a gigabyte of pages, like it can span up to a gigabyte. So if we have 20 gigabytes that we need,"}
{"text": " Well, we could have 20 L1 page tables because each of them could actually translate a gigabyte of memory if we wanted to. Yeah? Yeah, this 8 here? Yeah, it's supposed to be in brackets there."}
{"text": " Oh, yeah. Or sorry, not in brackets, yeah. So it's supposed to be 20 gigabytes, divide this, and then just times 8 after that answer. Yeah. Yeah, if you just throw it into Python, it calculates correctly."}
{"text": " bed mass and all that. All right. So yeah. But this is kind of neat to know that, hey, if it's a full L1 table, that makes sense. That points up to a gigabyte. And my whole address space is 512 gigabytes. And in my L0 page table, I have 512 entries. So that kind of makes sense. All right. Cool. All right. We can finish lab 6, then, with the remaining time. Or just there's still chocolate. Eat it so I don't have to bring it home."}
{"text": " Yeah, that's it of me talking. You can work on lab 6, ask me questions, or whatever. I guess I can shut this off and go around, too. All right, just remember, pulling for you. We're all in this together."}
{"text": " In the last lecture, we have studied about storage structure under the basics of operating system. In this lecture, we will be studying about input-output structure, which also comes under the basics of operating system. So, as we studied about storage structure in the previous lecture,"}
{"text": " We see here that storage is only one of the many types of input-output devices within a computer. So, what are input-output devices? Input-output devices are the devices that are used for either giving input or getting output from your computer. And storage also is just one of the many types of input-output devices that we have. So, we see that input-output devices are something that is very important."}
{"text": " So, a large portion of operating system code is dedicated to managing I.O. both because of its importance to the reliability and performance of a system and because of the varying nature of the devices. So, as I told you since input-output devices and managing input-output is very important. So, when you code the operating system"}
{"text": " A very large portion of that code is dedicated for managing the input and output. Why is that? It is because of its importance to the reliability and performance of the system. The reliability and performance of a system"}
{"text": " greatly depends upon how its input and output are managed, and also because of the varying nature of the devices. We know that we have different input-output devices, and then all these input-output devices are very different in nature. So, since they are very different or varying in nature, and because it is very important for the reliability and performance of a system, a large portion of operating system code is dedicated for"}
{"text": " managing this input output. So, we see that a general purpose computer system consists of CPUs and multiple device controllers that are connected through a common bus. Now, this was something that we have studied when I started teaching about operating system. Let's just go back and look into it once more. So, here when we studied about computer system operation,"}
{"text": " We said that a general purpose computer contains one or more CPUs and a number of device controllers connected through a common bus that provides access to shared memory. So, here we see that we are having different devices and each device is connected to a particular device controller like this."}
{"text": " Here we see that the disks are connected to the disk controllers and then the USB devices like your mouse, keyboard and printers are connected to the USB controllers and monitor is connected to the video adapter. So, each device is connected to a device controller which are connected via a common bus. This line here represents the"}
{"text": " common bus, and they provide access to shared memory. So, that is what we have said over here. And now, each device controller is in charge of a specific type of device. We know that there are different types of devices, and each device controller is in charge of a specific type of device. And this device controller maintains two things. What are they? One is a local buffer storage, and the other one is a set of special purpose registers."}
{"text": " So, we will see why it maintains this and what is the use of this as we proceed further. But remember that a device controller maintains a local buffer storage and a set of special purpose registers."}
{"text": " Typically, operating systems have a device driver for each device controller. Now, we have talked about device controller. Now, we are talking about another term called device driver. Now, operating systems have a device driver as well for each device controller. Let's see why do we have that?"}
{"text": " This device driver understands the device controller and presents a uniform interface to the device to the rest of the operating system. So, as I told you these devices are very different. They have a varying nature as we said."}
{"text": " and then each device controller also will be different for different devices. And then, how will these device controllers interact with the operating system? We need a proper interface that allows these device controllers to interact with the operating system. So, these device drivers, they understand what kind of nature does the device controller have, and it provides a uniform interface"}
{"text": " to the device to the rest of the operating system. So, that is the function of your device driver. Now, let us see how does a basic I O operation work. So, here we will be seeing the working of an I O operation. So, here we have a diagram and here is the explanation of that. So, let us see. First of all, to start an I O operation, the device driver loads the appropriate registers within the device controller."}
{"text": " So, when an IOP has to be performed by any device, what does it do? The respective device driver of that device loads the appropriate registers within the device controller."}
{"text": " So, when we were talking about device controller, I told you that device controller maintains a set of registers. So, from these registers, the appropriate registers that are required for performing that particular input-output operation will be loaded by the device driver. The second point is,"}
{"text": " The device controller in turns examines the contents of these registers to determine what action to take. Now, why does it load those appropriate registers? Those registers are loaded because in those registers we have the information or the data about what is the action or what is the exact input-output operation that has to be performed."}
{"text": " So, after the device driver loads those appropriate registers within the device controller, the device controller will examine the contents of those registers and determine what action to take. So, as I said, these registers will contain the information about what action to take. So, the device controller will examine that in order to know what is the action that has to be taken. And then, the controller starts the transfer of data from the device to its local buffer."}
{"text": " So, whatever has to be performed, the data for that will be transferred to the local buffer of the device controller. So, when I talked about device controller, I told you it has a local buffer and a set of registers. So, we saw what the registers are used for and now"}
{"text": " comes the local buffer. So, the data from the device is transferred to the local buffer of the device controller. Once the transfer of data is complete, the device controller informs the device driver via an interrupt that it has finished the operation."}
{"text": " So, we saw that the data was transferred to the local buffer. And then once the data transfer is complete, once the execution is complete, then the device controller will inform the device driver that it has finished its operation. So, once the operation is finished, the device controller will inform the device driver. And how will it inform? It will inform via an interrupt."}
{"text": " So, I have already explained in one of the previous lectures about interrupt. So, via an interrupt it will be informed to the device driver by the device controller that it has finished its operation when it is done. And then what happens? The device driver then returns control to the operating system."}
{"text": " After it is done, the device driver will return the control to the operating system, so that it can continue with the other work or task that it has to do. Now, this is the diagram that represents whatever I was explaining over here. Here you have the CPU and here we have the device and this is the memory and then"}
{"text": " when the device has an input-output request. After loading the registers and everything, the device controller loads its data to the local buffer and then it goes via the CPU to the memory. So, here we have the instruction execution cycle and the data movement between the CPU and the memory and whatever task has to be done will be done and then the data that has been transferred back to the device will be transferred back"}
{"text": " and then once everything is done via an interrupt, it tells that I am done with my operation. So, this is the diagrammatic representation of whatever is written here. Now, we see that there is a disadvantage to this kind of operation. Let's see what it is. This form of interrupt driven I.O. is fine for moving small amount of data, but can produce high overhead when used for bulk data movement."}
{"text": " So, we see that when this kind of a system is used, it is okay when it is used for moving small amount of data. But if you want to move or if you want to do input output operations that involve large or bulk amount of data movement, then this is not a very efficient system. Why? Because it is going to take up so much of your CPU and time."}
{"text": " because the CPU is always being interrupted over here. And in order to solve that, what do we do? To solve this problem, direct memory access, also known as DMA is used. So, in order to solve this problem, we have something called direct memory access, called DMA. So, that one is used. So, that is what we represent over here. And let's see what happens in DMA. After setting up buffers, pointers, and counters for the I O devices,"}
{"text": " The device controller transfers an entire block of data directly to or from its own buffer storage to memory with no intervention by the CPU. So, even in this direct memory access, the first"}
{"text": " three points remain the same. Okay? They will have to load the registers, buffers and everything. And after doing that, instead of going via the CPU in this way, what it does is that the device controller transfers an entire block of data directly to the memory from its own buffer storage without intervention of the CPU. So, in DMA we see that the CPU is not affected. It just goes directly to the memory."}
{"text": " So, whatever has to be sent to the memory can be directly sent and whatever has to be taken back from the memory also can be directly done without intervention of the CPU. So, this is direct memory access. So, in this direct memory access only one interrupt is generated per block to tell the device driver that the operation has completed. So, here only one interrupt per block is required. But in case of our"}
{"text": " other system that we first explained, there will be interrupt per byte of data that is being transferred. So, the CPU is interrupted so many times, making it an inefficient system. But here, only one interrupt is generated per block, and when is it generated? It is generated to tell the device driver that the operation is completed. When it is completed, it is generated just to tell the driver that the operation is completed."}
{"text": " So, while the device controller is performing these operations, the CPU is available to accomplish other works. So, this is one of the greatest advantages of this. As we said, in DMA, CPU is not intervened. So, even when this IO operation is occurring, the CPU is free to perform its other tasks and it will not be disturbed. So, this is the advantage of direct memory access. So, that is how input-output operation works and"}
{"text": " how DMA works. So, I hope this was clear to you. This was about the input-output structure which is also the basics of your operating system. So, I hope this was clear to you. Thank you for watching and see you in the next one."}
{"text": " In the previous lecture, we have studied about process creation which was an operation on processes. And in this lecture, we will be studying about process termination which is also an operation on processes. So, from the name itself, you can understand that process termination means"}
{"text": " when a process comes to an end and we are terminating it. So, a process terminates when it finishes executing its final statement and ask the operating system to delete it by using the exit system call. So, a process is said to have terminated when it finishes executing its final statement. So, we know that in processes there are lines of code or lines of statements that are being executed. So, when it reaches its final statement,"}
{"text": " and when the final statement finishes its execution, at that time the process asks the operating system to delete it by using the exit system call. So, using the exit system call, the process asks the operating system to delete it because it has finished its execution. So, at that moment the process terminates. So, at that point,"}
{"text": " the process may return a status value which will typically be an integer to its parent process via the wait system call. So, we have seen about the process tree where we have the parent process and the children of a particular process. There can be many children of a single process. So, the children process they belong to a parent process. So, when a child process or when some children process has completed its execution"}
{"text": " and when it is going to terminate, it will return a status value to its parent. And why will it do so? So that the parent will know that the child process has completed its execution and it is terminating. And it will do so using the wait system call. All the resources of the process including physical and virtual memory,"}
{"text": " open files and input output buffers are deallocated by the operating system. So, when a process is executing, we know that it is assigned certain resources. We have already studied about this. So, when a process completes its execution, all the resources that are allocated to that particular process. So, resources may be"}
{"text": " memory which may be physical or virtual and it may have files and it may have input output buffers. All these kind of resources may be allocated to a particular process while it is executing. And when the process finishes its execution and when it is going to terminate,"}
{"text": " All these resources that were being held by that particular process are deallocated by the operating system. That means it is freed from that process so that it can be used by another process. Now, terminations can occur in other circumstances as well."}
{"text": " So, when we just studied about termination now, we saw that a termination of a process occurs when the final statement of the process has been executed and when the process finishes and at that time the termination of a process occurs. So, that's what we just saw. But, termination can also occur in other circumstances as well."}
{"text": " And let's see what they are. A process can cause the termination of another process via an appropriate system call. So, one process can cause the termination of another process via an appropriate system call. Alright. So, not only when a process finishes its execution, but also when a process may still be executing at that moment also,"}
{"text": " another process can cause the termination of that process via an appropriate system call. Now, you may be thinking if this is possible, then every process may be able to kill or terminate every other processes. So, that is not the case. Usually, such a system call can be invoked only by the parent of the process that is to be terminated."}
{"text": " So, the killing of one process by another process only occurs when the process that is killing the process is its parent process. So, we said that a process can cause termination of another process via an appropriate system call. But such a system call can be invoked only by the parent of the process that is to be terminated. That means, only the"}
{"text": " parent can kill its own children. Alright. Only the parent process can kill the child or children of that process. Otherwise, users could arbitrarily kill each other's jobs. So, if that was not the case, then every process will be able to kill each other and that will cause a great problem. So, when one process kills another process, remember that it is the parent that is killing the"}
{"text": " child or the children of that particular process. Now, a parent may terminate the execution of one of its children for a variety of reasons such as this. Now, we may be thinking, why would a parent process kill its child or children processes? There may be a variety of reasons for that to happen. So, let's see what are those reasons."}
{"text": " The first reason is the child has exceeded its usage of some of the resources that it has been allocated. To determine whether this has occurred, the parent must have a mechanism to inspect the state of its children."}
{"text": " So, the first reason why a parent might kill its child in terms of process is when the child has exceeded its usage of some of the resources that it has been allocated. So, we know that there are certain resources allocated to each of the processes. So, even the children are also having some of the resources. Now, if a child or if the children has exceeded its usage of the resources that it has been allocated,"}
{"text": " At that time, the parent might want to kill that child so that it can get back its resources and that resources may be allocated to some other processes or the parent itself may want to use some of those resources. Now, to determine whether this has occurred,"}
{"text": " the parent must have a mechanism to inspect the state of its children. Now, how does a parent know whether the child has exceeded the usage of the resources that has been allocated. So, in order to know that the parent must have some kind of mechanism by which it will know the state of its children. It will know how much resources the children is using and what is the state of the children."}
{"text": " So, using some kind of mechanism the parent will find that out. And if it finds that the children is exceeding the use of the resources, then it can terminate that child process. So, that was one reason and the second reason is the task assigned to the child is no longer required."}
{"text": " Now, we know why a parent creates children. A parent creates a children or a child process in order to perform a particular task. Now, if the task assigned to that child is no longer required by the parent or no longer required by the entire process tree itself, then that child can be terminated. We don't need that child because the task assigned to that child is no longer required. So, this is another reason because of which"}
{"text": " a parent may terminate the children or the child. And the third reason is the parent is exiting and the operating system does not allow a child to continue if its parent terminates. Now, this is the third reason. The third reason says that the parent is exiting. That means the parent itself is terminating and then the operating system does not allow the child to continue if the parent terminates. So,"}
{"text": " When the parent terminates, some operating systems does not allow the processes which are created as the children of that parent to continue if the parent terminates. So, if that kind of a case occurs, when the parent is terminating,"}
{"text": " all the children processes associated to that parent should also be terminated. So, this is in the case of some of the operating systems. So, if the parent terminates, all the children of that parent also must terminate. So, all the children of that process will also terminate when the parent is terminating."}
{"text": " So, we have seen what are the reasons due to which a parent may terminate his children and we saw when does a termination of a process occurs. It either occurs when the process has finished its execution or the parent process may kill or terminate its children process due to one of these reasons mentioned here. So, that was about process termination which is also an operation on the processes. So, I hope this was clear to you. Thank you for watching and see you in the next class."}
{"text": " storm."}
{"text": " One, and the lecture on symmetric matrices. So that's the most important class of matrices, symmetric matrices. A equals A transpose. So the first points, the main points of the lecture, I'll tell you right away. What's special about the eigenvalues, what's special about the eigenvectors? This is, now the,"}
{"text": " This is the way we now look at a matrix. We want to know about its eigenvalues and eigenvectors, and if we have a special type of matrix, that should tell us something about eigenvalues and eigenvectors. Like Markov matrices, they had an eigenvalue equal one. Now symmetric matrices, can I just"}
{"text": " Tell you right off what the main facts, the two main facts are. The eigenvalues of a symmetric matrix, real, this is a real symmetric matrix, we're talking mostly about real matrices, the eigenvalues are also real. So our examples of rotation matrices where, where we got eigenvalues that were complex, that won't happen now."}
{"text": " For symmetric matrices, the eigenvalues are real and the eigenvectors are also very special. The eigenvectors are perpendicular, orthogonal. Which do you prefer? I'll say perpendicular. Perp- well, they're both long words. Perpendic- okay. Right. So."}
{"text": " I'll, you should say why. And I'll at least answer why for case one. Maybe case two, the checking the eigen, that the eigenvectors are perpendicular, I'll leave to, the, the book. But let's just realize what, well, first I have to say, it, it could happen, like, for the identity matrix,"}
{"text": " There's a symmetric matrix, its eigenvalues are certainly all real, they're all one, for the identity matrix. What about the eigenvectors? Well, for the identity, every vector is an eigenvector. So how can I say they're perpendicular? What I really mean is the, this word R should really be written can be chosen. Perpendicular."}
{"text": " That is, if we have, it's the usual case. If the eigenvalues are all different, then each eigenvalue has one line of eigenvectors and those lines are perpendicular here."}
{"text": " But if an eigenvalue is repeated, then there's a whole plane of eigenvectors, and all I'm saying is that in that plane, we can choose perpendicular ones. So that's why it's a can-be-chosen part. It's, this is in the case of a repeated eigenvalue where there's some real substantial freedom. But the typical case is different eigenvalues, all real,"}
{"text": " one-dimensional eigenvector spaces, eigenspaces, and all perpendicular. So just, let's just see the conclusion. If we accept those as correct, what happens, and I also mean that there's a full set of them. So that's part of this picture here."}
{"text": " that there's a complete set of eigenvectors, perpendicular ones. So having a complete set of eigenvectors means, so normal, so the usual, maybe I put the usually, usual, usual case is that the matrix A we can write in terms of its eigenvalue matrix and its eigenvector matrix this way, right?"}
{"text": " We can do that in the usual case, but now what's special when the matrix is symmetric? So this is the usual case, and now let me go to the symmetric case. So in the symmetric case, A, this should become somehow a little special. Well, the lambdas."}
{"text": " On the diagonal, or still on the diagonal, they're real, but that's where they are. What about the eigenvector matrix? So what can I do now special about the eigenvector matrix when the A itself is symmetric? That says something good about the eigenvector matrix. So what does this lead to? These perpendicular eigenvectors,"}
{"text": " I can not only guarantee they're perpendicular, I could also make them unit vectors, no problem. Just scale their length to one. So what do I have? I have orthonormal eigenvectors. And what does that tell me about the eigenvector matrix? What letter should I now use?"}
{"text": " in place of S, remember S has the eigenvectors in its columns, but now those columns are orthonormal. So the right letter to use is Q. So that's where, so we've got the letter all set up, so this should be Q lambda Q inverse."}
{"text": " Q standing in our minds always for this matrix, in this case it's square, it's, it's, so these are the columns of Q, of course. And one more thing. What's Q inverse? For an orthonormal, for a matrix that has these orthonormal columns."}
{"text": " we know that the inverse is the same as the transpose. So here is the beautiful, there's the, the great, description, the factorization of a symmetric matrix. And this is like one of the famous theorems of linear algebra, that if I have a symmetric matrix,"}
{"text": " It can be factored in this form, an orthogonal matrix times diagonal times the transpose of that orthogonal matrix. And of course, everybody immediately says, yes, and if this is possible, then that's clearly symmetric, right? We've looked at products of three guys like that and taken their transpose and we got it back again."}
{"text": " Do you see the beauty of this factorization, then? It completely displays the eigenvalues and eigenvectors and the symmetry of the whole thing, because that product, Q times lambda times Q transpose, if I transpose it, it just comes in this position and we get that matrix back again."}
{"text": " So that's, in mathematics that's called the spectral theorem. Spectrum is the set of eigenvalues of a matrix. It somehow comes from the idea of the spectrum of light as a combination of, of, pure things, where our matrix is broken down into pure eigenvalues and eigenvectors."}
{"text": " Mechanics, it's often called the principal axis theorem. It's very useful. It means that if you have, we'll see it geometrically. It means that if I have some material, if I look at the right axes, it becomes diagonal, it becomes, the directions don't couple together. OK."}
{"text": " That's what to remember from this lecture. Now I would like to say, why are the eigenvalues real? Can I do that? So, because something useful comes out. So I'll just come back, come to that question, why real eigenvalues? OK."}
{"text": " So I have to start from the only thing we know, Ax equal lambda x. OK. But as far as I know at this moment, lambda could be complex. I'm going to prove it's not. And x could be complex."}
{"text": " In fact, for the moment, even A could be. We could even think, well, what happens if A is complex? Well, one thing we can always do. This is, this is like always, always okay. I can, if I have an equation, I can take the complex conjugate of everything. That's no, no, so A conjugate x conjugate equal lambda conjugate x conjugate."}
{"text": " It just means that everywhere over here that there was a"}
{"text": " an i, then here I changed it to a minus i. That, that, you, you know that that step, that conjugate business, that a plus i b, if I conjugate it, it's a minus i b. That's the meaning of conjugate. And products behave right, I can conjugate every factor. So I haven't done anything yet except to say what would be true if"}
{"text": " X, in any case, even if X and lambda were complex. Of course, our, we're speaking about real matrices A, so I can take that out. Actually, this already tells me something about real matrices. I haven't used any assumption of A equal A transpose yet. Symmetry is waiting in the wings to be used. This tells me that if"}
{"text": " A real matrix has an eigenvalue lambda and an eigenvector x. It also has an- another of its eigenvalues is lambda bar with eigenvector x bar. Real matrices, the eigenvalues come in lambda, lambda bar, the complex eigenvalues come in lambda and lambda bar pairs."}
{"text": " But of course, I'm aiming to show that they're not complex at all here, by getting symmetry in. So how am I going to use symmetry? I'm going to transpose this equation to x bar transpose A transpose equals x bar transpose lambda bar. That's just a number, so I don't mind where I put that number. This is, this is, then again,"}
{"text": " OK. But now I'm ready to use symmetry. I'm ready, so this was all just mechanics. Now, now comes the moment to say, OK, if the matrix is symmetric, then this A transpose is the same as A. You see, at that moment I used the assumption. Now let me finish the discussion."}
{"text": " Here's the way I finish. I look at this original equation and I take the inner product, I multiply both sides by, oh, maybe I'll do it with this one. I take, I multiply both sides by x bar transpose. x bar transpose A x bar equals lambda bar x bar transpose x bar. OK, fine."}
{"text": " All right? Now what's the other one? Oh, the other one I'll probably use this guy. Am I happy about this? No, for some reason I'm not."}
{"text": " Yeah, if I take the inner product of this from the right with x bar, I get x bar transpose A x bar equals x bar transpose lambda bar x bar. I've done something dumb, because I've got the -. I haven't learned anything. I've got, those two equations are identical."}
{"text": " Forgive me for doing such a thing, but, I'll look at the book. OK. So I took the dot product, yeah, somehow it didn't, I should have taken the dot product of this guy here with, that's what I was going to do, Ax equals lambda x bar transpose x, right?"}
{"text": " OK, so that was, that's fine, that comes directly from that, multiplying both sides by x bar transpose, but now I'd like to get, why do I have x bars over there? Ah, yes. Forget this. OK, on this one, right, on this one, I took it like that, I multiply on the right by x. That's the idea."}
{"text": " Okay. Now why am I happier with this situation now? A proof is coming here. Because I compare this guy with this one. And they have the same left-hand side. So they have the same right-hand side. So comparing those two, can I, I'll raise the board to do this comparison, this thing"}
{"text": " Lambda x bar transpose x is equal to lambda bar x bar transpose x. OK. And the conclusion I'm going to reach, am I on the right track here? The conclusion I'm going to reach is lambda equal lambda bar."}
{"text": " I would have to track down the other possibility that this thing is zero. But let me, oh. Oh yeah, that's important. It's not zero. So once I know that this isn't zero, I just cancel it and I learn that lambda equals lambda bar. And so what? Can you, have you got the reasoning altogether? What does this tell us?"}
{"text": " Lambda's an eigenvalue of this symmetric matrix. We've just proved that it equaled lambda bar, so we have just proved that lambda is real. Right? If a number is equal to its own complex conjugate, then there's no imaginary part at all, the number is real. So lambda is real. Good. Good."}
{"text": " Now, what, but it depended on this little expression, on knowing that that wasn't zero, so that I could cancel it out. So can we just take a second on that one? Because it's an important quantity. X bar transpose x. Okay, now remember, as far as we know, x is complex. So this is?"}
{"text": " Here x is complex, x has these components, x1, x2, down to xn. And x bar transpose, well, it's transposed and it's conjugated. So that's x1 conjugated, x2 conjugated, up to xn conjugated."}
{"text": " I'm really reminding you of crucial facts about complex numbers that are going to come into the next lecture as well as this one. So what can you tell me about that product? I guess what I'm trying to say is, if I had a complex vector, this would be the quantity I would like. This is the quantity I like. I would take the vector."}
{"text": " times its transpose. Now what happens usually if I take a vector x transpose x? I mean, that's a quantity we see all the time, x transpose x. That's the length of x squared, right? That's this positive length squared, it's Pythagoras, it's x1 squared plus x2 squared and so on. Now our vector is complex and you see the effect? I'm conjugating."}
{"text": " one of these guys. So now when I do this multiplication, I have x1 bar times x1 and x2 bar times x2 and so on. So this is an, this is some a plus i b and this is some a minus i b. I mean, what's the point here? What's the point when I multiply a number by its conjugate,"}
{"text": " A complex number by its conjugate, what do I get? I get a, the imaginary part is gone. When I multiply A plus IB by its conjugate, what's, what's the result of that, of each of those separate little multiplications? There's an A squared, and, and what, how many, what's B squared comes in with a plus or a minus? A plus."}
{"text": " i times minus i is a plus b squared, and what about the imaginary part? Gone, right? An i a b and a minus i a b. So this, this is the right thing to do. If you want a decent answer, then multiply numbers by their conjugates."}
{"text": " multiply vectors by the conjugates of x transpose. So this quantity is positive, this quantity is positive, the whole thing is positive, except for the zero vector, and that allows me to know that this is a positive number, which I safely cancel out and I reach the conclusion. So actually, in this discussion here,"}
{"text": " I've done two things. I've reached the conclusion that lambda's real, which I wanted to do. But at the same time, we sort of saw what to do if things were complex. If a vector is complex, then it's x bar transpose x, this is its length squared. And as I said, the next lecture Monday will"}
{"text": " will repeat that this is the right thing and then do the right thing for matrices and all other, all other, complex possibilities. OK. But the main point, then, is that the eigenvalues of a symmetric matrix, it just, where did we use symmetry, by the way? We used it here, right? Can I just?"}
{"text": " Suppose A was a complex. Suppose A had been a complex number. Could, could I have made all this work? If A was a complex number, a complex matrix, then here I should have written A bar. I erased the bar because I assumed A was real, but now let's suppose for a moment it's not. Then when I took this step, what should I have?"}
{"text": " What did I do on that step? I transposed. So I should have A bar transpose. In the symmetric case, that was A. And that's what made everything work, right? This, this led immediately to that. This one led immediately to this when the matrix was real, so that didn't matter, and it was symmetric, so that didn't matter. Then I got A."}
{"text": " So now I just get to ask you, suppose the matrix had been complex, what's the right equivalent of symmetry? So the good matrix, so here, let me say, good matrices. By good, I mean real lambdas and perpendicular x-s."}
{"text": " And tell me now which matrices are good. If they're real matrices, the good ones are symmetric. Because then everything went through. So the good, I'm saying now what's good. These are the good matrices. They have real eigenvalues, perpendicular eigenvectors. Good means A equal A transpose if real."}
{"text": " Then, then that was what our proof worked. But if A is complex, all, our proof will still work provided A bar transposes A. Do you see what I'm saying? I'm saying if we have complex matrices and we want to say are they, are they as good as symmetric matrices, then we should not only transpose the thing but conjugate it."}
{"text": " Those are good matrices. And of course the most important case is when they're real, this part doesn't matter and I just have A equal A transpose symmetric. I'll just repeat that. The good matrices, if complex, are these. If real,"}
{"text": " That doesn't make any difference, so I'm just saying symmetric. And of course, 99% of examples and applications, the matrices are real, and we don't have that, and then symmetric is the key property. Okay. So that's, these main facts, and now let me just, let me just, so that's this x bar transpose x."}
{"text": " OK. So I'll just, write it once more in this form. So perpendicular orthonormal eigenvectors, real eigenvalues, transposes of orthonormal eigenvectors. That's the symmetric case, A equal A transpose. OK. Good. Actually,"}
{"text": " I'll even take one more step here. Suppose, I can break this down to show you really what that says about a symmetric matrix. I can break that down. Let me, here go these eigenvectors."}
{"text": " Here go these eigenvalues, lambda one, lambda two, and so on. Here go these eigenvectors transposed. And what happens if I actually do out that multiplication? Do you see what will happen? There's lambda one times q1 transposed."}
{"text": " So the first row here is just lambda one q1 transpose. If I multiply column times row, you remember I could do that? When I multiply matrices, I can multiply columns times rows. So when I do that, I get lambda one and then the column and then the row and then lambda two and the column and the row."}
{"text": " Every symmetric matrix breaks up into these pieces. So these pieces have real lambdas and they have these orthonormal eigenvectors. And maybe you even could tell me what kind of a matrix have I got there. Suppose I take a unit vector."}
{"text": " times its transpose. So column times row, I'm getting a matrix. That's a matrix with a special name. What kind of a matrix is it? We've seen those matrices now in chapter four. It's A A transpose with a unit vector, so I don't have to divide by A transpose A. That matrix is a?"}
{"text": " projection matrix. That's a projection matrix. It's symmetric. And if I square it, there'll be another, there'll be a q1 transpose q1, which is one. So I'll get that matrix back again. Every, so every symmetric matrix, every symmetric matrix is a combination of"}
{"text": " of mutually perpendicular, so perpendicular projection matrices. Projection matrices. OK. That's another way that people like to think of the spectral theorem. That every symmetric matrix can be broken up that way."}
{"text": " I guess at this moment, first I haven't done an example. I could create a symmetric matrix, check that it's, find its eigenvalues, they would come out real, find its eigenvectors, they would come out perpendicular, and you would see it in numbers, but maybe I'll leave it here for the moment in letters. Oh, maybe I will do it with numbers for this reason. Because there's one more remarkable fact."}
{"text": " Can I just put this further great fact about symmetric matrices on the board? When I have symmetric matrices, I know their eigenvalues are real. So then I can get interested in the question, are they positive or negative? And you remember why that's important. For differential equations, that decides between instability and stability."}
{"text": " So I'm, after I know they're real, then the next question is, are they positive, are they negative? And I hate to have to compute those eigenvalues to answer that question. Right? Because computing the eigenvalues of a symmetric matrix of order, let's say, fifty, compute its fifty eigenvalues, is a job."}
{"text": " I mean, by pencil and paper, it's a lifetime's job. I mean, which, and in fact, a few years ago, well, say, twenty years ago, or thirty, nobody really knew how to do it. I mean, so, like, science was stuck on this problem. If you have a matrix of order fifty or a hundred, how do you find its eigenvalues?"}
{"text": " Numerically now, I'm just saying, because pencil and paper is, we're going to run out of time or paper or something before we get it. Well, and you might think, OK, get the, get, get MATLAB to compute the determinant of lambda minus A, A minus lambda I, this polynomial of fiftieth degree, and then find the roots."}
{"text": " MATLAB will do it, but it will complain. Because it's a very bad way to find the eigenvalues. I'm sorry to be saying this, because it's the way I taught you to do it, right? I taught you to find the eigenvalues by doing that determinant and taking the roots of that polynomial. But now I'm saying, okay, I really meant that for two by twos and three by threes, but I didn't mean you to do it on a fifty by fifty."}
{"text": " you're not too unhappy, probably, because you didn't want to do it. But, good. Because it would be a very unstable way, the an- the fifty answers that would come out would be highly unreliable. So, new ways are, are much better to find those fifty eigenvalues. That's a, that's a part of numerical linear algebra. But here's the remarkable fact."}
{"text": " that MATLAB would quite happily find the fifty pivots, right? Now the pivots are not the same as the eigenvalues. But here's the great thing. If I had a real matrix, I could find those fifty pivots and I could see maybe twenty-eight of them are positive and twenty-two are negative pivots, and I can compute those safely and quickly."}
{"text": " And the great fact is that twenty-eight of the eigenvalues would be positive and twenty-two would be negative. That the signs of the pivots, so this is like a, just, I hope you think this is kind of a nice thing. That the signs of the pivots for symmetric, I'm always talking about symmetric matrices."}
{"text": " So I really like trying to convince you that symmetric matrices are better than the rest. So the signs of the pivots are same as the signs of the eigenvalues. The same number. The number of pivots greater than zero, the number of positive pivots,"}
{"text": " is equal to the number of positive eigenvalues. So that actually is a very useful, that gives you a good start on a decent way to compute eigenvalues. Because you can narrow them down, you can find out how many are positive, how many are negative. Then you could shift the matrix by seven times the identity."}
{"text": " That would shift all the eigenvalues by seven. Then you could take the pivots of that matrix and you would know how many eigenvalues of the original were above seven and below seven. So this, this neat little theorem that the symmetric matrices have this connection between the, nobody's mixing up and thinking the pivots are the eigenvalues."}
{"text": " I mean, the only thing I can think of is the product of the pivots equals the product of the eigenvalues, why is that? So if I asked you for the reason on that, why is the product of the pivots for a symmetric matrix the same as the product of the eigenvalues? Because they both equal the determinant. Right. The product of the pivots gives the determinant if no row exchanges."}
{"text": " The product of the eigenvalues always gives the determinant. So, so the products, but that doesn't tell you anything about the fifty individual ones, which this does. Okay. So that's, those are essential facts about symmetric matrices. Okay. Now I, I said in the, in the lecture description that I would"}
{"text": " take the last minutes to start on positive definite matrices, because we're right there. We're ready to say what's a positive definite matrix. It's symmetric, first of all. Always I will mean symmetric."}
{"text": " So this is the next section of the book. It's about this, if symmetric matrices are good, which is, like, the point of my lecture so far, then positive definite matrices are a subclass that are excellent. Okay. Just the greatest. So what are they?"}
{"text": " Their matrices, their symmetric matrices, so all their eigenvalues are real, you can guess what they are. These are symmetric matrices with all the eigenvalues are OK, tell me what to write. What, well, it's hinted, of course, by the name for these things."}
{"text": " All the eigenvalues are positive. OK. Tell me about the pivots. We can check the eigenvalues or we can check the pivots. All the pivots are what?"}
{"text": " And then I'll finally give an example. I feel awful that I have got to this point in the lecture and I haven't given you a single example. So let me give you one. Five, three, two, two. At symmetric, fine. Its eigenvalues are real, for sure. But more than that, I know the signs of those eigenvalues."}
{"text": " And also I know the signs of those pivots. So what's the deal with the pivots? If the eigenvalues are all positive, and if this little fact is true that the pivots and eigenvalues have the same signs, then this must be true. All the pivots are positive. And that's the good way to test. This is the good test, because I could, what are the pivots for that matrix?"}
{"text": " The pivots for that matrix are five, so pivots are five, and what's the second pivot? Have we, like, noticed the formula for the second pivot in a matrix? It doesn't necessarily, you know, it may come out a fraction for sure, but what is that fraction, can you tell me? Well, here."}
{"text": " The product of the pivots is the determinant. What's the determinant of this matrix? Eleven? So the second pivot must be eleven over five, so that the product is eleven. They're both positive. Then I know that the eigenvalues of that matrix are both positive."}
{"text": " What are the eigenvalues? Well, I've got to take the roots of, you know, do I put in a minus lambda? Do you mentally do this? Lambda squared minus how many lambdas? Eight, right? Five and three, the trace comes in there, plus what number comes here? The determinant, the eleven. So I set that to zero. So the eigenvalues are?"}
{"text": " Let's see, half of that is four, look at that positive number, plus or minus the square root of sixteen minus eleven, I think five. The eigenvalues, well, two by two, they're not so terrible, but they're not so perfect. Pivots are really simple."}
{"text": " And this is the family of matrices that you really want in differential equations, because you know the signs of the eigenvalues, so you know the stability or not. Okay. There's one other related fact I can pop in here in the time available for positive definite matrices. The related fact is to ask you about determinants."}
{"text": " So what's the determinant? What can you tell me if I -? Remember, positive definite means all eigenvalues are positive, all pivots are positive, so what can you tell me about the determinant? It's positive, too. But somehow that's not quite enough."}
{"text": " Here's a matrix, minus one, minus three. What's the determinant of that guy? It's positive, right? Is this a positive definite matrix? Are the pivots, what are the pivots? Well, negative. What are the eigenvalues? Well, they're also the same. So somehow,"}
{"text": " I don't just want the determinant of the whole matrix, here is eleven, that's great. Here the determinant of the whole matrix is three, that's positive. I also, I've got to check, like, little sub-determinants. Say, maybe coming down from the left. So the one by one and the two by two have to be positive. So there, that's where I get the all."}
{"text": " All, can I call them subdeterminants, are, see, I have to, I need to make the thing plural. I need to test n things, not just the big determinant. All subdeterminants are positive. Then I'm OK. Then I'm OK. This passes the test."}
{"text": " Five is positive and eleven is positive. This fails the test because that minus one there is negative. And then the big determinant is positive three. So this fact, you see that actually the course, like, coming together."}
{"text": " And that's really my point now. In the next, in this lecture and particularly next Wednesday and Friday, the course comes together. These pivots that we met in the first week. These determinants that we met in the middle of the course. These eigenvalues that we met most recently. All matrices are square here."}
{"text": " So coming together for square matrices means these three pieces come together and they come together in that beautiful fact that if I have one of these, I have the others."}
{"text": " that if I, but for symmetric matrices. So that, this will be the positive definite section, and then the real climax of the course is to make everything come together for m by n matrices."}
{"text": " Not necessarily symmetric. Bring everything together there and that will be the final thing. Okay. So have a great weekend and don't forget symmetric matrices. Thanks."}
{"text": " All right, please find your seat. Let's get started. So,"}
{"text": " Last lecture, we started our journey about virtual memory, and we left off with doing a page table, which was basically a giant lookup table, right? We decided not to individually translate individual addresses, because that would be insane, so we decided to have a big block of memory and translate something called pages, which are typically 4,096 bytes."}
{"text": " And that's where we left off. So, any questions about where we left off yesterday? Pretty clear, hopefully? No major questions? So, the big problem we were left off with last time is, well, if we have a giant page table, and we only have one page table, so again, each process would need its own page table, because each process has access to its own virtual memory,"}
{"text": " So if we have just one giant page table that supports up to a 39-bit virtual address, well, our page table would need 2 to the 26 entries again, one for each, and then each of our entries would essentially need to store at least a physical page number. So that's one of the things that would need to be stored in the PTE. Does anyone remember what other things we need to store in a page table entry?"}
{"text": " So one of the things for sure we need to store is the physical page number, so where to actually find this page in physical memory, and what are some other things we need to store as part of the page table entry. Yep? Yeah, at least a valid bit, maybe some other flags if I can read or write to it, maybe if I can execute it. So we'd have a physical page number, some flags, which would definitely include something like, whoops,"}
{"text": " which would definitely include something like a valid bit."}
{"text": " So this doesn't really work because, well, if we multiply those two numbers together to get the size of our page table, well, that means the size of our page table is 2 to the 30. So 2 to the 26 times 2 to the 3, which is what 8 is. Again, generally, it's better to keep everything in powers of 2, because then using exponent law, you can just add them together."}
{"text": " 27 plus 3 is 30. So the size of this page table is 2 to the 30, which, again, is 1 gigabyte. So you might notice I write something weird. I write a lowercase i after the gigabyte instead of just gb. And that's because gigabyte"}
{"text": " means something different depending on who you're talking to and GIB means definitely base powers of two so in that 2 to the 10 is 1 kilobyte 2 to the 12 is 1 megabyte 2 to the 30 is 1 gigabyte and then depending on who you're talking to well a kilobyte is"}
{"text": " might mean the same thing, or maybe not. Maybe it means base 10, because we're humans. Maybe it's 10 to the 3. And a megabyte is 10 to the 6."}
{"text": " Then a gigabyte is 10 to the 9. And then let's do a terabyte for fun. So a terabyte in base 2 units is 2 to the 40. In base 10, it would be 10 to the 12 terabytes. And these numbers aren't that much different if you do it kilobytes, because it's like 1,024 versus 1,000, basically the same thing."}
{"text": " But if you go all the way to a terabyte and you actually get the difference between these two numbers, it becomes somewhat significant. So this is probably the base two things we care about and make sense to us. And this is what hard drive manufacturers will sell you."}
{"text": " So has anyone ever had a disk and then formatted it and it's way smaller than it should be? Well, if you read the fine print, it's because their definition of a terabyte is probably different than your definition of a terabyte. And since it's actually kind of ambiguous, they choose the smaller one because it's cheaper. So that's just a fun aside thing. So I'll always write the lowercase i, i there, which means it's a base two."}
{"text": " So that's a fun fact for the day. So that's way too big. One gigabyte per process is not going to work. So this is like the shock of the lecture. So this is what we're going to do. So we are going to divide up that huge, huge, huge page table."}
{"text": " into a sequence of smaller page tables. And the idea is, well, if I only need to translate a few pages, well then, I don't have to store one giant one gigabyte table. I could actually just store something like, in this example, at minimum three tables."}
{"text": " So each of these tables are significantly smaller, so you'll see they only have 512 entries, so 0 to 511, and they just contain a normal page table entry, but instead of doing a direct lookup,"}
{"text": " they just point to the table below it. So instead of our one big page table, we would start at L2, and that's where our first page table would be. We get an index into there, which is significantly smaller, and that points to another page table. Then we do the same thing. Point to another page table until eventually we get down to the bottom here at our lowest page table, and then that just behaves as normal. That has the direct lookup we have."}
{"text": " So at the end of the lecture, we're going to explain this. It's OK if this doesn't really make that much sense right now. But after we're done, we'll come back and see if we understand it."}
{"text": " So first, we'll dispel one kind of myth about what we're talking about. So all this page table stuff, all of the management is done by the kernel, and it directly accesses physical memory, because it's the kernel, it needs to make virtual memory for your processes, so it doesn't exist before the kernel has anything to do with it. So when you boot up your computer,"}
{"text": " your kernel will be able to figure out how much physical memory is in your machine. And what it is going to do is divide all that physical memory up into pages and essentially maintain a giant linked list of all those pages."}
{"text": " It'll have a blank list of all the pages for efficiency. It would just store a pointer on a page because all that memory is not used yet. But it's basically just a giant linked list. And then all they do is point to the next free one. And initially, when you boot up your computer, the kernel will just create a link to the next one, to the next one, to the next one, because nothing's using memory yet."}
{"text": " So this would be the initialization at boot. It just creates a bunch of pointers between all the actual physical memory blocks. And then in the kernel, memory allocation becomes dead simple because everything is the same fixed size block. We're dealing with pages. So if you request a block and the kernel has to allocate it for you, it just"}
{"text": " removes it from the free list, whatever it's pointing to. And then you just use that block of memory, and it's allocated for you. And then when you're done with that page, it would just add it back to the free list. And that's it. So your data structures add stuff to a list, remove stuff from a list. In this type of memory allocation, that's all you need to do to implement memory allocation. You just request a physical page. You get it. When you're done with it, you give it back. So any questions about that? Yep."}
{"text": " Yeah, this would just be a list of pages that we haven't used yet, yeah, at all. Okay, so our major insight for this is since we're dealing with pages and we don't want, and it's really easy to allocate pages, then I don't wanna do any special cases for a giant page table or like a really smaller page table or variable sizes. So the insight for the designers of all this virtual memory systems"}
{"text": " were to just use a page for each of the smaller page tables. So instead of one giant page table, I'm going to create a page table that fits exactly on a page, which in this case, and for most of our examples, it will be that magical 4,096 bytes. So we can work backwards from this. If we know that's our size of our total page table, which would be 2 to the 12, again, remember, we gotta get really used to base two units to make our lives easier."}
{"text": " Well, if each page table entry is the 8 bytes we were discussing before, well, then it's just a simple question of, how many 8-byte things can we fit on a 4,096-byte page? And if you just divide, you get 512. So I could fit 512 page table entries on a single page."}
{"text": " So that's what we do. And each of these levels of page tables just point to a level below it. So in that case, before, we had three levels of page tables, and of course, we did index zero because we like computers. So you start with L2, L2 points to L1, L1 points to L0, and then we treat L0 as our normal big page table that just has our direct lookup in it."}
{"text": " So these smaller page tables, just to get used to them, they're just like arrays. So if I write it out as a table and have two columns of index and that page table entry, well, if we want to be super efficient and store it on our computer, well, we just store it as an array, and you wouldn't have to keep track of the index. You wouldn't store the index. It would just be, everything is nice and sequential and contiguous."}
{"text": " So just to review to make sure we are OK, if I had something like this in C, so I have an array of ints, and I have 512 of them, what's the size of this? How big is that array? Yep."}
{"text": " And what is the size of int? Four bytes. Yep. So if I want to figure out how big this array is in bytes, and remember, we do everything in bytes because memory is byte addressable, so that's the lowest kind of atomic unit we have, well,"}
{"text": " There's 512 ints, so the size of this is 512 times whatever the size of an int is, and an int just happens to be four bytes. So this would be like 2,048 bytes big. So any questions about that? Hopefully that's kind of review. Okay, so now if we, you know, we have an int x, and we do something like this, we do page table two."}
{"text": " Well, we brought up that word offset before, so let's review and make sure we understand it. So what would be the offset of index two, knowing that integers are four bytes? Yeah. Yeah, yeah, so the answer was the offset of that is eight bytes. So does anyone have any questions about how I got that?"}
{"text": " Because this array, it will be stored at some address, somewhere in memory. Generally, you don't care about where the base pointer is, like where the array starts. And if you want to be, your consistent nomenclature is kind of,"}
{"text": " how many bytes from the beginning of that is something. So in this case, well, everything's index 0. So your first element of your array is going to be at byte 0, which is an offset of 0. So that just means it starts at the beginning. And because all of our integers are 4 bytes, well, index 1 would start 4 bytes later. So it would be at index 4."}
{"text": " And index 2 would be 4 bytes after that. So it would start at offset 8. And the offset is basically just how many bytes away from the start is something. So in this case, page table index 2 would be an offset of 8 bytes away."}
{"text": " Doing this whole page table thing is the same thing. We just have to substitute an int for a page table entry. So now all I did is change int to page table entry. So now if I have 512 page table entries, everything is still the same. So if I do the size of the page table, well, that's the same as the array. So it's the number of entries times the size of whatever the thing is I'm storing."}
{"text": " In this case, an int is 4 bytes, my page table entry in this scenario is 8 bytes, so it would be 8 times 512, which happens to be that we can double check the size of our page. So 2 to the 9 times 2 to the 3, that's 2 to the 12, which is the exact same size as our page table entry. So any questions about this, so that our smaller page table"}
{"text": " Because we want to fit it exactly on a page, it would have 512 entries, which would be like index 0 to 511. So any questions about that before we move on? Yep."}
{"text": " So the question is, is there a standard page table entry size? And the answer to that is it depends on your CPU. On your CPU, there's a standard. But when you jump between CPUs, it may or may not change."}
{"text": " Yep. But for any questions, you'd be given the page table entry size or maybe have to explain some trade-offs. Because if I made it smaller, well, I could probably support less physical memory. But I could fit way more entries on a single page table if it was half the size or something like that."}
{"text": " OK, so let's consider just one additional level. So before, we had a 39-bit address. Well, now we'll just have a 30-bit virtual address. So if our 30-bit virtual address is something like this, 3FFFFFF and then 008, well, we're going to have the exact same page size we had before of that magical 4,096."}
{"text": " So if we divide up this address into offsets and indexes, well, we know that since our page stable size is that 2 to the 12, that we don't have to translate the last three hex digits, because they're essentially the offset into the page. And that doesn't change. We don't need to translate that part, because that part stays the same no matter what page we get. It doesn't matter."}
{"text": " And then the rest of the bits values up here, it's just all ones. So if we divide that, or if we write that in binary, we would get something like this, where every just hex digit goes to binary, four binary digits. Or if we want to break it up into different categories, it would be like this. So this,"}
{"text": " is 12 bits, that's our offset that we don't have to translate. And then we group them into groups of nine that are to index these smaller page tables. So if we start backwards, the L0 group index, which would be nine bits here, are all ones. And then we then just go to the next group of nine bits. So the next group of nine bits is also all ones. So if we go back,"}
{"text": " and we divide up our address, we get something that looks a bit like... So we get something that looks a bit like this, where our L1 index is nine bits, our L0 index is also nine bits. And then at the bottom, what I don't have to translate is the offset."}
{"text": " which is 12 bits, and I'll just keep it in hex and then write it in red. So I don't have to translate these at all. So I just grouped up my numbers, started at the back, I chopped off the offset bits so I don't have to translate, and then essentially I went in groups of nine to figure out the indexes. And as a sandy check, this is a 30-bit virtual address."}
{"text": " Oops. So if I add all my bits, 9 plus 9 plus 12, that's 30. So that's a good sandy check to make. So any questions about breaking that number up into our indexes? OK. So now is where it gets tricky, and we try and follow things."}
{"text": " Instead of each process having its own giant page table, it would have its own root page table, which would be the highest level one, which would be L1. So it would start with its own L1 page table, which has those 512 entries, and that's its page table, and that's where it starts translating this address. So."}
{"text": " Somewhere, your kernel would allocate a page for it. It would get a physical page number back, and it's free to add entries to that page. So for instance, in this case, if your kernel just gets physical page 7, well, now it's going to use physical page 7 to do as the L1 page table."}
{"text": " So because the kernel gave you back a page, well, going back to this, well, we essentially have this. We essentially have 512 page table entries we could make on that page. So somewhere in there, we would get a page back."}
{"text": " And this would be our L1 page. And it would start at physical page 7, it says. But this page is going to be, since it's a page, whoops. So since this is a page, the page we get back is at 4,096 bytes. So how many page table entries can I fit on this thing?"}
{"text": " Yeah, 512 that we just saw right there. So I can fit 512 of these because my page table entry size, again, is 8 bytes. And my total page size is 4,096. So to visualize it, instead of writing out an array, we could do it in the form of a table."}
{"text": " where it would have entries all the way from index 0, 1, 2, dot, dot, dot, to 511. And then what you would do is to translate this address, well, let's also put another column here to say if it's valid."}
{"text": " Well, to translate this address, if I look at it, my L1 index I would use to translate this address is all ones, which would be 511. So if I try and translate this address, what I would do is use my L1 index, then"}
{"text": " I would know from the kernel that this process's L1 table is located at page six or page seven or something like that. And then I would look into it and then actually look at that entry, which would be 511. And all I need is the valid bit to be on, and I can use it. And in its physical page number,"}
{"text": " it would have to point to an L0 table to use to continue the translation. So in this case, it might have something like a value of 8. So if I want to continue translating this address, it means that the next table I should look at starts on page 8. And I should consider that as an L0 page table. So any questions about that?"}
{"text": " or maybe hold off and we'll see what it looks like at the end. Yeah. Yep. Yeah, so this is in hex. Yeah, so the offset's in hex here because I don't need to translate it, so I don't really care. So I can just keep it the same."}
{"text": " Also, I ran out of room on the page to write a bunch of zeros."}
{"text": " OK, so to continue translating this address, well, I would have to look at my L1 page table. It would have an entry for that index. So the L1 index, again, is this one, which is 511. So in order to successfully translate this address to something, it would need to be valid and point to another page."}
{"text": " So it would point to another page, and let's draw what that would look like. So it would be another page that would start, in this case, at physical page 8. Again, the size of this would be the same size as a page, and it would look pretty much the same. It would have its own indices, 0, 1, 2, all the way to 500 and 11."}
{"text": " And it would have a valid bit and also the physical page number of the translation."}
{"text": " So if I wanted to continue translating this address, well, this says I should go. This is my L0 page table. So I should look at my L0 index here. And it's the same one. It's 511. So I would go ahead and look at the entry at index 511."}
{"text": " In this case, it would actually contain our translation. So let's just make up a value. So say it C-A-F-E to just make it more fun. And it would have to be valid. So if we follow this, well, now we can actually just do the same thing we did yesterday and translate the address. So what would?"}
{"text": " So what would my final address be if I have virtual? My virtual address was 3FFFF008. So now following this, what would my physical address be?"}
{"text": " So when we had a big page table, what did we do to get the final address? We just kept the offset the same and then replaced the whole physical, or the whole virtual page number with the physical page number, right? So that's, we do the same thing. This LL0 table, we treat it just like our big table. It stores the final translation. So to get our physical address, well, our offset doesn't change."}
{"text": " It's still that 008, and we just replaced the virtual part of the address with the physical part. So the physical part, excuse my writing, is this. Maybe that's why you couldn't see it. So you just replace it. So our physical address would be C-A-F-E 008. So any questions about how we got that? Yep. Sorry, could you explain again how the two tables are?"}
{"text": " Yeah, so the question is, how are the two tables connected? So each process would have its own L1 page table that stores the top level. Yeah, that just stores page table entries to a bunch of L0 tables. So you would be given something like this, that it would start at physical page 7."}
{"text": " And this would be your L1 table. And as part of decoding the address, the hardware on the CPU that we'll go over next lecture will be like, OK, well, I know I need to translate two levels of page tables. So this is my L1. Whatever value I find here, that points me to my L0. And it just knows them, and that's how they're connected. So because this is an L0, because we have two levels of page tables, well,"}
{"text": " We know we're pointing at the highest level, so this is like an L1 table. And then these entries all point to L0 page tables. And we just know that just by knowing how many levels of page tables we have."}
{"text": " Yeah, so the question is, is L0 shared between all the processes? So what we'll get into later of little tricks you can do is you could share them if you want to share memory. So if two different processes have the same L0 entry, well, then all those addresses are going to translate to the same physical addresses. And that way, both processes are going to actually get the same memory and actually start sharing memory."}
{"text": " We'll see when we do translations what we can do with that because we could have processes share memory if we want. If we don't want them to share memory, we just make sure all the L1 or L0 tables are all independent. Yep. So these are all still on physical memory."}
{"text": " Right, so this is what the kernel is maintaining, and it has to use physical memory. So all the page tables and stuff it uses, or yeah, all the storage of the page tables are done in physical memory, and they're all pages. So that's why we use, you know, why this physical page number, we just use it to say where that page is in memory. And we just use that because everything fits on a page."}
{"text": " Yeah, so page, okay, so remember physical page number, like in this case, physical page number in seven, it doesn't start at address seven because it would start at address like 7000, right? And go all the way to address 7FFF. So that's where it would be actually stored in physical memory. So if it says physical page seven, it means that all these addresses"}
{"text": " are on that same page, which to Sandy check again, well, 000 to FFF, like the difference between them is the same 4,096 bytes. So everything kind of jives. Yep. So in this case, the physical page number would actually have to be fairly long, right?"}
{"text": " So how big the physical page number is depends on whatever we want to support. So in this case, if our page table entry size is like 8 bytes, well, at least what the designers of RISC chose is to only use 44 of those bytes for the physical page number. So it can support up to 2 to the 56, like a 56 byte physical address."}
{"text": " So yeah, so the size of the page table entry determines the size of physical memory you can support, while the size of the virtual is just how much each process could actually address. Yep."}
{"text": " Yeah, so there would be two page tables here. So the first L1 page table would live on page 7 here. So L1 lives on this page, which if you translate it to physical addresses, like straight up physical addresses that we don't care about where the page is, it would be 7,000 to 7,000 FFF."}
{"text": " And then this table over here, because it starts at physical page 8, well, the addresses that represent this page are 8, 0, 0, 0, 2, 8, F, F, F. Yep? Why is it 0 to 8 and not to 8? Sorry? Why do you have to create them 0 to 8?"}
{"text": " 0x. So yeah, so what you store, you don't store the address. You just store the physical page number. Because yeah, so if my physical page number is 08, well, it means I can access all those addresses are on that same page."}
{"text": " So the way to think about it, too, is from what we've been doing to translate it is all the offset bits are for you to use for your own purposes. That's where you are within a page. So all those can be whatever you want. And the upper part of the address would be the physical page number. Yeah. Yeah."}
{"text": " Yeah, so if we go back to this, this entry here, like 511, that would be at a particular offset in the page, the same way that an integer's at a particular offset in memory. So in this case, this would always start at byte, oh God, math, 4096."}
{"text": " Yeah, so if all of our entries are eight bytes and our page is 4,096, that means entry 512 would start at byte 4,086, and that offset is the same no matter what page we're on."}
{"text": " So if this page table happened to be stored at page 9, that offset does not change. But if I were to access that entry, well, it would be at address 9FF8 or something like that."}
{"text": " Because FF8 would be the offset, so that is 4,096, and that's our physical page number. Or is that too quick binary? That might have been too quick binary. OK, so we have, yep, sorry."}
{"text": " Yeah. Yeah. Yeah."}
{"text": " Yeah, so the question is, well, in this case, my physical page table on the left is only one digit, and the other one is four hex digits. And that doesn't have any specific meaning. My page table, or my PPN, would be a certain size for both of them. In the case that we're following the RISC-V one, they're all 44 bits, and I just didn't write any leading zeros. So, yep. I'm sorry, just to clarify something. So on our slide,"}
{"text": " So this means you split it into two top blocks of 9 bits for L1 and 9 bits for L0, and they're all ones. So how does that translate to each other? They're all ones, so how does that translate to each other?"}
{"text": " Yeah, so these index bits, as part of the virtual address, don't correspond to what page you actually use to do the translation. So that's a separate thing that gets stored. So what would be stored here as part of the operating system is this part that would say that the L1 table starts on page 7. So that would be stored separately."}
{"text": " So then you combine these two things. So as part of the virtual addresses, the virtual address tells you where to index in these page tables. Yeah, so this would be within L1, where do I index? And that would be 511. And then this would mean within L0, where do I index?"}
{"text": " And then the other pieces of the puzzle to actually translate the addresses, I need to know where L1 is. So you'd be given, in this case, to translate the address, I would have to tell you where L1 is. So in this case, I said L1 starts at 7. So then you'd use that index. So if I change, yeah, so then I use L1 index. I know to go to 511 to find what I'm looking for."}
{"text": " That tells me the next piece of the puzzle. That tells me what L0 table to use. And then I go back up to my virtual address, and that answers the question, what entry in that table do I need to look at? And then once I have that, that's L0. You just do the same translation as we did with our big page table, and that gives you the address. Does that make sense, hopefully? Yeah, so L1, you said it's like a"}
{"text": " Yep."}
{"text": " Yeah, yeah, so now we know when we create a process, if each process has its own root page table, well, as part of creating a process, or new process when you fork, that's independent, the operating system's gonna have to ask for another page, and then it gets another page, and would say, I will use this page table for this process, and then it can monkey with the entries, just if you wanna share memory, or if you want to make memory independent or not, but all the page tables do is,"}
{"text": " help you translate virtual addresses to physical addresses. Right. Good. Yep."}
{"text": " the second page, which is at the 511th index would point to another page. And then, so in that case, the N2 index, which is the last time prior to the offset would be pointing to the address, the index in the final page that will tell you where the value is stored in the memory. Right now we are going through a list like a sequence of two pages, right?"}
{"text": " Yep, so let's go back to our first slide of the evening. So now we can kind of understand this a little bit better, hopefully. So for this slide, we go, we look up our virtual address, and we slice it. In this case, all of my page tables are of support 512 entries. So I start dividing it up after the offset into groups of 9 bits to the power of 9 is 512."}
{"text": " So the example we just saw was starting at L1 and going that way. But now if we were to add another level of page table, it's just the same thing, but we just do it again. So as part of our address, we would have"}
{"text": " three levels of page tables. So an L2, an L1, and an L0. And then this SATP, that's essentially the root page table that you would use for this process. So in this case, this points to an L2 page table. And then that's part of the information would be given. And then we can figure out the address. So we would use this L2 page table"}
{"text": " get the index from this part of the virtual address, and then that physical page number is going to point us to an L1 page table, so it would point us here. Now we are using this as our L1 page table, and then we get the index from the virtual address again,"}
{"text": " Then find out what entry it is. It would have a physical page number. Then it would point to an L0 page table. And then this is our lowest level page table. So it's like the big table again. So we would just take the physical page number. And then that's our physical address. And we don't touch the offset. So if we change the offset to whatever, we wouldn't change it. Yep? So if you want to add an extra level,"}
{"text": " Yeah, so that's a good question. So I'm having so much fun with all these page tables. I want to do it again. So I want to do four levels now. So you can do four levels. So let's see. So with three levels, well, our address looks like this."}
{"text": " And we'd always use nine index bits. So for a, right now it looks like we have 12 bits offset. Then we had nine bits for L0, nine bits for L1, nine bits for L2. So if you wanted to add another level, because everyone's having fun, right?"}
{"text": " You just add another nine bits here. Now, how big of a virtual address can we support if we add all those bits together? Oh."}
{"text": " Sorry? 48. So if we had so much fun that we want another level of page table, well, if we add another level, essentially, we can have a 48-bit virtual address now. That additional level lets us translate more addresses. So now we can support a 48-bit virtual address, which is massive."}
{"text": " Because a 39-bit virtual address, well, it means I can address 2 to the 39 bytes, which is 512 gigabytes. Well, about 48 bits. What's the size of my virtual address space?"}
{"text": " Anyone quick powers of 2? So 48 bit is 2 to the power of 48. Do we remember? What's the biggest unit that I could chop off some stuff? Yeah."}
{"text": " Yeah, so terabytes. So if I rewrote that, a terabyte is 2 to the 40. So I would have 2 to the 8 terabytes. Or 2 to the 8, you should know what 2 to the 8 is. So that's 256."}
{"text": " So if I added another level of page tables, suddenly every process can address up to 256 terabytes of virtual memory, which seems pretty good. It's a bigger number than 39. Why might we not want to do this? Yeah. So the answer is that my addresses take up a lot more space."}
{"text": " So we do need another level to translate an address, and it would take up a bit more space, but it would take up one additional page, which isn't too bad. Oh, yep. Why would it be slower?"}
{"text": " Yeah, so we know that all our processes use virtual memory. So as part of using virtual memory, your computer needs to do the translation. So each translation step takes time. So if I have three levels of page tables, well, I have to do three steps, which if everything scales linearly, if I add another level and now I do it four, well, I slowed it down by like 25%."}
{"text": " We have some ways to go around that. But basically, no one has above 512 gigabytes of memory anyways. So why would you pay for something you're not going to use? Yep."}
{"text": " Oh, yeah, so the question is, why is the offset 12 bits, and is it always 12 bits? So the offset always corresponds to how big of a page we have. So in this case, we have 4,096 byte pages."}
{"text": " which is to the 12, so we need 12 bits to address every single byte within a page. And we call that the offset because it would stay the same no matter what page we're on. And this would be given to you. This is the usual size on any hardware that I know of today. But fun questions you could just dream up of. I could just change the page size and tell you, oh, yeah, well, what happens now? And yep."}
{"text": " Yeah, so the question is, why do we have nine for the different levels? And the answer to that is because of our nice insight. If our memory allocator just cares in pages and we can make it really, really easy, our insight is always to use exactly a page for our smaller level page table."}
{"text": " So it's 512 only in this case, because we know our page size, and we know how big our page table entry is. So essentially, we have this equation, and you have one unknown. So you can always figure it out."}
{"text": " On any type of question or any design problem, you have this equation, and you'd always have one unknown. So I could give you the size of a page, which would be the size of our page table. And I could tell you the size of the page table entry. Then you can figure out how many entries you can fit in a page, and then"}
{"text": " The number of bits you need for the index bits comes directly from that, because you have to be able to index each one of those. So in this case,"}
{"text": " In this case, my size of the page table is 2 to the 12. The size of the page table entry is 2 to the 3, or 8 bytes. And that means the number of entries has to be 2 to the 9. So I need at least 9 bits to index every entry within that page. So the number of index bits you need is going to change depending on this. So if I say,"}
{"text": " If I suddenly say, hey, let's rewind to 20 years ago when we had 32-bit machines, well, when you had 32-bit machines, the page table entries were 4 bytes instead of 8 bytes. So if they're 4 bytes instead of 8 bytes and we still have the same page table size, well, how many entries can we store then if our page table size is 4 bytes now?"}
{"text": " So we had 2 to the 9 before when they were 8 bytes. How many when they're 4? Yeah. Yeah, 2 to the 10. So back in the day, well, we could fit more entries on a single page. And lo and behold, if we actually go back to it and we have a 32-bit machine that has a 32-bit virtual address,"}
{"text": " And we have the same page size. Well, our offset is going to be 12 bits. That's going to be our offset. And then since we can fit more entries on a page table, we can fit to the 10. So each of our index bits needs to be 10. So this would be like our L0 index."}
{"text": " And if we were just to work backwards, well, that's 10 plus 12, so that's 22 bits. So I have enough room for another level. L1 index. And it would also be 10 bits. And lo and behold, on a 32-bit machine, well, 10 plus 10 plus 12, that's 32 bits. So I can translate any 32-bit address"}
{"text": " if my page table entry size is smaller by just having two levels of page tables. So this is like the State of the Union before 64-bit machines came into the picture. This was all fine, but obviously has some limitations. But this is what it was like before. So any questions quickly on that before we wrap up? And we'll do more practice and everything tomorrow. Yep, quick."}
{"text": " Yeah. Oh, yeah. So the quick question before we leave is there is the SATP here. And that's basically a pointer to the highest level page table. So that's just a pointer to the L2 page table. What L2 page table do I need to get started in this translation? All right. Well, just remember, pulling for you, we're on the side."}
{"text": " See, I have taken this example in the previous video. So, I am going to take this example only for explaining the deletion operation. If you get how to delete data from a specific position, then you can easily get how to delete data from beginning and how to delete data from end of the array fine. So, first of all we will discuss the delete process with the help of this example, then we will write down the code fine and also we will discuss the time complexity."}
{"text": " Here I have taken these lines from the previous code only from the previous video that I have declared one array of size 50."}
{"text": " bits from 100 to 299 would be allocated 200 bytes would be allocated by the memory manager for this array one variable size fine this is the maximum size but actually suppose the user wants to insert only 10 element 5 elements then we will ask from the user how much size he wants for the array so we will ask enter the size of the array and user will enter the size so for the size also 4 bytes would be allocated somewhere in the memory suppose the here I am taking the position at the address 30"}
{"text": " 4 and then we will ask from the user the for the elements of the array we are going to initialize the array at run time. So, enter the elements of array for entering the elements loop would be started from 0 to size, size is suppose 5 here I am taking array the in limit size is 5. So, loop would be from 0 to 4 because array index would be started from 0 and we are going to populate the array."}
{"text": " like this fine I have discussed this coding in the previous video in detail so you can check out that video see now suppose user has entered this data in the array now you will ask the user from which position he wants to delete the data and now see suppose he said I want to delete the data from position 2 right so position 2 means from this position"}
{"text": " index is 1 I am taking index and position different thing index is 1 but position is what 1 2 second position so from this position I want to delete the data this 2 I want to delete so simply if you delete this 2 so now what you will do you cannot shift 6 here because this space you cannot leave it blank but one thing you can do you can shift 10 this side 4 this side and 5 this side"}
{"text": " that would be fine and after shifting these elements the size would be decreased by 1. So, after deleting this data size would become."}
{"text": " 4 right now size is 5 so we are going to shift this 10 this side this 4 this side and 5 to this location right so we are going to start a loop how you can do this see here we have 2 so we are going to start a loop from here suppose we are I am going to take a variable i i would be started from this one from which index position minus 1 i would be started from position minus 1 because position is 2 so i value is 1"}
{"text": " right till position minus 1 to here till 4 or you can say size minus 1 size is 5 so here till 4 or you can say till 3 why till 3 i'll tell you see now we are going to shift i would be started from here so now we are going to shift this value here so here what you can write this value of this array of 2 would be shifted to array of 1 so you can say i plus 1 to"}
{"text": " right so we have shifted this 10 here now again we shift this i would be incremented by 1 now i is this one now we will shift 3 value at index 3 to 2 so 4 would be shifted to here so here we will write 4."}
{"text": " fine 10 would be overwritten 10 is no more now again we are going to shift now i would be incremented i is at this place now this 5 would be i plus 1 value would be shifted to i value 5 would be shifted here so here you will write 5 so now simply you can say you can delete this one or you can say now size becomes size minus 1 so you just do size minus minus see i am going to"}
{"text": " process the loop I am going to run the loop till 3 not till 4 because when i is equal to 3 then simply we write what this a of i plus 1 that is 4 would be shifted to a of i that is 3 here only. So, no need to increment this i here."}
{"text": " we are going to run the loop from here till here only till size minus 1 that is fine fine. So, this is now the updated array and if you want to print which data you have deleted. So, what you can see before shifting this these values you can write down what you can take this value and you can store this value to somewhere you can say you can take one variable that is item and you can store here 2."}
{"text": " and after that you can print this. If you simply want to delete then no need to store this 2 value here. You simply start a for loop and start shifting these values. Start a for loop from position minus 1. So now we will write down code for this. See here size we have taken, array of size initially we have taken 5. After deletion it becomes 4. So now you want, you will ask from the user at from which position you want to delete the data."}
{"text": " fine and user will enter its position. So, you will write. So, this is how we are going to ask from the user. So, you are going to take a variable that is pose for position for storing the position fine because obviously, when user will enter the data for position then that value would be stored in memory and how value would be stored in memory using variables fine."}
{"text": " So, see now you also check see now if position is minus 1 if user entered minus 1 then what happens then obviously, there is no index of minus 1. So, we will also check the position should be a valid position and if user enter position is equal to 48."}
{"text": " so now at 48 we don't have any data fine so this is also invalid position we have data from 0 to 4th index only before deletion the data was from 0 to 4 so you can enter from 0 to 4 the position would be valid so you will also write down if statement to check the validity of this position if position is less than equal to 0"}
{"text": " or position is greater than size right then it becomes you will print invalid position. See here I am taking position would be started from 1 that is why this is position 1 so that is why I am taking position should be greater than 0 that is position would be started from 1 right and position should be"}
{"text": " less than size, size is 5. So, 1, 2, 3, 4, 5 this is the valid position only right because if you give 6 then at 6 we do not have any data right and you will also check if there is no data in this array then obviously that is under flow condition and you cannot delete the data else you will write now for loop would be started"}
{"text": " we are going to delete. See suppose position is this one. So, position"}
{"text": " 2 user has entered a value 2 for this from this position you want to delete. So, from this position only you are going to shift this to this then this value to this you are going to shift something like this. So, we are going to start a loop from i is equal to position minus 1 position is 2. So, loop would be started from 1 i is equal to 1 now and i should be less than"}
{"text": " size minus 1 minus minus i plus plus. Why i less than size minus 1? See size we have taken 5 at starting and we are going to run this i for loop till 3."}
{"text": " so till 3 means size minus 1 size minus 1 is 4 so i should be less than 4 that is till 3 we are going to run you can run this for loop till 4 that is also fine but obviously that would that would increase the time taken for computing for this for loop only fine so that is of no use so now in this case you will write what"}
{"text": " So, now here you will write the a of i plus 1 value would be shifted to a of i when i is equal to position minus 1 that is position minus 1 that is 1 i is equal to 1. So, value of this 1 plus 1 that is 2 a value of 2 would be transferred to value at 1 that is that is exactly we have done fine."}
{"text": " and now what you will do now you have done your shifting till this till this so now we will write size minus minus because size has been decremented by one now right and now at last you can print the array."}
{"text": " I guess you can print the updated arrays just write down a for loop from i is equal to 0 to size less than size now size is 4 after size minus minus this size becomes 4 right this value becomes now 4 so from 0 to 3."}
{"text": " value would be printed. i is less than size and in for loop you can write printf %d a of i. This is how we are going to delete the data. And one more thing I have told you in the previous video also that in arrays when we are discussing arrays in C then there is no concept of bound checking. It means suppose you have declared array of size 50."}
{"text": " And if here you will enter the size of array is 60 and if you start entering the data you can you can easily enter 60 elements, but that is not possible because that should not be possible right because at starting how much space has been allocated for 50 elements only for this only."}
{"text": " from 100 to this 200 bytes. So how can you store 60 elements once you have declared and as we have read that that array size is fixed once you have declared the size you cannot change the size right. So this is now the you have to check the programmer programmer have to write a code to check the boundaries of the array. So after this after entering the size you can write down one if statement if size is greater than this maximum size greater than 50 then you can print out of bound."}
{"text": " And in else block you can write further enter the elements in this for loop."}
{"text": " right and after that you can print the updated array see here no need to store this element in any at anywhere because we just want to delete the data so just shifting would be enough if you want to print which data you have deleted from the array then you can store before before this for loop you can write item suppose you will take one variable where you will store the value so you can write item is equal to a of"}
{"text": " position minus 1 position minus 1 that is a of 1 a of 1 is 2 2 would be stored in this item right and after that you can print the value deleted is and you can print you can say print percentage d and item you can print. So, if you take this case here also you are going to declare a variable item."}
{"text": " But if you do not want to print the value, you can simply ignore this one and simply write down this for loop. So, if you want to delete the data from the end of the array, then that is very easy, no shifting would be done, no need to ask for the position, no need to write down this for loop just to size minus minus right fine. And if you want to print, then you can store this value in item and you can print that value."}
{"text": " And if you want to delete from the beginning then what you will do? If you want to delete the 6 then from the beginning only you are going to start the for loop for i and all the values would be shifted here, left side. So you are going to start this for loop."}
{"text": " from i. So, updated for loop from if you want to delete from the beginning then the updated for loop would be for i is equal to 0 i would be started from 0 only and i should go less than size minus minus 1 same and i plus plus and simply write down this thing only a of i and i plus 1 and after that size minus minus."}
{"text": " because you are going to start from this position only. We know the fixed position is you are going to delete the data from 0th index. So, start from the 0 only. So, if you talk about the time taken, the time complexity, then here also the time complexity depends on the position from where you want to delete the data. If you want to delete the data from this position, then you are going to shift all the elements."}
{"text": " n theta n if you want to delete from n then obviously, theta 1. So, it depends on the position at as we have discussed in insertion case. So, theta n minus p you can write, but simple logic is see this is unsorted area. So, ordering of these elements does not matter here. So, rather than shifting we can do what the very quick algorithm is what if suppose you want to delete data from this position 2."}
{"text": " So, simply what you can do you can pick the last data from the array and you can put this data here only right and you can do size minus minus minus minus and size would be from 0 to 3. So, this is now our array."}
{"text": " and that is deletion. So, it is it will take constant time that is theta 1 order of 1 you can say, but if array is sorted in that case this ordering of the elements would matter. In that case you cannot do this thing you can directly in that case you cannot pick directly the last element and place at the position from where you want to delete the data because it will you know disturb the order of the elements in sorted array."}
{"text": " In sorted array it is must to use this process, the shifting process, but in unsorted array you can do this thing. So, the best algo will take how much time? Theta 1 or you can say order of 1. But the condition is this array should be unsorted. Here we are taking about linear array or you can say 1D array that is unsorted. In that case the best algo would take"}
{"text": " time to delete data from any position from the beginning from any specific position or from the end. So, now I am going to start the topic linked list from the next video. So, I will see you in the next video till then bye take care."}
